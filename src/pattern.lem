open import Smoosh
   
type match_result 'a =
  NoMatch
| Symbolic
| Match of 'a

type bracket_char =
  Char of char
| Collating of string
| Equiv of string
| Class of string

type bracket_entry =
  BC of bracket_char
| Range of range_char * range_char (* should only be char or collating *)

type bracket = 
  Matching of list bracket_entry
| Nonmatching of list bracket_entry

let rec parse_bracket_terminator (pat:symbolic_string) (term:char) : match_result (list char * symbolic_string) =
  match pat with
  | [] -> NoMatch
  | C(c)::C(#']')::pat' -> 
      if c = term
      then Match ([], pat')
      else NoMatch (* valid symbolic names are alpha . (alphanum|-)* (it seems per http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap06.html#tagtcjh_4)
                      so there's no way for us to have a valid x] for any x!=term *)
  | C(c)::pat' -> match parse_bracket_terminator pat' term with
               | NoMatch -> NoMatch
               | Symbolic -> Symbolic
               | Match (cs,pat'') -> Match (c::cs, pat'')
               end
  | Sym _::_ -> Symbolic
  end

let parse_bracket_class (pat:symbolic_string) (term:char) : match_result (string * symbolic_string) =
  match parse_bracket_terminator pat term with
  | NoMatch -> NoMatch
  | Symbolic -> Symbolic
  | Match (cls,pat') -> Match (toString cls, pat')
  end
                      
(* http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_05 *)
(* parsing brackets *)
let rec parse_bracket_char (pat:symbolic_string) : match_result (bracket_char * symbolic_string) =
  match pat with
  | [] -> NoMatch
  | C(#'[')::C(#'.')::pat' ->
     match parse_bracket_class pat' #'.' with
     | NoMatch -> NoMatch
     | Symbolic -> Symbolic
     | Match (cls, pat'') -> Match (Collating cls, pat'')
     end
  | C(#'[')::C(#'=')::pat' ->
     match parse_bracket_class pat' #'=' with
     | NoMatch -> NoMatch
     | Symbolic -> Symbolic
     | Match (cls, pat'') -> Match (Equiv cls, pat'')
     end
  | C(#'[')::C(#':')::pat' ->
     match parse_bracket_class pat' #':' with
     | NoMatch -> NoMatch
     | Symbolic -> Symbolic
     | Match (cls, pat'') -> Match (Class cls, pat'')
     end
  | C(c)::pat' -> Match (Char c,pat')
  | Sym _::_ -> Symbolic
  end

(* The starting range point and the ending range point shall be a
   collating element or collating symbol. An equivalence class
   expression used as a starting or ending point of a range expression
   produces unspecified results. An equivalence class can be used
   portably within a bracket expression, but only outside the
   range. If the represented set of collating elements is empty, it is
   unspecified whether the expression matches nothing, or is treated
   as invalid.

   per http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_05

   so we're just going to not parse the bracket... which means we'll treat it as raw characters.
*)

let range_bc (bc : bracket_char) : maybe range_char =
  match bc with
  | Char c -> Just (RChar c)
  | Collating cls -> Just (RCollating cls)
  | Equiv _c -> Nothing (* TODO implement *)
  | Class _c -> Nothing (* TODO implement *)
  end

let rec parse_bracket_entries (pat:symbolic_string) : match_result (list bracket_entry * symbolic_string) = 
  match pat with
  | [] -> NoMatch
  | C(#']')::pat' -> Match ([],pat')
  | _ -> match parse_bracket_char pat with
         | NoMatch -> NoMatch
         | Match (bc,C(#'-')::pat') -> 
            match parse_bracket_char pat' with
            | NoMatch -> 
               match parse_bracket_entries (C(#'-')::pat') with
               | NoMatch -> NoMatch
               | Symbolic -> Symbolic
               | Match (es,pat'') -> Match (BC bc::es,pat'')
               end
            | Symbolic -> Symbolic
            | Match (bc',pat'') -> 
               match (range_bc bc, range_bc bc', parse_bracket_entries pat'') with
               | (Just lo, Just hi, Match (es,pat''')) -> Match (Range lo hi::es,pat''')
               | (Just _, Just _, Symbolic) -> Symbolic
               | _ -> NoMatch
               end
            end
         | Match (bc,pat') ->
            match parse_bracket_entries pat' with
            | NoMatch -> NoMatch
            | Symbolic -> Symbolic
            | Match (es,pat'') -> Match (BC bc::es,pat'')
            end
         | _ -> Symbolic
         end
  end

(* If a bracket expression contains at least three list elements,
   where the first and last list elements are the same
   single-character element of <period>, <equals-sign>, or <colon>,
   then it is unspecified whether the bracket expression will be
   treated as a collating symbol, equivalence class, or character
   class, respectively; treated as a matching list expression; or
   rejected as an error. -- http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_05

   i.e., if we just have [.a.], we can treat it as matching:
      . and a
      collating symbols matching a
      an error

   we'll treat them as a range, like dash
 *)

let rec parse_bracket (neg:char) (pat:symbolic_string) : match_result (bracket * symbolic_string) = 
  match pat with
  | [] -> NoMatch
  | C(c)::pat' ->
     if c = neg
     then match parse_bracket_entries pat' with
          | NoMatch -> NoMatch
          | Symbolic -> Symbolic
          | Match (es,pat'') -> Match (Nonmatching es, pat'')
          end
     else match parse_bracket_entries (C(c)::pat') with
          | NoMatch -> NoMatch
          | Symbolic -> Symbolic
          | Match (es, pat'') -> Match (Matching es, pat'')
          end
  | Sym _::_ -> Symbolic
  end

let match_entry (lc:locale) (c : char) (be : bracket_entry) : bool = 
  match be with
  | BC (Char c')       -> c' = c
  | BC (Collating cls) -> lc.collates c cls
  | BC (Equiv cls)     -> lc.equiv c cls
  | BC (Class cls)     -> lc.charclass c cls
  | Range lo hi        -> lc.range c lo hi
  end

(* returns nothing if no match, rest of string if so *)
(* is this quite right, to account for collations? *)
let match_bracket (lc:locale) (b : bracket) (s : symbolic_string) : match_result symbolic_string =
  match (b, s) with
  | (_, [])                  -> NoMatch
  | (Matching cs,    C(c) :: s') -> if any (match_entry lc c) cs then Match s' else NoMatch
  | (Nonmatching cs, C(c) :: s') -> if any (match_entry lc c) cs then NoMatch else Match s'
  | (_, Sym _::_) -> Symbolic
  end

(* Does an EXACT pattern match. *)
let rec match_exact (lc:locale) (pat:symbolic_string) (s:symbolic_string) : match_result (symbolic_string) =
  match (pat,s) with

  (* empty pattern *)
  | ([]       ,      []) -> Match []
  | ([]       ,       _) -> NoMatch

  (* question-mark expressions *)
  | (C(#'?')::_   ,     []) -> NoMatch
  | (C(#'?')::pat', _ ::s') -> match_exact lc pat' s'

  (* star expressions *)
  | (C(#'*')::pat',     []) -> match_exact lc pat' []
  | (C(#'*')::pat', c ::s') ->
     match match_exact lc pat' (c::s') with    (* try matching empty first *)
     | NoMatch -> match_exact lc (C(#'*')::pat') s' (*   ...no dice; skip a character and go on *)
     | Symbolic -> Symbolic
     | Match s' -> Match s'                        (*   ...success; we have our answer *)
     end

  (* bracket expressions *)
  | (C(#'[')::_   ,     []) -> NoMatch (* is this an optimization? *)
  | (C(#'[')::pat', C(c)::s') ->
     match parse_bracket #'!' pat' with
     | NoMatch -> 
        (* we couldn't parse a bracket expression, so treat it as literals *)
        if c = #'[' 
        then match_exact lc pat' s'
        else NoMatch
     | Symbolic -> Symbolic
     | Match (b,pat'') -> 
        (* got a bracket expression (and some leftover pattern), match the whole string against it *)
        match match_bracket lc b (C(c)::s') with
        | NoMatch -> NoMatch                    (* couldn't match the bracket, we're done *)
        | Symbolic -> Symbolic
        | Match s'' -> match_exact lc pat'' s''  (* got it, keep going with what's left *)
        end
     end
                 
  (* TODO 2018-11-08

     "If any character (ordinary, shell special, or pattern special)
      is quoted, that pattern shall match the character itself. The
      shell special characters always require quoting."

     "When pattern matching is used where shell quote removal is not
      performed (such as in the argument to the find - name primary
      when find is being called using one of the exec functions as
      defined in the System Interfaces volume of POSIX.1-2017, or in
      the pattern argument to the fnmatch() function), special
      characters can be escaped to remove their special meaning by
      preceding them with a <backslash> character. This escaping
      <backslash> is discarded. The sequence "\\" represents one
      literal <backslash>. All of the requirements and effects of
      quoting on ordinary, shell special, and special pattern
      characters shall apply to escaping in this context."

      PICK UP HERE
   *)

  (* plain characters *)                                  
  | (   _::_,        []) -> NoMatch
  | (  c1::pat', c2::s') ->
     if c1 = c2
     then match_exact lc pat' s'
     else NoMatch
  end

(* Does matching a la %/# *)
let rec try_match_substring_loop (lc:locale) s sizes (pat : symbolic_string) (str:symbolic_string) =
  match sizes  with
  | [] -> NoMatch
  | size::sizes' -> 
     let (first,rest) = splitAt size str in
     let (substr,keep) = 
       match s with
       | Prefix -> (first,rest)
       | Suffix -> (rest,first)
       end
     in
     match match_exact lc pat substr with
     | NoMatch -> try_match_substring_loop lc s sizes' pat str
     | Symbolic -> Symbolic
     | Match _ -> Match keep
     end
  end

let try_match_substring (lc:locale) (s:substring_side) (m:substring_mode) (pat : symbolic_string) (str:symbolic_string) : symbolic_string =
  let sizes = List.genlist (fun idx -> idx) (length str + 1) in
  let ordered_sizes = 
    match (m,s) with
    | (Shortest,Prefix) -> sizes
    | (Longest, Suffix) -> sizes
    | (Longest, Prefix) -> reverse sizes
    | (Shortest,Suffix) -> reverse sizes
    end
  in
  match try_match_substring_loop lc s ordered_sizes pat str with
  | NoMatch -> str
  | Symbolic -> [Sym (SymPat s m pat str)]
  | Match str' -> str'
  end
