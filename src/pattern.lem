open import Smoosh
   
type match_result 'a =
  NoMatch
| Symbolic
| Match of 'a

type bracket_char =
  Char of char
| Collating of string
| Equiv of string
| Class of string

type bracket_entry =
  BC of bracket_char
| Range of range_char * range_char (* should only be char or collating *)

type bracket = 
  Matching of list bracket_entry
| Nonmatching of list bracket_entry

let rec parse_bracket_terminator (pat:symbolic_string) (term:char) : match_result (list char * symbolic_string) =
  match pat with
  | [] -> NoMatch
  | C(c)::C(#']')::pat' -> 
      if c = term
      then Match ([], pat')
      else NoMatch (* valid symbolic names are alpha . (alphanum|-)* (it seems per http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap06.html#tagtcjh_4)
                      so there's no way for us to have a valid x] for any x!=term *)
  | C(c)::pat' -> match parse_bracket_terminator pat' term with
               | NoMatch -> NoMatch
               | Symbolic -> Symbolic
               | Match (cs,pat'') -> Match (c::cs, pat'')
               end
  | Sym _::_ -> Symbolic
  end

let parse_bracket_class (pat:symbolic_string) (term:char) : match_result (string * symbolic_string) =
  match parse_bracket_terminator pat term with
  | NoMatch -> NoMatch
  | Symbolic -> Symbolic
  | Match (cls,pat') -> Match (toString cls, pat')
  end
                      
(* http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_05 *)
(* parsing brackets *)
let rec parse_bracket_char (pat:symbolic_string) : match_result (bracket_char * symbolic_string) =
  match pat with
  | [] -> NoMatch
  | C(#'[')::C(#'.')::pat' ->
     match parse_bracket_class pat' #'.' with
     | NoMatch -> NoMatch
     | Symbolic -> Symbolic
     | Match (cls, pat'') -> Match (Collating cls, pat'')
     end
  | C(#'[')::C(#'=')::pat' ->
     match parse_bracket_class pat' #'=' with
     | NoMatch -> NoMatch
     | Symbolic -> Symbolic
     | Match (cls, pat'') -> Match (Equiv cls, pat'')
     end
  | C(#'[')::C(#':')::pat' ->
     match parse_bracket_class pat' #':' with
     | NoMatch -> NoMatch
     | Symbolic -> Symbolic
     | Match (cls, pat'') -> Match (Class cls, pat'')
     end
  | C(c)::pat' -> Match (Char c,pat')
  | Sym _::_ -> Symbolic
  end

(* The starting range point and the ending range point shall be a
   collating element or collating symbol. An equivalence class
   expression used as a starting or ending point of a range expression
   produces unspecified results. An equivalence class can be used
   portably within a bracket expression, but only outside the
   range. If the represented set of collating elements is empty, it is
   unspecified whether the expression matches nothing, or is treated
   as invalid.

   per http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_05

   so we're just going to not parse the bracket... which means we'll treat it as raw characters.
*)

let range_bc (bc : bracket_char) : maybe range_char =
  match bc with
  | Char c -> Just (RChar c)
  | Collating cls -> Just (RCollating cls)
  | Equiv _c -> Nothing (* TODO implement *)
  | Class _c -> Nothing (* TODO implement *)
  end

let rec parse_bracket_entries (pat:symbolic_string) : match_result (list bracket_entry * symbolic_string) = 
  match pat with
  | [] -> NoMatch
  | C(#']')::pat' -> Match ([],pat')
  | _ -> match parse_bracket_char pat with
         | NoMatch -> NoMatch
         | Match (bc,C(#'-')::pat') -> 
            match parse_bracket_char pat' with
            | NoMatch -> 
               match parse_bracket_entries (C(#'-')::pat') with
               | NoMatch -> NoMatch
               | Symbolic -> Symbolic
               | Match (es,pat'') -> Match (BC bc::es,pat'')
               end
            | Symbolic -> Symbolic
            | Match (bc',pat'') -> 
               match (range_bc bc, range_bc bc', parse_bracket_entries pat'') with
               | (Just lo, Just hi, Match (es,pat''')) -> Match (Range lo hi::es,pat''')
               | (Just _, Just _, Symbolic) -> Symbolic
               | _ -> NoMatch
               end
            end
         | Match (bc,pat') ->
            match parse_bracket_entries pat' with
            | NoMatch -> NoMatch
            | Symbolic -> Symbolic
            | Match (es,pat'') -> Match (BC bc::es,pat'')
            end
         | _ -> Symbolic
         end
  end

(* If a bracket expression contains at least three list elements,
   where the first and last list elements are the same
   single-character element of <period>, <equals-sign>, or <colon>,
   then it is unspecified whether the bracket expression will be
   treated as a collating symbol, equivalence class, or character
   class, respectively; treated as a matching list expression; or
   rejected as an error. -- http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_05

   i.e., if we just have [.a.], we can treat it as matching:
      . and a
      collating symbols matching a
      an error

   we'll treat them as a range, like dash
 *)

let rec parse_bracket (neg:char) (pat:symbolic_string) : match_result (bracket * symbolic_string) = 
  match pat with
  | [] -> NoMatch
  | C(c)::pat' ->
     if c = neg
     then match parse_bracket_entries pat' with
          | NoMatch -> NoMatch
          | Symbolic -> Symbolic
          | Match (es,pat'') -> Match (Nonmatching es, pat'')
          end
     else match parse_bracket_entries (C(c)::pat') with
          | NoMatch -> NoMatch
          | Symbolic -> Symbolic
          | Match (es, pat'') -> Match (Matching es, pat'')
          end
  | Sym _::_ -> Symbolic
  end

let match_entry (lc:locale) (c : char) (be : bracket_entry) : bool = 
  match be with
  | BC (Char c')       -> c' = c
  | BC (Collating cls) -> lc.collates c cls
  | BC (Equiv cls)     -> lc.equiv c cls
  | BC (Class cls)     -> lc.charclass c cls
  | Range lo hi        -> lc.range c lo hi
  end

(* returns nothing if no match, rest of string if so *)
(* is this quite right, to account for collations? *)
let match_bracket (lc:locale) (b : bracket) (s : symbolic_string) : match_result symbolic_string =
  match (b, s) with
  | (_, [])                  -> NoMatch
  | (Matching cs,    C(c) :: s') -> if any (match_entry lc c) cs then Match s' else NoMatch
  | (Nonmatching cs, C(c) :: s') -> if any (match_entry lc c) cs then NoMatch else Match s'
  | (_, Sym _::_) -> Symbolic
  end

let rec match_prefix (lc:locale) (m:substring_mode) (pat:symbolic_string) (s:symbolic_string) : match_result (symbolic_string) =
  match (pat,s) with

  (* empty pattern *)
  | ([]       ,      []) -> Match []
  | ([]       ,       s) ->
     match m with
     | Exact -> NoMatch
     | Shortest -> Match s
     | Longest -> Match s
     end

  (* question-mark expressions *)
  | (C(#'?')::_   ,     []) -> NoMatch
  | (C(#'?')::pat', _ ::s') -> match_prefix lc m pat' s'

  (* star expressions *)
  | (C(#'*')::pat',     []) -> match_prefix lc m pat' []
  | (C(#'*')::pat', c ::s') ->
     match m with
     | Longest -> 
        match match_prefix lc m (C(#'*')::pat') s' with  (* try skipping a character first *)
        | NoMatch -> match_prefix lc m pat' (c::s')   (*   ...no dice; try to stop here *)
        | Symbolic -> Symbolic
        | Match s' -> Match s'                       (*   ...success; we have our answer *)
        end
     | Shortest ->
        match (match_prefix lc m pat' (c::s')) with    (* try matching empty first *)
        | NoMatch -> match_prefix lc m (C(#'*')::pat') s' (*   ...no dice; skip a character and go on *)
        | Symbolic -> Symbolic
        | Match s' -> Match s'                        (*   ...success; we have our answer *)
        end
     | Exact -> (* SAME AS SHORTEST *)
        match (match_prefix lc m pat' (c::s')) with    (* try matching empty first *)
        | NoMatch -> match_prefix lc m (C(#'*')::pat') s' (*   ...no dice; skip a character and go on *)
        | Symbolic -> Symbolic
        | Match s' -> Match s'                        (*   ...success; we have our answer *)
        end
    end

  (* bracket expressions *)
  | (C(#'[')::_   ,     []) -> NoMatch (* is this an optimization? *)
  | (C(#'[')::pat', C(c)::s') ->
     match parse_bracket #'!' pat' with
     | NoMatch -> 
        (* we couldn't parse a bracket expression, so treat it as literals *)
        if c = #'[' 
        then match_prefix lc m pat' s'
        else NoMatch
     | Symbolic -> Symbolic
     | Match (b,pat'') -> 
        (* got a bracket expression (and some leftover pattern), match the whole string against it *)
        match match_bracket lc b (C(c)::s') with
        | NoMatch -> NoMatch                    (* couldn't match the bracket, we're done *)
        | Symbolic -> Symbolic
        | Match s'' -> match_prefix lc m pat'' s''  (* got it, keep going with what's left *)
        end
     end
  (* plain characters *)                                  
  | (   _::_,        []) -> NoMatch
  | (  c1::pat', c2::s') ->
     if c1 = c2
     then match_prefix lc m pat' s'
     else NoMatch
  end

let try_match_prefix (lc:locale) (s:substring_side) (m:substring_mode) (pat : symbolic_string) (str:symbolic_string) : symbolic_string =
  let fixup string = 
    (* maybe reverse string to support suffix matching *)
    match s with
    | Prefix -> string
    | Suffix -> reverse string
    end in
  match match_prefix lc m (fixup pat) (fixup str) with
  | NoMatch -> str
  | Symbolic -> [Sym (SymPat s m pat str)]
  | Match str' -> fixup str'
  end
