open import Smoosh_prelude
include import Signal_platform
import Debug
                                   
(**********************************************************************)
(* OS STATE ***********************************************************)
(**********************************************************************)

type log_entry =
    LogMessage of string
  | LogConcretization of symbolic_string
  | LogUnspecified of string
  | LogUndefined of string
  | LogStep of evaluation_step

type os_state 'a = <| 
   symbolic: 'a; 
   sh: shell_state;
   log: list log_entry;
   fuel: maybe nat;
 |>                   

type step_fun 'a = 
  os_state 'a -> 
  bool (* exit status checked elsewhere? *) ->
  stmt -> 
  either (evaluation_step * os_state 'a) (evaluation_step * os_state 'a * stmt)

(**********************************************************************)
(* FS STATE ***********************************************************)
(**********************************************************************)

(* 2018-10-11 PICK UP HERE

   read_all_fd is used for backtick. 
   there it's easy to make sure the subterm has evaluated all the way.

   have Block of nat
     noop in os_state system
     acts like waitpid in os_state symbolic
   avoids issues with FIFOs filling up in the real world!
 *)

val default_block : nat
let default_block = 10 (* wait 10 steps by default *)

type read_result 'a =
    ReadError of string (* bad FD, etc. *)
  | ReadBlocked of nat (* pid of blocking process; 
                          only ever used in symbolic mode...
                          system mode just actually blocks! *)
  | ReadSuccess of 'a * bool (* EOF? *)
      
(* TODO 2018-08-14 file contents? will allow for use of, e.g., /etc/passwd *)
type file 'a = File | Dir of 'a

type file_type = 
    FileRegular 
  | FileDirectory 
  | FileCharacter
  | FileBlock
  | FileLink
  | FileFIFO
  | FileSocket

declare ocaml target_rep type file_type = `Unix.file_kind`
declare ocaml target_rep function FileRegular   = `Unix.S_REG`
declare ocaml target_rep function FileDirectory = `Unix.S_DIR`
declare ocaml target_rep function FileCharacter = `Unix.S_CHR`
declare ocaml target_rep function FileBlock     = `Unix.S_BLK`
declare ocaml target_rep function FileLink      = `Unix.S_LNK`
declare ocaml target_rep function FileFIFO      = `Unix.S_FIFO`
declare ocaml target_rep function FileSocket    = `Unix.S_SOCK`

(**********************************************************************)
(* OS CLASS ***********************************************************)
(**********************************************************************)

class ( OS 'a )

  (* SYSTEM CALLS *)
  val getpwnam : os_state 'a -> string -> maybe string
  val execve : 
    os_state 'a -> symbolic_string -> list symbolic_string -> env -> os_state 'a * stmt
  val fork_and_subshell : 
    os_state 'a -> 
    stmt -> 
    bool (* bg? [for tty] *) -> 
    os_state 'a * pid
  val exit : os_state 'a -> os_state 'a * maybe stmt
  val waitpid : 
    step_fun 'a -> (* for opportunistic scheduling in symbolic mode *)
    os_state 'a -> pid -> 
    os_state 'a * maybe (either evaluation_step (* step taken *) nat (* exit code *))  
  val handle_signal : os_state 'a -> signal -> maybe symbolic_string -> os_state 'a
  val signal_pid : os_state 'a -> signal -> pid -> os_state 'a * bool
  val times : os_state 'a -> 
              (string (* utime *)            * string (* stime *) * 
               string (* utime + children *) * string (* stime + children *))

  val get_umask : os_state 'a -> perms
  val set_umask : os_state 'a -> perms -> os_state 'a

  (* FS CALLS *)

  val physical_cwd : os_state 'a -> string
  val chdir : os_state 'a -> path -> os_state 'a * maybe string
  val readdir : os_state 'a -> path -> set (path * file unit)
  val file_exists : os_state 'a -> path -> bool

  val file_type : os_state 'a -> path -> maybe file_type
  val file_size : os_state 'a -> path -> maybe nat
  val file_perms : os_state 'a -> path -> maybe perms
  val is_tty : os_state 'a -> fd -> bool
  val is_readable : os_state 'a -> path -> bool
  val is_writeable : os_state 'a -> path -> bool
  val is_executable : os_state 'a -> path -> bool

  val write_fd : os_state 'a -> fd -> string -> maybe (os_state 'a)
  val read_all_fd : os_state 'a -> fd -> maybe (os_state 'a * string)
  val read_line_fd 
      : os_state 'a -> bool (* allow backslash escapes? *) -> fd -> 
        os_state 'a * read_result string
  val close_fd : os_state 'a -> fd -> os_state 'a

  val pipe : os_state 'a -> os_state 'a * fd * fd

  val open_file_for_redir 
      : os_state 'a -> redir_type -> symbolic_string -> 
        os_state 'a * either string fd
  val open_heredoc : os_state 'a -> string -> either string (os_state 'a * fd)
  val close_and_save_fd : os_state 'a -> fd -> os_state 'a * either string saved_fds
  val renumber_fd : os_state 'a -> 
                    bool (* close orig? *) -> 
                    fd (* orig *) -> 
                    fd (* wanted number *) -> 
                    os_state 'a * either string saved_fds
  val restore_fd : os_state 'a -> fd -> saved_fd_info -> os_state 'a

end

(**********************************************************************)
(* SHELL/OS STATE FUNCTIONS *******************************************)
(**********************************************************************)

(* Logging and fuel ***************************************************)

val tick : forall 'a. os_state 'a -> os_state 'a
let tick os =
  <| os with fuel = Maybe.map (fun n -> if n > 0 then n - 1 else 0) os.fuel |>

val out_of_fuel : forall 'a. os_state 'a -> bool
let out_of_fuel os =
  match os.fuel with
  | Nothing -> false
  | Just n -> n = 0
  end

val string_of_fuel : forall 'a. os_state 'a -> string
let string_of_fuel os =
  match os.fuel with
  | Nothing -> "unbounded"
  | Just n -> stringFromNat n
  end

val entry_unspecified : log_entry -> bool
let entry_unspecified entry =
  match entry with
  | LogUnspecified _ -> true
  | LogUndefined _ -> true
  | _ -> false
  end

val entry_undefined : log_entry -> bool
let entry_undefined entry =
  match entry with
  | LogUndefined _ -> true
  | _ -> false
  end

val try_entry_step : log_entry -> maybe evaluation_step
let try_entry_step entry =
  match entry with
  | LogStep step -> Just step
  | _ -> Nothing
  end

val in_unspecified_state : forall 'a. os_state 'a -> bool
let in_unspecified_state os = any entry_unspecified os.log

val in_undefined_state : forall 'a. os_state 'a -> bool
let in_unefined_state os = any entry_undefined os.log

val extract_trace : forall 'a. os_state 'a -> list evaluation_step
let extract_trace os = List.mapMaybe try_entry_step os.log

val log : forall 'a. log_entry -> os_state 'a -> os_state 'a
let log entry os = <| os with log = entry::os.log |>

val log_msg : forall 'a. string -> os_state 'a -> os_state 'a
let log_msg msg = log (LogMessage msg)

val log_concretization : forall 'a. symbolic_string -> os_state 'a -> os_state 'a
let log_concretization ss = log (LogConcretization ss)

val log_unspecified : forall 'a. string -> os_state 'a -> os_state 'a
let log_unspecified msg = log (LogUnspecified msg)

val log_undefined : forall 'a. string -> os_state 'a -> os_state 'a
let log_undefined msg = log (LogUndefined msg)

val log_step : forall 'a. evaluation_step -> os_state 'a -> os_state 'a
let log_step step = log (LogStep step)

val concretize 
    : forall 'a. os_state 'a -> symbolic_string -> os_state 'a * bool * string
let concretize os0 ss =
  match try_concrete ss with
  | Nothing -> (log_concretization ss os0, true, string_of_symbolic_string ss)
  | Just s -> (os0, false, s)
  end     

val concretize_many 
    : forall 'a. os_state 'a -> fields -> os_state 'a * bool * list string
let concretize_many os0 f =
  foldr 
    (fun ss (os,before,strs) ->
      let (os',now,str) = concretize os ss in
      (os', now||before, str::strs))
    (os0, false, [])
    f

val concretize_fields
    : forall 'a. os_state 'a -> fields -> os_state 'a * bool * string
let rec concretize_fields os0 f =
  match f with
  | [] -> (os0, false, "")
  | [ss] -> concretize os0 ss
  | ss::f' ->
     let (os1, concretized1, s) = concretize os0 ss in
     let (os2, concretized2, s') = concretize_fields os1 f' in
     (os2, concretized1 || concretized2, s ^ " " ^ s')
  end     

(* Reading and writing FDs ********************************************)

val try_write_fd : forall 'a. OS 'a => fd -> string -> os_state 'a -> os_state 'a
let try_write_fd fd s os =
  (* TODO 2018-03-02 is this the right behavior when an fd points to a bad fifo, e.g., STDERR is closed? *)
  match write_fd os fd s with
  | Just os' -> os'
  | Nothing -> os
  end
   
val write_stdout : forall 'a. OS 'a => string -> os_state 'a -> os_state 'a
let write_stdout = try_write_fd STDOUT

val write_stderr : forall 'a. OS 'a => string -> os_state 'a -> os_state 'a
let write_stderr = try_write_fd STDERR

(* FS and path manipulation *******************************************)

val path_dotdot_rev_cl : list char -> list char
let rec path_dotdot_rev_cl path =
  match path with
  | [] -> [#'/'] (* stop at the root *)
  | [#'/'] -> [#'/'] (* stop at the root *)
  | #'/'::rest -> rest
  | _::rest -> path_dotdot_rev_cl rest
  end
                            
val dotdot : path -> path
let dotdot path = toString (reverse (path_dotdot_rev_cl (reverse (toCharList path))))

val isdir : forall 'a. OS 'a => os_state 'a -> path -> bool
let isdir os path = file_type os path = Just FileDirectory

val canonicalize_split_path : forall 'a. OS 'a => os_state 'a -> path -> list string -> maybe string
let rec canonicalize_split_path os path components =
  match components with
  | [] -> Just path
  | ""::components' -> canonicalize_split_path os path components' (* result of // *)
  | "."::components' -> canonicalize_split_path os path components'
  | ".."::components' -> 
     if isdir os path
     then canonicalize_split_path os (dotdot path) components'
     else Nothing
  | dir::components' -> canonicalize_split_path os (join_path path dir) components'
  end

val canonicalize_path : forall 'a. OS 'a => os_state 'a -> path -> maybe path 
let canonicalize_path os path = 
  let (initial,path') =
    match (toCharList path) with
    | #'/'::#'/'::path' -> 
       ("//",toString path') (* save initial double slash---the rest will go *)
    | #'/'::path' -> ("/",toString path')
    | _ -> ("/",path)
    end
  in
  let components = split_string_on false (* not escapable *) #'/' path' in
  canonicalize_split_path os initial components

(* Job control ********************************************************)

val active_jobs : forall 'a. OS 'a => os_state 'a -> os_state 'a * list job_info
let active_jobs os0 =
  let real_jobs = List.filter is_active_job os0.sh.jobs in
  (* TODO 2018-10-02 check jobs more seriously? *)
  (* TODO 2018-10-02 announce completed jobs? *)
  (<| os0 with sh = <| os0.sh with jobs = real_jobs |> |>, 
   real_jobs)

val add_job 
    : forall 'a. OS 'a =>
        os_state 'a ->
        nat (* pid *) -> stmt (* cmd *) ->
        os_state 'a
let add_job os0 pid cmd =
  let highest_job_num = 
    match os0.sh.jobs with
    | [] -> 0
    | _ -> maximum (map (fun job -> job.id) os0.sh.jobs)
    end in
  let new_job = 
    <| id = highest_job_num + 1;
       pid = pid;
       cmd = cmd;
       status = JobRunning;
       pgrp = pid (* TODO 2018-10-02 need real pgrp numbers *) |> 
  in
  let os1 =
    if Set.member Sh_monitor os0.sh.opts
    then 
      let msg = "[" ^ stringFromNat new_job.id ^ "] " ^ stringFromNat pid ^ "\n" in
      write_stdout msg os0 
    else os0
  in
  <| os1 with sh = <| os1.sh with jobs = new_job::os1.sh.jobs |> |>

(* Redirects **********************************************************)

val redirect : forall 'a. OS 'a => os_state 'a -> expanded_redir -> 
               os_state 'a * either string saved_fds
let redirect os0 er =
  match er with
  | ERFile ty wanted_fd [sfile] -> 
     match open_file_for_redir os0 ty sfile with
     | (os1, Left err) -> (os1, Left err)
     | (os1, Right new_fd) -> renumber_fd os1 true (* close *) new_fd wanted_fd
     end
  | ERFile _ _ fs -> (os0, Left ("expected single file field, got: " ^ string_of_fields fs))
  | ERDup _ty _close_orig orig_fd Nothing ->
     (* we're meant to close orig_fd *)
     close_and_save_fd os0 orig_fd
  | ERDup _ty close_orig orig_fd (Just wanted_fd) ->
     (* dash doesn't distinguish between the two types... because
        both resolve to the same dup2 call, since dup2 doesn't care
        about fd direction *)
     renumber_fd os0 close_orig wanted_fd orig_fd
  | ERHeredoc _ty wanted_fd fs -> 
     (* ty is irrelevant at this point---we used it to determine the
        kinds of expansion we'll go through *)
     let (os1,_concretized,s) = concretize_fields os0 fs in
     match open_heredoc os1 s with
     | Left err -> (os1, Left err)
     | Right (os2, new_fd) -> renumber_fd os2 true new_fd wanted_fd
     end
  end

val restore_fds : forall 'a. OS 'a => os_state 'a -> saved_fds -> os_state 'a
let restore_fds os saved_fds =
  foldr
    (fun (orig_fd, info) os' -> restore_fd os' orig_fd info)
    os
    saved_fds 

let rec really_do_redirs os0 ers =
  match ers with
  | [] -> (os0, Right [])
  | (er::ers') ->
     match redirect os0 er with
     | (os1, Left err) -> (os1, Left err)
     | (os1, Right saved) -> 
        match really_do_redirs os1 ers' with
        | (os2, Left err) -> (os2, Left err)
        | (os2, Right saved') -> (os2, Right (saved ++ saved'))
        end
     end
  end

val do_redirs : forall 'a. OS 'a => os_state 'a -> list expanded_redir -> 
                os_state 'a * either string saved_fds
let do_redirs os0 ers =
  if Set.member Sh_noexec os0.sh.opts
  then (os0, Right [])
  else really_do_redirs os0 ers

(* Pipes and forking **************************************************)

val fork_and_execve : forall 'a. OS 'a =>
    os_state 'a -> symbolic_string -> list symbolic_string -> env -> os_state 'a * nat
let fork_and_execve s0 cmd args env =
  fork_and_subshell s0 (Exec cmd args env) false

val run_pipe_loop : forall 'a. OS 'a =>
                 os_state 'a ->
                 list stmt -> 
                 fd ->
                 bool -> (* bg? [for tty] *)
                 os_state 'a * nat
let rec run_pipe_loop s0 stmts fd_prev bg =
  match stmts with
  | [] -> fork_and_subshell s0 Done bg (* just run a trivial statement *)
  | [stmt] -> (* last one *)
     let (s1, last_pid) = 
       fork_and_subshell 
         s0 
         (with_redirs 
            stmt 
            [ERDup ToFD true (* close orig *) STDIN (Just fd_prev)])
         bg
     in
     let s2 = close_fd s1 fd_prev in
     (s2, last_pid)
  | stmt::stmts' ->
     let (s1, fd_next, fd_write) = pipe s0 in
     let (s2, _pid) =
       fork_and_subshell 
         s1
         (with_redirs 
            (close_fd_and_then fd_next stmt) 
            [ERDup ToFD true (* close orig *) STDIN (Just fd_prev )
            ;ERDup ToFD true (* close orig *) STDOUT (Just fd_write )])
         bg
     in
     let s3 = close_fd s2 fd_prev in
     let s4 = close_fd s3 fd_write in
     run_pipe_loop s4 stmts' fd_next bg
  end

(* TODO 2018-10-02 job control
   in order to supports jobs -l, need detailed pid and command info 
   if we just return a list of pids, that'll more or less cover us
   we'll probably have to change the representation of jobs, too:
     dash keeps a more detailed jobs spec, cf. jobs.h:66
   2018-10-24 in particular, we need the pids carrying forward so we can setpgid
 *)
val run_pipe : forall 'a. OS 'a =>
                 os_state 'a ->
                 list stmt ->
                 bool -> (* bg? [for tty] *)
                 os_state 'a * nat
let run_pipe s0 stmts bg =
  match stmts with
  | [] -> fork_and_subshell s0 Done bg      (* just run a trivial statement *)
  | [stmt] -> fork_and_subshell s0 stmt bg  (* trivial pipe *)
  | stmt::stmts' ->                         (* real pipe! *)
     (* set up first process *)
     let (s1, fd_next, fd_write) = pipe s0 in
     let (s2, _pid) =
       fork_and_subshell
         s1
         (with_redirs 
            (close_fd_and_then fd_next stmt)
            [ERDup ToFD true (* close orig *) STDOUT (Just fd_write)]) 
         bg
     in
     let s3 = close_fd s2 fd_write in
     (* hand off to the loop *)
     run_pipe_loop s3 stmts' fd_next bg
  end

(* Traps **************************************************************)
   
val update_trap : forall 'a. os_state 'a -> signal -> maybe symbolic_string -> os_state 'a
let update_trap os0 signal action =
  match action with
  | Nothing -> 
     <| os0 with sh = <| os0.sh with traps = Map.delete signal os0.sh.traps |> |>
  | Just cmd ->
     <| os0 with sh = <| os0.sh with traps = Map.insert signal cmd os0.sh.traps |> |>
  end

val clear_traps_for_subshell : shell_state -> shell_state * list signal
let clear_traps_for_subshell sh =
  let traps = Map_extra.toList sh.traps in
  let (ignored,handled) = 
    partition (fun (_signal,cmd) -> string_of_symbolic_string cmd = "") traps 
  in
   (* clear handled traps (but keep ignored ones) *)
  (<| sh with traps = Map.fromList ignored |>,
   (* indicate which handled traps are now cleared *)
   map fst handled)

(* Parameters and the environment *************************************)

val printable_shell_env : forall 'a. os_state 'a -> string
let printable_shell_env os = 
  foldr (fun (k, v) s -> k ^ "=" ^ quote (string_of_symbolic_string v) ^ "\n" ^ s) 
    "" 
    (Map_extra.toList os.sh.env)

val lookup_positional_param : forall 'a. nat -> os_state 'a -> maybe symbolic_string
let lookup_positional_param num os = index os.sh.positional_params num

val is_special_param : string -> bool
let is_special_param x =
  match readNat (toCharList x) with
  | Right _ -> true
  | Left _ -> elem x ["@"; "*"; "#"; "?"; "-"; "$"; "!"]
  end

(* The result is nothing if the parameter is unset, and the empty string if it's null. *)
val lookup_nonat_param : forall 'a. os_state 'a -> string -> maybe symbolic_string
let lookup_nonat_param os str =
  match (readNat (toCharList str),str) with
  | (Right num,_) -> lookup_positional_param num os
  | (Left _,"@") -> Nothing (* specifically excluded! *)
  | (Left _,"*") -> 
     match os.sh.positional_params with
     | [] -> Just []
     | _::params -> Just (symbolic_string_of_fields params)
     end
  | (Left _,"#") -> 
     let num_params = length os.sh.positional_params in
     Just (symbolic_string_of_string (stringFromNat (max 0 (num_params - 1))))
     (* number of positional arguments excluding $0 *)
  | (Left _,_) -> Map.lookup str os.sh.env
  end

val lookup_param : forall 'a. os_state 'a -> string -> maybe fields
let lookup_param os str =
  if str = "@"
  then match os.sh.positional_params with
       | [] -> Just []
       | _::params -> Just params
       end
  else match lookup_nonat_param os str with
       | Nothing -> Nothing
       | Just v -> Just [v]
       end

val lookup_concrete_param : forall 'a. os_state 'a -> string -> maybe string
let lookup_concrete_param os str =
  match lookup_param os str with
  | Nothing -> Nothing
  | Just fs -> try_concrete_fields fs
  end

val ps1 : forall 'a. os_state 'a -> string
let ps1 os =
  match lookup_concrete_param os "PS1" with
  | Nothing -> "$ "
  | Just prompt -> prompt
  end

val ps4 : forall 'a. os_state 'a -> string
let ps4 os =
  match lookup_concrete_param os "PS4" with
  | Nothing -> "+ "
  | Just prompt -> prompt
  end

val get_path : forall 'a. os_state 'a -> string
let get_path os =
  match lookup_concrete_param os "PATH" with
  | Nothing -> ""
  | Just path -> path
  end

val is_readonly : forall 'a. string -> os_state 'a -> bool
let is_readonly var os = Set.member var os.sh.readonly
   
val internal_set_param 
    : forall 'a. string -> symbolic_string -> os_state 'a -> os_state 'a
let internal_set_param x v os = 
  <| os with sh = <| os.sh with env = Map.insert x v os.sh.env |> |>

val set_param : forall 'a.
                  string -> symbolic_string -> os_state 'a -> either string (os_state 'a)
let set_param x v os0 = 
  if is_readonly x os0
  then Left (x ^ ": is read only")
  else if is_special_param x
  then Left (x ^ ": is a special parameter and not a valid identifier")
  else 
    let os1 = internal_set_param x v os0 in
    let os2 = 
      if Set.member Sh_allexport os1.sh.opts 
      then <| os1 with sh = <| os1.sh with export = Set.insert x os1.sh.export |> |>
      else os1
    in
    let os3 = 
      if x = "OPTIND" 
      then <| os2 with sh = <| os2.sh with optoff = Nothing |> |>
      else os2
    in
    Right os3

val unset_param : forall 'a. string -> os_state 'a -> os_state 'a
let unset_param x os0 = <| os0 with sh = <| os0.sh with env = Map.delete x os0.sh.env |> |>

(* Functions and positional param management **************************)

val defun : forall 'a. string -> stmt -> os_state 'a -> os_state 'a
let defun name body os = 
  <| os with sh = <| os.sh with funcs = Map.insert name body os.sh.funcs |> |>

val lookup_function : forall 'a. string -> os_state 'a -> maybe stmt
let lookup_function name os = Map.lookup name os.sh.funcs
  
val set_function_params : forall 'a. nat -> fields -> os_state 'a -> os_state 'a
let set_function_params ln argv os =
  let new_params =
    match os.sh.positional_params with
    | [] -> []::argv
    | arg0::_ -> arg0::argv
    end in
  <| os with sh = <| os.sh with loop_nest = ln; positional_params = new_params |> |>

val enter_loop : forall 'a. os_state 'a -> os_state 'a
let enter_loop os = 
  <| os with sh = <| os.sh with loop_nest = os.sh.loop_nest + 1 |> |>

val exit_loop : forall 'a. os_state 'a -> os_state 'a
let exit_loop os = 
  <| os with sh = <| os.sh with loop_nest = os.sh.loop_nest - 1 |> |>

(* Special variables ($?, $!, $-) **************************************)

val exit_with : forall 'a. nat -> os_state 'a -> os_state 'a
let exit_with ec os = 
  internal_set_param "?" (symbolic_string_of_string (stringFromNat ec)) os

val fail_with_code 
    : forall 'a. OS 'a => nat -> string -> os_state 'a -> os_state 'a
let fail_with_code ec msg os = exit_with ec (write_stderr (msg ^ "\n") os)

val fail_with : forall 'a. OS 'a => string -> os_state 'a -> os_state 'a
let fail_with = fail_with_code 1

val get_last_exit_code : forall 'a. os_state 'a -> maybe nat
let get_last_exit_code os =
  match lookup_concrete_param os "?" with
  | Nothing -> Nothing
  | Just s -> 
     match readNat (toCharList s) with
     | Right n -> Just n
     | Left _err -> Nothing
     end
  end

val get_concrete_exit_code : forall 'a. os_state 'a -> os_state 'a * nat
let get_concrete_exit_code os =
  match lookup_param os "?" with
  | Nothing -> (log_msg "missing exit code, using 254" os, 254)
  | Just f -> 
     let (os1,_,s) =  concretize_fields os f in
     match readNat (toCharList s) with
     | Right n -> (os1, n)
     | Left _err -> 
        (log_msg ("non-numeric exit code '" ^ s ^ "', using 255") os1,
         255)
     end
  end

val set_last_pid : forall 'a. nat -> os_state 'a -> os_state 'a
let set_last_pid pid os = 
  internal_set_param "!" (symbolic_string_of_string (stringFromNat pid)) os

let internal_fixup_dollardash os =
  let char_opts = List.mapMaybe char_of_sh_opt (Set_extra.toList os.sh.opts) in
  let dash = toString char_opts in
  internal_set_param "-" (symbolic_string_of_string dash) os

val set_sh_opt : forall 'a. OS 'a => os_state 'a -> sh_opt -> os_state 'a
let set_sh_opt os opt =
  let os' = 
    if List.elem opt unimplemented_sh_opts
    then
      write_stderr ("set: warning: " ^ string_of_sh_opt opt ^ " is unimplemented\n") os
    else os
  in
  internal_fixup_dollardash
    <| os' with sh = <| os.sh with opts = Set.insert opt os.sh.opts |> |>

val unset_sh_opt : forall 'a. os_state 'a -> sh_opt -> os_state 'a
let unset_sh_opt os opt =
  internal_fixup_dollardash
    <| os with sh = <| os.sh with opts = Set.delete opt os.sh.opts |> |>

val is_interactive : forall 'a. os_state 'a -> bool
let is_interactive os = Set.member Sh_interactive os.sh.opts

val is_monitoring : forall 'a. os_state 'a -> bool
let is_monitoring os = Set.member Sh_monitor os.sh.opts

(* Aliases ************************************************************)

val dash_setalias : string -> string -> unit
declare ocaml target_rep function dash_setalias = `Dash.setalias`

val dash_unalias : string -> unit
declare ocaml target_rep function dash_unalias = `Dash.unalias`

val set_alias : forall 'a. os_state 'a -> string -> string -> os_state 'a
let set_alias os name mapping =
  let _ = dash_setalias name mapping in
  <| os with sh = <| os.sh with aliases = Map.insert name mapping os.sh.aliases |> |>

val free_alias : forall 'a. os_state 'a -> string -> os_state 'a
let free_alias os name =
  let _ = dash_unalias name in
  <| os with sh = <| os.sh with aliases = Map.delete name os.sh.aliases |> |>
  
(**********************************************************************)
(* SYMBOLIC FS STATE **************************************************)
(**********************************************************************)

(* Broadly, directories map to contents, which are dir trees or files.
 * For now, fine, just using for pathname expansion.
 * TODO: Ultimately, rely on SibylFS's detailed model *)

type symbolic_fs = <|
  parent: maybe symbolic_fs;
  contents: Map.map string (file symbolic_fs)
|>

type fs = symbolic_fs (* shim *)

let symbolic_fs_dotdot fs =
  match fs.parent with
  | Nothing -> fs
  | Just fs' -> fs'
  end

let symbolic_fs_subdir fs name = 
  match Map.lookup name fs.contents with
  | Just (Dir fs) -> Just fs
  | _ -> Nothing
  end

val symbolic_fs_resolve_comps : symbolic_fs -> list string -> maybe (file symbolic_fs)
let rec symbolic_fs_resolve_comps fs comps =
  match comps with
  | [] -> Just (Dir fs)
  | ""::comps' -> symbolic_fs_resolve_comps fs comps'
  | "."::comps' -> symbolic_fs_resolve_comps fs comps'
  | ".."::comps' -> symbolic_fs_resolve_comps (symbolic_fs_dotdot fs) comps'
  | [file] -> Map.lookup file fs.contents
  | dir::comps' ->
     match symbolic_fs_subdir fs dir with
     | Just fs' -> symbolic_fs_resolve_comps fs' comps'
     | Nothing -> Nothing
     end
  end

val symbolic_fs_resolve_path : symbolic_fs -> string -> maybe (file symbolic_fs)
let symbolic_fs_resolve_path fs path =
  let comps = split_string_on false (* not escapable *) #'/' path in
  symbolic_fs_resolve_comps fs comps

val symbolic_fs_resolve_dir : symbolic_fs -> string -> maybe symbolic_fs
let symbolic_fs_resolve_dir fs path = 
  match symbolic_fs_resolve_path fs path with
  | Just (Dir fs') -> Just fs'
  | _ -> Nothing
  end

(* empty FS/OS for testing purposes *)    
let fs_empty =
  <| parent = Nothing;
     contents = Map.empty
  |>

(**********************************************************************)
(* SYMBOLIC OS STATE **************************************************)
(**********************************************************************)

(* TODO 2018-09-04 have FIFO record which end we're working on

   trickiness: renumber_fd then needs to save some of that data.
   it's bigger refactor than you'd hope
 *)
type fd_tgt = FIFO of nat | Path of path

(* Mapping of FDs numbers *)
type fds = Map.map fd fd_tgt

(* FIFO pipes for symbolic FDs *)             
type fifo = string
type fifo_num = nat

(* TODO 2018-10-22 handle process groups? *)
and proc_status = Proc_Running | Proc_Stopped

and proc =
    Shell of proc_status * stmt * shell_state * fds
  | Zombie of nat (* exit code *)

and symbolic = <|
    passwd: Map.map string string; (* TODO relate to /etc/passwd, emulate getpwnam properly in getpwdir *)
    sh_fds: fds;
    fs_root: fs;
    fifos: list fifo;
    procs: list proc;
    exited: bool;
    umask: perms
  |>

type evaluation_trace = 
  list (evaluation_step * shell_state * symbolic * stmt) * os_state symbolic
    
(* INVARIANT: the second number here is referring to the indices in os_empty.fifos below *)
let fds_default : fds = 
  Map.insert STDIN (FIFO 0) 
 (Map.insert STDOUT (FIFO 1) 
 (Map.insert STDERR (FIFO 2) 
  Map.empty))

let symbolic_empty : symbolic = <|
    sh_fds = fds_default;
    passwd = Map.empty;
    fs_root = fs_empty;
    fifos = ["" (* STDIN *)
            ;"" (* STDOUT *)
            ;"" (* STDERR *)
            ];
    procs = [];
    exited = false;
    umask = default_umask
 |>

let os_empty : os_state symbolic = 
  <| symbolic = symbolic_empty; 
     sh = default_shell_state;
     log = [];
     fuel = Just 500;
  |>
  
(**********************************************************************)
(* SYMBOLIC OS STATE INSTANCE *****************************************)
(**********************************************************************)

val compare_by_first : forall 'a 'b. Ord 'a => ('a * 'b) -> ('a * 'b) -> ordering
let compare_by_first (a, _) (a', _) = compare a a'

val symbolic_resolve_fd : symbolic -> fd -> maybe nat
let symbolic_resolve_fd symbolic fd =
  match Map.lookup fd symbolic.sh_fds with
  | Just (FIFO fifo_num) -> Just fifo_num
  (* TODO 2018-03-23 is this the right behavior when fd points to a file? *)   
  (* TODO 2018-03-02 is this the right behavior when fd doesn't exist? *)
  | _ -> Nothing
  end
    
val mkfifo : symbolic -> symbolic * fifo_num
let mkfifo symbolic =
  let fifo_num = length symbolic.fifos in
  (<| symbolic with fifos = symbolic.fifos ++ [""] |>, fifo_num)

val write_fifo : symbolic -> fifo_num -> string -> maybe (symbolic)
let write_fifo symbolic fifo_num s =
  match adjust_nth symbolic.fifos fifo_num (fun fifo_cts -> (fifo_cts ^ s, ())) with
  | Nothing -> Nothing
  | Just (new_fifos,()) -> Just <| symbolic with fifos = new_fifos |>
  end

(* TODO 2018-10-03 differentiate blocking and EOF 

   really, we should use these reads as hints to the scheduler!
*)
val read_fifo : symbolic -> fifo_num -> maybe (symbolic * string)
let read_fifo symbolic fifo_num =
  match adjust_nth symbolic.fifos fifo_num (fun fifo_cts -> ("",fifo_cts)) with
  | Nothing -> Nothing
  | Just (new_fifos,s) -> Just (<| symbolic with fifos = new_fifos |>, s)
  end

val read_char_fifo : symbolic -> fifo_num -> maybe (symbolic * char)
let read_char_fifo symbolic fifo_num =
  let get_char fifo_cts =
    match toCharList fifo_cts with
    | [] -> ("", Nothing)
    | c::cs -> (toString cs, Just c)
    end
  in
  match adjust_nth symbolic.fifos fifo_num get_char with
  | Nothing -> Nothing
  | Just (new_fifos,Just c) -> Just (<| symbolic with fifos = new_fifos |>, c)
  | Just (_, Nothing) -> Nothing
  end

val string_read_line_cl 
    : list char -> bool (* backslash escapes *) -> list char ->
      list char * list char * bool
let rec string_read_line_cl cs backslash_escapes line =
  (* dash miscbltin.c:162 ignores nullchar? *)
  match (cs, backslash_escapes) with
  (* terminator *)
  | ([], _) -> (line, [], true)
  | (#'\n'::cs', _) -> (line, cs', false)

  (* backslash *)
  | ([#'\\'], true) -> (#'\\'::line, [], true)
  | (#'\\'::#'\n'::cs, true) -> string_read_line_cl cs backslash_escapes     line
  | (#'\\'::c    ::cs, true) -> string_read_line_cl cs backslash_escapes (c::line)

  (* ordinary char *)
  | (c::cs, _) -> string_read_line_cl cs backslash_escapes (c::line)
  end

val string_read_line
    : string -> bool (* backslash escapes *) -> string * string * bool
let string_read_line s backslash_escapes =
  let (line_cs, rest, hit_eof) = 
    string_read_line_cl (toCharList s) backslash_escapes []  
  in
  (toString (reverse line_cs), toString rest, hit_eof)

val symbolic_fresh_fd : fds -> fd
let symbolic_fresh_fd sh_fds = 
  match Set.findMax (Map.domain sh_fds) with
  | Nothing -> 0
  | Just max -> max + 1
  end

(* TODO 2018-10-11 identify the writer of a given fifo_num *)
val symbolic_fds_writes_fifo : fifo_num -> fds -> bool
let symbolic_fds_writes_fifo fifo_num fds =
  let select_writers fd fd_tgt =
    match fd_tgt with
    | FIFO fifo_num' -> 
       if fd <> STDIN && fifo_num = fifo_num'
       then Just (FIFO fifo_num')
       else Nothing
    | Path _ -> Nothing
    end
  in
  (* any FDs are writing our FIFO? *)
  let writers = Map_extra.mapMaybe select_writers fds in
  not (Map.null writers)

val symbolic_writes_fifo : fifo_num -> proc -> bool
let symbolic_writes_fifo fifo_num proc =
  match proc with
  | Zombie _ -> false
  | Shell _ _ _ fds -> symbolic_fds_writes_fifo fifo_num fds
  end

val symbolic_find_writer : os_state symbolic -> fifo_num -> maybe nat (* pid *)
let symbolic_find_writer os fifo_num = 
  (* recall that symbolic PIDs are indices into the list 
     so we'll just paw through it and find the first one that's writing
   *)
  findIndex (symbolic_writes_fifo fifo_num) os.symbolic.procs

let symbolic_write_fd os fd s =
  match symbolic_resolve_fd os.symbolic fd with
  | Just fifo_num -> 
     match write_fifo os.symbolic fifo_num s with
     | Nothing -> Nothing
     | Just symbolic' -> Just <| os with symbolic = symbolic' |>
     end
  | Nothing -> Nothing
  end

let symbolic_write_stderr s os =
  match symbolic_write_fd os STDERR s with
  | Nothing -> os
  | Just os' -> os'
  end

instance (OS symbolic)
  let getpwnam os u = Map.lookup u os.symbolic.passwd

  let execve os prog argv env =                     
    (os, Exec prog argv env)

  let fork_and_subshell os stmt _bg =
    (* TODO 2018-10-24 if bg is false, this command will be controlling the terminal
       should record that in symbolic state for fancier symbolic signal handling
     *)
    let proc_num = length os.symbolic.procs in
    let (sh,_handlers) = clear_traps_for_subshell os.sh in
    let proc = Shell Proc_Running stmt sh os.symbolic.sh_fds in
    (* When a subshell is entered, traps that are not being ignored
       shall be set to the default actions, except in the case of a
       command substitution containing only a single trap command,
       when the traps need not be altered. Implementations may check
       for this case using only lexical analysis; for example, if
       `trap` and $( trap -- ) do not alter the traps in the subshell,
       cases such as assigning var=trap and then using $($var) may
       still alter them. This does not imply that the trap command
       cannot be used within the subshell to set new traps.  *) 
    (<| os with symbolic = <| os.symbolic with procs = os.symbolic.procs ++ [proc] |> |>, 
     proc_num)

  let exit os0 = 
    if os0.symbolic.exited
    then (os0, Nothing)
    else
      match Map.lookup EXIT os0.sh.traps with
      | Nothing -> (os0, Nothing)
      | Just cmd -> 
         let os1 = <| os0 with symbolic = <| os0.symbolic with exited = true |> |> in
         (os1, Just (command_eval cmd))
      end

  let waitpid step_eval os0 pid =
    match index os0.symbolic.procs pid with
    | Nothing -> (os0, Nothing)
    | Just (Zombie ec) -> (os0, Just (Right ec))
    | Just (Shell Proc_Stopped _stmt _sh' _fds') ->
       let os1 = symbolic_write_stderr ("warning: process with pid " ^ stringFromNat pid ^ " is stopped") os0 in
       (os1, Nothing)
    | Just (Shell Proc_Running stmt sh' fds') ->
       let os1 = <| os0 with sh = sh'; symbolic = <| os0.symbolic with sh_fds = fds' |> |> in
       match step_eval os1 false (* exit status not checked *) stmt with
       | Left (_step, os2) -> 
          (<| os2 with sh = os0.sh; 
                       symbolic = <| os2.symbolic with 
                                        sh_fds = os0.symbolic.sh_fds;
                                        procs = update os2.symbolic.procs pid (Zombie 1) |> |>, 
           Just (Right 1)) (* errored, signal with code *)
       | Right (_step, os2, Done) ->
          (* terminated! grab the code, update everything *)
          let ec = (* can't use get_last_exit_code because we're DEFINING the type class *)
            match Map.lookup "?" os2.sh.env with
            | Nothing -> 255
            | Just ss -> 
               match try_concrete ss with
               | Nothing -> 255
               | Just s -> 
                  match readNat (toCharList s) with
                  | Right n -> 
                     n
                  | Left _err -> 255
                  end
               end
            end in
          (<| os2 with sh = os0.sh; 
                       symbolic = <| os2.symbolic with 
                                        sh_fds = os0.symbolic.sh_fds;
                                        procs = update os2.symbolic.procs pid (Zombie ec) |> |>,
           Just (Right ec))
       | Right (step, os2, stmt') ->
          (<| os2 with sh = os0.sh; 
                       symbolic = <| os2.symbolic with 
                                        sh_fds = os0.symbolic.sh_fds;
                                        procs = 
                                          List.update os2.symbolic.procs pid 
                                            (Shell Proc_Running stmt' os2.sh os2.symbolic.sh_fds) |> |>,
           Just (Left (XSNested step (XSProc pid stmt'))))
       end
    end

  let handle_signal = update_trap

  let signal_pid os0 signal pid = 
    match index os0.symbolic.procs pid with
    | Nothing -> (os0, false)
    | Just (Zombie _ec) -> (os0, false)
    | Just (Shell _status stmt proc_sh proc_fds) ->
       match Map.lookup signal proc_sh.traps with
       | Nothing -> 
          match signal_default_behavior signal with
          | SigBeh_Terminate actions ->
             let os1 =
               if actions
               then log_unspecified "Implementation-defined abnormal termination actions, such as creation of a core file, may also occur." os0
               else os0
             in
             let ec = 128 + platform_int_of_signal signal in
             let procs' = update os1.symbolic.procs pid (Zombie ec) in
             let os2 = 
               <| os1 with symbolic = <| os1.symbolic with procs = procs' |> |>
             in
             (os2, true)
          | SigBeh_Ignore ->
             let os1 = 
               log_msg (string_of_signal signal ^ " ignored by process with pid " ^ stringFromNat pid) os0 
             in
             (os1, true)
          | SigBeh_Stop ->
             let procs' = update os0.symbolic.procs pid (Shell Proc_Stopped stmt proc_sh proc_fds ) in
             (<| os0 with symbolic = <| os0.symbolic with procs = procs' |> |>, true)
          | SigBeh_Continue ->
             let procs' = update os0.symbolic.procs pid (Shell Proc_Running stmt proc_sh proc_fds ) in
             (<| os0 with symbolic = <| os0.symbolic with procs = procs' |> |>, true)
          end
       | Just handler ->
          let os1 =
            log_msg (string_of_signal signal ^ " trapped by process with pid " ^ stringFromNat pid) os0 
          in
          let procs' = 
            update os1.symbolic.procs pid 
              (Shell Proc_Running (command_eval handler) proc_sh proc_fds)
          in
          (<| os1 with symbolic = <| os1.symbolic with procs = procs' |> |>, true)
       end
    end

  let times _os0 = ("0m0s", "0m0s", "0m0s", "0m0s")

  let get_umask os0 = os0.symbolic.umask

  let set_umask os0 mask = 
    <| os0 with symbolic = <| os0.symbolic with umask = mask |> |>

  let readdir os path =
    (* TODO 2018-08-21 will be buggy on non-absolute paths *)
    match symbolic_fs_resolve_dir os.symbolic.fs_root path with
    | Nothing -> Set.empty
    | Just fs -> 
       Set.map (fun (name,file) ->
           (name,
            match file with
            | File -> File
            | Dir _ -> Dir ()
            end))
         (* Only compare equality for the set based on the keys.
          * Comparing equality of a non-trivial file system will loop infinitely. *)
         (toSetBy compare_by_first fs.contents)
    end

  let physical_cwd os = os.sh.cwd

  let chdir os path =
    match symbolic_fs_resolve_dir os.symbolic.fs_root path with
    | Nothing -> (os,Just ("no such directory: " ^ path))
    | Just _ -> (<| os with sh = <| os.sh with cwd = path |> |>, Nothing)
    end

  (* TODO 2018-09-04 symbolic fs needs file contents/types *)
  let file_exists os path =
    match symbolic_fs_resolve_path os.symbolic.fs_root path with
    | Nothing -> false
    | Just _ -> true
    end

  let file_size os path =
    match symbolic_fs_resolve_path os.symbolic.fs_root path with
    | Nothing -> Nothing
    | Just (Dir _) -> Just 512 (* simulating result of stat call *)
    | Just File -> Just 1 (* TODO 2018-10-05 symbolic fs needs file contents *)
    end

  (* TODO 2018-10-05 symbolic fs needs perms *)
  let file_perms os path =
    match symbolic_fs_resolve_path os.symbolic.fs_root path with
    | Nothing -> Nothing
    | Just (Dir _) -> Just (invert_perms default_umask)
    | Just File -> Just (invert_perms default_umask)
    end

  let file_type os path =
    match symbolic_fs_resolve_path os.symbolic.fs_root path with
    | Nothing -> Nothing
    | Just File -> Just FileRegular
    | Just (Dir _) -> Just FileDirectory
    end

  let is_tty os fd =
    match symbolic_resolve_fd os.symbolic fd with
    | Just fifo_num ->
       (* if it points to our original TTY and we're interactive, yup! *)
       elem fifo_num [STDIN; STDOUT; STDERR] && 
       Set.member Sh_interactive os.sh.opts
    | Nothing -> false
    end

   (* TODO 2018-10-04 real permissions? *)
  let is_readable os path =
    match symbolic_fs_resolve_path os.symbolic.fs_root path with
    | Nothing -> false
    | Just _ -> true
    end

  let is_writeable os path =
    match symbolic_fs_resolve_path os.symbolic.fs_root path with
    | Nothing -> false
    | Just _ -> true
    end

  let is_executable os path =
    match symbolic_fs_resolve_path os.symbolic.fs_root path with
    | Nothing -> false
    | Just _ -> true
    end

  let write_fd = symbolic_write_fd

  let read_all_fd os fd =
    match symbolic_resolve_fd os.symbolic fd with
    | Just fifo_num -> 
       match read_fifo os.symbolic fifo_num with
       | Nothing -> Nothing
       | Just (symbolic', s) -> Just (<| os with symbolic = symbolic' |>, s)
       end
    | Nothing -> Nothing
  end

  let read_line_fd os backslash_escapes fd =
    match symbolic_resolve_fd os.symbolic fd with
    | Just fifo_num -> 
       (* look up the FIFO contents *)
       match index os.symbolic.fifos fifo_num with
       | Nothing -> (os, ReadError "broken pipe ")
       | Just cts ->
          (* try to parse a line *)
          let (line,cts',hit_eof) = string_read_line cts backslash_escapes in
          (* we'll return this value if the read is good. but it depends!
             
             if we really parsed a line (no EOF), we're good. otherwise we may
             have to block on the writing process.
           *)
          let commit_read = 
            (<| os with symbolic = 
                <| os.symbolic with 
                   fifos = update os.symbolic.fifos fifo_num cts' |> |>, 
             ReadSuccess line hit_eof)
          in
          if not hit_eof
          then 
            (* we actually parsed a line---no need to block, we have what we need 
               so we'll update the FIFO to holds cts' and return the string
             *)
            commit_read
          else
            (* found EOF. is someone still writing to this FIFO?
               if so, we need to throw away our (uncommitted) read and block.
               if not, fine: EOF it is *)
            match symbolic_find_writer os fifo_num with
            | Nothing -> commit_read
            | Just pid -> (os, ReadBlocked pid)
            end
       end
    | Nothing -> (os, ReadError ("bad file descriptor " ^ stringFromNat fd))
    end

  let close_fd os fd = 
    <| os with symbolic = <| os.symbolic with sh_fds = Map.delete fd os.symbolic.sh_fds |> |>

  let pipe os0 =
    let (sym1, fifo_num) = mkfifo os0.symbolic in
    (* get an FD number for reading *)
    let fd_read = symbolic_fresh_fd sym1.sh_fds in
    let fds' = Map.insert fd_read (FIFO fifo_num) sym1.sh_fds in
    (* get an FD number for writing *)
    let fd_write = symbolic_fresh_fd fds' in
    let fds'' = Map.insert fd_write (FIFO fifo_num) fds' in
    (<| os0 with symbolic = <| sym1 with sh_fds = fds'' |> |>, fd_read, fd_write)

  let open_file_for_redir _os _ty _file = 
    (_os, Left "symbolic file redirects are unimplemented")

  let open_heredoc os0 s =
    let (sym1, fifo_num) = mkfifo os0.symbolic in
    let fd = symbolic_fresh_fd sym1.sh_fds in
    (* update the FD map with a read FD *)
    let sym2 = <| sym1 with sh_fds = Map.insert fd (FIFO fifo_num) sym1.sh_fds |> in
    (* don't bother making a write FD, just write to the FIFO buffer *)
    match write_fifo sym2 fifo_num s with
    | Nothing -> Left "broken pipe"
    | Just sym3 -> Right (<| os0 with symbolic = sym3 |>, fd)
    end

  let close_and_save_fd os0 fd = 
    (* precomupte potential next os *)
    let sym1 = <| os0.symbolic with sh_fds = Map.delete fd os0.symbolic.sh_fds |> in
    let os1 = <| os0 with symbolic = sym1 |> in
    match Map.lookup fd os0.symbolic.sh_fds with
    | Nothing -> 
       (* already closed, nothing to save *)
       (os1, Right [])
    | Just (FIFO fifo_num) ->
       (* hold on to the FIFO number *)
       (os1, Right [(fd, Saved fifo_num)])
    | Just (Path _path) ->
       (os1, Left "TODO 2018-08-24 symbolic path FDs unimplemented")
    end

  let renumber_fd os0 close new_fd wanted_fd = 
    if new_fd = wanted_fd
    then (os0, Right (if close then [(wanted_fd, Close)] else []))
    else
      match Map.lookup new_fd os0.symbolic.sh_fds with
      | Nothing -> 
         (os0, Left "broken pipe (tried to renumber closed fd)")
      | Just new_tgt ->
        let saved = 
          match Map.lookup wanted_fd os0.symbolic.sh_fds with
          | Nothing -> 
             (* the wanted_fd is free... great! *)
             []
          | Just (FIFO fifo_num) ->
             (* the wanted fd is in use, points to a fifo... hold on to the number *)
             [(wanted_fd, Saved fifo_num)]
          | Just (Path _path) ->
             (* the wanted fd is in use, points to a file *)
             (* TODO 2018-08-24 symbolic path FDs unimplemented *)
             []
          end in
        let fds0 = Map.insert wanted_fd new_tgt os0.symbolic.sh_fds in
        let fds1 = if close then Map.delete new_fd fds0 else fds0 in
        (<| os0 with symbolic = <| os0.symbolic with sh_fds = fds1 |> |>,
         Right saved)
      end

  let restore_fd os0 fd info =
    match info with
    | Saved fifo_num -> 
       let fds = Map.insert fd (FIFO fifo_num) os0.symbolic.sh_fds in
       <| os0 with symbolic = <| os0.symbolic with sh_fds = fds |> |>
    | Close ->
       let fds = Map.delete fd os0.symbolic.sh_fds in
       <| os0 with symbolic = <| os0.symbolic with sh_fds = fds |> |>
    end
end

val set_pwdir : string -> string -> os_state symbolic -> os_state symbolic
let set_pwdir u d os = 
  <| os with symbolic = <| os.symbolic with passwd = Map.insert u d (os.symbolic.passwd) |> |>

val get_stdout : os_state symbolic -> string
let get_stdout os = fromMaybe "" (index os.symbolic.fifos 1)

val get_stderr : os_state symbolic -> string
let get_stderr os = fromMaybe "" (index os.symbolic.fifos 2)

(**********************************************************************)
(* REAL OS STATE INSTANCE *********************************************)
(**********************************************************************)

type system = unit

(* generate an 'environ'-style string given an env *)
let environ os0 (env : env) : os_state system * list string =
  foldr 
    (fun (x,v) (os,l) -> 
      let (os',_,str) = concretize os v in
      (os',(x ^ "=" ^ str) :: l))
    (os0,[])
    (Map_extra.toList env)

val real_getpwnam : string -> maybe string
declare ocaml target_rep function real_getpwnam = `System.real_getpwnam`

val real_execve : forall 'a. string -> list string -> list string -> 'a
declare ocaml target_rep function real_execve = `System.real_execve`

val real_fork_and_eval : list int -> os_state system -> stmt -> bool -> nat
declare ocaml target_rep function real_fork_and_eval = `System.real_fork_and_eval`

val real_waitpid : nat (* rootpid *) -> nat (* pid *) -> nat (* ec *)
declare ocaml target_rep function real_waitpid = `System.real_waitpid`

val real_handle_signal : int -> maybe string -> unit
declare ocaml target_rep function real_handle_signal = `System.real_handle_signal`

val real_signal_pid : int -> nat -> bool
declare ocaml target_rep function real_signal_pid = `System.real_signal_pid`

val real_exit : forall 'a. nat -> 'a
declare ocaml target_rep function real_exit = `exit`

val real_times : unit -> string * string * string * string
declare ocaml target_rep function real_times = `System.real_times`

val real_get_umask : unit -> nat
declare ocaml target_rep function real_get_umask = `System.real_get_umask`

val real_set_umask : nat -> unit
declare ocaml target_rep function real_set_umask = `System.real_set_umask`

val real_physical_cwd : unit -> string
declare ocaml target_rep function real_physical_cwd = `Unix.getcwd`

val real_chdir : path -> maybe string
declare ocaml target_rep function real_chdir = `System.real_chdir`

val real_file_exists : path -> bool
declare ocaml target_rep function real_file_exists = `System.real_file_exists`

val real_file_size : path -> maybe nat
declare ocaml target_rep function real_file_size = `System.real_file_size`

val real_file_perms : path -> maybe nat
declare ocaml target_rep function real_file_perms = `System.real_file_perms`

val real_file_type : path -> maybe file_type
declare ocaml target_rep function real_file_type = `System.real_file_type`

val real_is_tty : fd -> bool
declare ocaml target_rep function real_is_tty = `System.real_is_tty`

val real_is_readable : path -> bool
declare ocaml target_rep function real_is_readable = `System.real_is_readable`

val real_is_writeable : path -> bool
declare ocaml target_rep function real_is_writeable = `System.real_is_writeable`

val real_is_executable : path -> bool
declare ocaml target_rep function real_is_executable = `System.real_is_executable`

val real_readdir : string -> list (string * bool)
declare ocaml target_rep function real_readdir = `System.real_readdir`

val real_write_fd : fd -> string -> bool
declare ocaml target_rep function real_write_fd = `System.real_write_fd`

val real_read_all_fd : fd -> maybe string
declare ocaml target_rep function real_read_all_fd = `System.real_read_all_fd`

val real_read_line_fd : bool -> fd -> either string (string * bool)
declare ocaml target_rep function real_read_line_fd = `System.real_read_line_fd`

val real_pipe : unit -> fd * fd
declare ocaml target_rep function real_pipe = `System.real_pipe`

type open_flags
declare ocaml target_rep type open_flags = `System.open_flags` 
val to_flags : open_flags
declare ocaml target_rep function to_flags = `System.to_flags`
val clobber_flags : open_flags
declare ocaml target_rep function clobber_flags = `System.clobber_flags`
val from_flags : open_flags   
declare ocaml target_rep function from_flags = `System.from_flags`
val fromto_flags : open_flags
declare ocaml target_rep function fromto_flags = `System.fromto_flags`
val append_flags : open_flags
declare ocaml target_rep function append_flags = `System.append_flags`

val flags_of_redir_type : forall 'a. os_state 'a -> redir_type -> open_flags
let flags_of_redir_type s0 rt =
  match rt with
  | To -> if Set.member Sh_noclobber s0.sh.opts then to_flags else clobber_flags
  | Clobber -> clobber_flags
  | From -> from_flags
  | FromTo -> fromto_flags
  | Append -> append_flags
  end

val real_open : string -> open_flags -> either string fd
declare ocaml target_rep function real_open = `System.real_open`

val real_close : fd -> unit
declare ocaml target_rep function real_close = `System.real_close`

val real_savefd : fd -> either string fd
declare ocaml target_rep function real_savefd = `System.real_savefd`

val real_dup2 : fd -> fd -> maybe string
declare ocaml target_rep function real_dup2 = `System.real_dup2`

val real_openhere : string -> either string fd
declare ocaml target_rep function real_openhere = `System.real_openhere`

let real_close_and_save_fd fd =
  match real_savefd fd with
  | Left err -> Left err
  | Right saved_fd ->
     let () = real_close fd in
     Right [(fd,Saved saved_fd)]
  end

let real_renumber_fd (close : bool) (new_fd : fd) (wanted_fd : fd) =
  if new_fd = wanted_fd
  then 
    (* we fished our wish! no need to dup or anything.
       just remember to clean up when you're done *)
    Right (if close then [(wanted_fd,Close)] else [])
    else (* need to save wanted_fd and then dup *)
      match real_savefd wanted_fd with
      | Left err -> Left err
      | Right saved_fd -> 
         match real_dup2 new_fd wanted_fd with
         | Just err -> Left err
         | Nothing -> 
            (* close the actual fd we got, now that we've
               relocated it where we want it *)
            let () = if close then real_close new_fd else () in
            Right [(wanted_fd, Saved saved_fd)]
         end
      end

instance (OS unit)
  let getpwnam _os nam = real_getpwnam nam
                       
  let execve os0 sprog sargv senv =
    let (os1,_,prog) = concretize os0 sprog in
    let (os2,_,argv) = concretize_many os1 sargv in
    let (os3,env) = environ os2 senv in
    (os3, real_execve prog argv env)

  let fork_and_subshell os stmt bg =
    let (subsh,handlers) = clear_traps_for_subshell os.sh in
    (* When a subshell is entered, traps that are not being ignored
       shall be set to the default actions, except in the case of a
       command substitution containing only a single trap command,
       when the traps need not be altered. Implementations may check
       for this case using only lexical analysis; for example, if
       `trap` and $( trap -- ) do not alter the traps in the subshell,
       cases such as assigning var=trap and then using $($var) may
       still alter them. This does not imply that the trap command
       cannot be used within the subshell to set new traps.  *) 
    let pid = 
      real_fork_and_eval 
        (List.mapMaybe ocaml_signal_of_signal handlers) (* ignore these signals! *)
        (<| os with sh = subsh |>) (* update the traps *)
        stmt
        bg
    in
    (os, pid)

  let physical_cwd _os = real_physical_cwd ()

  let chdir os path =
    match real_chdir path with
    | Nothing -> (<| os with sh = <| os.sh with cwd = path |> |>, Nothing)
    | Just err -> (os, Just err)
    end
      
  let file_exists _os path = real_file_exists path

  let file_size _os path = real_file_size path

  let file_perms _os path = 
    match real_file_perms path with
    | Nothing -> Nothing
    | Just num_perms -> Just (perms_of_nat num_perms)
    end

  let file_type _os path = real_file_type path

  let is_tty _os fd = real_is_tty fd

  let is_readable _os path = real_is_readable path
  let is_writeable _os path = real_is_writeable path
  let is_executable _os path = real_is_executable path

  let readdir _os path = 
    let contents = real_readdir path in
    let convert (f,is_dir) = (f,if is_dir then Dir () else File) in
    Set.fromList (map convert contents)

  let write_fd os fd s =
    if real_write_fd fd s
    then Just os
    else Nothing

  let read_all_fd os fd =
    match real_read_all_fd fd with
    | Nothing -> Nothing
    | Just s -> Just (os,s)
    end

  let read_line_fd os backslash_escapes fd =
    match real_read_line_fd backslash_escapes fd with
    | Left err -> (os, ReadError err)
    | Right (s, hit_eof) -> (os, ReadSuccess s hit_eof)
    end

  let close_fd os fd =
    let () = real_close fd in
    os

  let pipe os =
    let (fd_read, fd_write) = real_pipe () in
    (os, fd_read, fd_write)

  let exit os =
    let ec = 
      match Map.lookup "?" os.sh.env with
      | Nothing -> 127
      | Just ss -> 
         match try_concrete ss with
         | Nothing -> 128
         | Just s -> 
            match readNat (toCharList s) with
            | Right n -> n
            | Left _err -> 2
            end
         end
      end in
    real_exit ec

  let waitpid _step_eval os pid =
    let code = real_waitpid os.sh.rootpid pid in
    (os, Just (Right code))

  let handle_signal os0 signal action =
    let s1 = update_trap os0 signal action in
    let actual_action =
      match action with
      | Nothing -> Nothing
      | Just ss -> Just (string_of_symbolic_string ss)
      end
    in
    let _ = 
      match ocaml_signal_of_signal signal with
      | Nothing -> ()
      | Just ocaml_signal -> 
         real_handle_signal ocaml_signal actual_action 
      end 
    in
    s1

  let signal_pid os0 signal pid =
    match ocaml_signal_of_signal signal with
    | Nothing -> (os0, false)
    | Just ocaml_signal ->
       let success = real_signal_pid ocaml_signal pid in
       (os0, success)
    end

  let times _os = real_times ()

  let get_umask _os = 
    let umask = real_get_umask () in
    perms_of_nat umask

  let set_umask os mask = 
    let _ = real_set_umask (nat_of_perms mask) in
    os

  let open_file_for_redir os0 ty sfile =
    let flags = flags_of_redir_type os0 ty in
    let (os1,_,file) = concretize os0 sfile in
    (os1,
     match real_open file flags with
     | Left err -> Left err
     | Right new_fd -> Right new_fd
     end)
   
  let open_heredoc os s =
    match real_openhere s with
    | Left err -> Left err
    | Right fd -> Right (os, fd)
    end

  let close_and_save_fd os fd = 
    (os, real_close_and_save_fd fd)

  let renumber_fd os close new_fd wanted_fd = 
    (os, real_renumber_fd close new_fd wanted_fd)

  let restore_fd os orig_fd info =
    let to_close = 
      match info with
      | Saved saved -> 
         match real_dup2 saved orig_fd with
         | Just _err -> saved (* TODO 2018-08-24 uh oh... signal in some way? *)
         | Nothing -> saved
         end
      | Close -> 
         orig_fd
      end
    in
    let _ = real_close to_close in
    os    

end

val real_set_sh_opt : os_state system -> sh_opt -> os_state system
let real_set_sh_opt os opt = set_sh_opt os opt

val real_ignore_signal : os_state system -> signal -> os_state system
let real_ignore_signal os0 signal =
  handle_signal os0 signal (Just [])
