open import Smoosh

open import Fields (* late stage expansion *)
open import Arith
open import Pattern
open import Command

import Debug

(**********************************************************************)   
(* SHARED DECLARATIONS FOR EXPANSION AND EVALUATION *******************)   
(**********************************************************************)   

(* TECHNICAL DEBT 2019-03-04 just have an opts record *)

type string_mode =
    UserString
  | GeneratedString

type quoting_mode =
    Unquoted
  | Quoted

type redir_exp_result 'a =
    REDone of 'a * expanded_redir
  | REError of fields
  | REStep of expansion_step * 'a * expanding_redir

type step_assign_result 'a =
    SADone of list (string * fields)
  | SAError of fields
  | SAStep of evaluation_step * os_state 'a * list (string * expansion_state)
            
val expand_control : forall 'a. OS 'a => 
                     os_state 'a -> splitting_mode -> quoting_mode -> tilde_mode -> control ->
                     either (expansion_step * os_state 'a * expanded_words) 
                            (expansion_step * os_state 'a * tilde_mode * expanded_words * words) 
val expand_words : forall 'a. OS 'a => 
                   os_state 'a -> splitting_mode -> quoting_mode -> tilde_mode -> string_mode -> 
                   (expanded_words * words) ->
                   either (expansion_step * os_state 'a * expanded_words) 
                          (expansion_step * os_state 'a * tilde_mode * expanded_words * words) 
val step_expansion : forall 'a. OS 'a =>
                     os_state 'a * expansion_state -> 
                     expansion_step * os_state 'a * expansion_state 
val step_redir : forall 'a. OS 'a => 
                   os_state 'a -> expanding_redir -> redir_exp_result (os_state 'a)
val step_redir_state : forall 'a. OS 'a => os_state 'a -> redir_state -> 
                       os_state 'a * string * maybe (redir_state * maybe expansion_step)
val step_assign : forall 'a. OS 'a => 
                    os_state 'a -> list (string * expansion_state) ->
                    step_assign_result 'a
val check_traps : forall 'a. OS 'a => step_result 'a -> step_result 'a (* see os.lem for defn *)
val expansion_error : forall 'a. OS 'a => bool (* may exit? *) -> os_state 'a -> evaluation_step -> expansion_step -> fields -> step_result 'a (* see os.lem for defn *)
val step_eval : forall 'a. OS 'a => step_fun 'a (* see os.lem for defn *)

val full_evaluation : forall 'a. OS 'a => os_state 'a -> stmt -> os_state 'a
val eval : forall 'a. OS 'a => os_state 'a -> stmt -> nat

(**********************************************************************)   
(* TRAP MANAGEMENT ****************************************************)   
(**********************************************************************)   

let rec internal_check_traps step s0 c =
  match pending_signal s0 with
  | (s1, Nothing) -> (step, s1, c)
  | (s1, Just signal) ->
     match Map.lookup signal s1.sh.traps with
     | Nothing -> internal_check_traps step s1 c
     | Just ss_handler ->
        let (s2,_,s_handler) = concretize s1 ss_handler in
        let src = ParseString ParseTrap s_handler in
        let sstr = parse_init src in
        let c_handler =                    
          EvalLoop 1 (sstr, Just (stack_init ())) src 
            Noninteractive Subsidiary
        in
        (XSNested (XSTrap signal "trapped") step, 
         s2, 
         Trapped signal s2.sh.exit_code c_handler c)
     end
  end

let check_traps res =
  match res with
  | Left _ -> res
  | Right (_,_,Exit) -> res
  | Right (step0,s0,c0) -> 
     let s1 = log_msg "checked traps" s0 in
     Right (internal_check_traps step0 s1 c0)
  end

let expansion_error may_exit s0 evalstep expstep err =
  let msg = string_of_symbolic_string (symbolic_string_of_fields err) in
  let s1 = fail_with msg s0 in
  check_traps (Right ((XSExpand evalstep expstep),
                      s1,
                      if may_exit && is_interactive s1 then Done else Exit))

(**********************************************************************)   
(* EXPANSION **********************************************************)   
(**********************************************************************)   
   
(*
 * Stage 1 Expansion: Word expansion
 *)

val expand_param : forall 'a. OS 'a => os_state 'a -> splitting_mode -> quoting_mode -> string -> format -> os_state 'a * expanded_words * words

(* TODO 2017-12-01
 * In an N____ case, when null_string fs is Nothing, the
 * string is entirely symbolic so we need
 * to represent the symbolic result of "it could be either
 * true or false, we don't know". This means we need to branch
 * and allow for both cases to progress.
 *)
let expand_param s0 split q str f =
  (* return type says we yield `expanded_words * words`, but really
     only one or the other these functions package up the possible
     bits of logic *)
  let (s1, value) =
    if str = "*" && (q = Quoted || not (should_split split))
    then 
      let (s1, sep) = 
        match lookup_string_param s0 "IFS" with
        | Nothing -> (s0,[C #' '])
        | Just ss ->
           let (s1,_,ifs) = concretize s0 ss in
           match toCharList ifs with
           | [] -> (s1, [])
           | c::_ -> (s1, [C c])
           end
        end 
      in
      (s1, Just [symbolic_string_of_fields_sep sep (get_function_params s1)])
    else
      (s0, lookup_param s0 str)
  in
  let cstr s  = (s1, [ExpS s], []) in
  let ewfs fs = (s1, expanded_words_of_fields fs, []) in
  let wrds w  = (s1, [], w) in
  let ctrl k  = (s1, [], [K k]) in
  if not (elem str ["@"; "*"]) && 
     Set.member Sh_nounset s0.sh.opts &&
     value = Nothing
  then ctrl (LError str [ExpS "parameter not set"] [])
  else match (value, f) with
  (* NORMAL *)
  | (Nothing, Normal)     -> wrds [] (* unset, no field *)
  | (Just fs, Normal)     -> ewfs fs
  (* DEFAULT *)
  | (Nothing, Default w)  -> wrds w
  | (Just fs, Default _)  -> ewfs fs
  | (Nothing, NDefault w) -> wrds w
  | (Just fs, NDefault w) ->
     match null_fields fs with
     | Nothing -> 
        let s2 = log_msg "Unsoundly treating symbolic fields as non-empty" s1 in
        (s2, expanded_words_of_fields fs, [])
     | Just true -> wrds w
     | Just false -> ewfs fs
     end
  (* ASSIGN *)
  | (Nothing, Assign w)  -> ctrl (LAssign str [] w)
  | (Just fs, Assign _)  -> ewfs fs       
  | (Nothing, NAssign w) -> ctrl (LAssign str [] w)
  | (Just fs, NAssign w) -> 
     match null_fields fs with
     | Nothing -> ewfs fs
     | Just true -> ctrl (LAssign str [] w)
     | Just false -> ewfs fs
     end
  (* ERROR *)
  | (Nothing, Error w)  -> ctrl (LError str [] w)
  | (Just fs, Error _)  -> ewfs fs
  | (Nothing, NError w) -> ctrl (LError str [] w)
  | (Just fs, NError w) -> 
     match null_fields fs with
     | Nothing -> 
        let s2 = log_msg "Unsoundly treating symbolic fields as non-empty" s1 in
        (s2, expanded_words_of_fields fs, [])
     | Just true -> ctrl (LError str [] w)
     | Just false -> ewfs fs
     end
  (* LENGTH *)
  | (Nothing, Length) -> cstr "0"
  | (Just fs, Length) ->
     (* TODO 2018-10-08 need to return a new state to support logging of concretization *)
     match try_concrete_fields fs with
     | Nothing -> (* TODO This should be the length of the symbolic result of fs *) cstr "0"
     | Just strs -> cstr (show (stringLength strs))
     end
  (* ALT *)
  | (Nothing, Alt _)  -> cstr ""
  | (Just _, Alt w)  -> wrds w
  | (Nothing, NAlt _) -> cstr ""
  | (Just fs, NAlt w) ->
     match null_fields fs with
     | Nothing -> 
        let s2 = log_msg "Unsoundly treating symbolic fields as non-empty" s1 in
        (s2, [], w)
     | Just true -> cstr ""
     | Just false -> wrds w
     end
  (* SUBTRINGS (prefix/suffix) *)
  | (Nothing, Substring _ _ _) -> cstr ""
  | (Just fs, Substring s m w) -> ctrl (LMatch fs s m [] w)
  end

let rec expand_control s0 split q tm k =
    match k with
    | Tilde -> 
       if tm = YesTilde then
         let (msg, dir) = match lookup_concrete_param s0 "HOME" with
         (* if HOME is unset, results are unspecified---we return "~" 
            dash:
              $ unset HOME
              $ echo ~
              ~
              $ HOME=""
              $ echo ~
              ~
              $ HOME="/Users/mgree"
              $ echo ~
              /Users/mgree

            bash:
              $ unset HOME
              $ echo ~
              /Users/mgree
              $ HOME=""
              $ echo ~
              
              $ HOME="/Users/mgree"
              $ echo ~
              /Users/mgree            

            lol
          *)
           | Nothing -> ("defaulting to dash behavior for unset HOME (unspec per 2.6.1)", 
                         ExpS "~")
           | Just dir -> ("", ExpS dir)
           end in
           Right (ESTilde msg, s0, YesTilde, [dir], [])
        else Right (ESTilde "skipped tilde expansion", s0, NoTilde, [ExpS "~"], [])
    | TildeUser usr -> 
       if tm = YesTilde
       then
         match getpwnam s0 usr with
         | Nothing ->
            (* unspec per 2.6.1, but we follow dash *)
            Right (ESTilde ("defaulting to dash behavior for failed getpwnam " ^
                            "(unspec per 2.6.1)"), 
                   s0, YesTilde, [ExpS ("~" ^ usr)], []) 
         | Just path -> Right (ESTilde "", s0, YesTilde, [ExpS path], [])
         end
       else Right (ESTilde "skipped tilde expansion", s0, NoTilde, [ExpS ("~" ^ usr)], [])
    | Param s f -> 
       (* We special case logic for "$@" here. The rest is in expand_param. *)
       if s = "@" && q = Quoted
       then 
         let param_vars = get_function_params s0 in
         (* -, = and ? can adhere when no params set
            + should always just expand the words, since $@ is never unset/null
            # should expand everything, convert to a string, and count. same as *.
            %/%% operates on the last param and #/## on the first param (in dash)
          *)
         let unspec =
           match f with
           | Length -> true
           | Substring _ _ _ -> true
           | _ -> false
           end
         in
         let s1 =
           if unspec 
           then log_unspecified 
                  ("Unspecified parameter format: " ^ string_of_control (Param s f))
                  s0
           else s0
         in
         let expand_more w = expand_words s1 split q NoTilde GeneratedString ([],w) in
         let build_at v = Right (ESParam "expanding @", s1, NoTilde, [At v], []) in
         match f with
         | Default _ -> build_at param_vars
         | NDefault w ->
            if null param_vars
            then expand_more w
            else build_at param_vars
         | Assign _ -> build_at param_vars
         | NAssign _ -> 
            if null param_vars
            then expand_more [K (LError "@" [ExpS "bad variable name"] [])]
            else build_at param_vars
         | Error _ -> build_at param_vars
         | NError w ->
            if null param_vars
            then expand_more [K (LError "@" [] w)]
            else build_at param_vars
         | Length -> expand_more [K (Param "*" Length)]
         | Alt w -> expand_more w
         | NAlt w -> 
            if null param_vars
            then build_at param_vars
            else expand_more w
         | Substring Prefix mode w -> 
            match param_vars with
            | v1::vars -> 
               let v1' = K (Quote [] [K (LMatch [v1] Prefix mode [] w)]) in
               expand_more (v1'::words_of_fields vars)
            | _ -> build_at []
            end
         | Substring Suffix mode w ->
            match dest_init param_vars with
            | Just (vars', vn) -> 
               let vn' = K (Quote [] [K (LMatch [vn] Suffix mode [] w)]) in
               expand_more (words_of_fields vars' ++ [vn'])
            | Nothing -> build_at []
            end
         | _ -> build_at param_vars
         end
       else 
         let (s1, ew, w) = expand_param s0 split q s f in
         expand_words s1 split q YesTilde GeneratedString (ew, w)
    | LAssign s f [] ->
       match set_param s (concat_expanded f) s0 with
       | Left err -> Left (ESParam "bad or readonly variable", s0, ExpS err::f)
       | Right s1 -> Right (ESParam "finished assignment", s1, NoTilde, f, [])
       end
    | LAssign s f w ->
       let tm' = if f = [] then YesTilde else NoTilde in
       match expand_words s0 NoSplit q tm' GeneratedString ([], w) with
       | Right (step, s1, tm1, f1, w1) ->
          Right (ESNested (ESParam "assignment") step, 
                 s1, tm1, [], [K (LAssign s (f ++ f1) w1)])
       | Left err -> Left err
       end
    | LMatch str side mode f [] -> 
       let sympat = symbolic_string_of_expanded_words false (* don't keep quotes *) f in
       let symstr = symbolic_string_of_fields str in
       let (s1,_concretized,pat) = concretize s0 sympat in
       let matched = try_match_substring s1.sh.locale side mode pat symstr in
       Right (ESParam "finished match", 
              s1, NoTilde, [], 
              words_of_symbolic_string matched)
    | LMatch s side mode f w ->
       let tm' = if f = [] then YesTilde else NoTilde in
       match expand_words s0 NoSplit q tm' GeneratedString ([], w) with
       | Right (step, s1, tm1, f1, w1) -> 
          Right (ESNested (ESParam "match") step, 
                 s1, tm1, [], [K (LMatch s side mode (f ++ f1) w1)])
       | Left err -> Left err
       end
    | LError str f [] -> 
       (* dash seems to print erroring variable name; TODO should we also have linno? *)
       Left (ESParam "raising requested error", s0, ExpS (str ^ ": ")::f) 
    | LError str f w ->
       let tm' = if f = [] then YesTilde else NoTilde in
       match expand_words s0 NoSplit q tm' GeneratedString ([], w) with
       | Right (step, s1, tm1, f1, w1) -> 
          Right (ESNested (ESParam "error") step, 
                 s1, tm1, [], [K (LError str (f ++ f1) w1)])
       | Left err -> Left err
       end
    | Backtick c ->
       (* create a pipe *)
       let (s1, fd_read, fd_write) = pipe s0 in
       let cmd = 
         pushredir 
           (* set up redirects [skipping expansion] *)
           (with_redirs c [ERDup ToFD CloseOrig STDOUT (Just fd_write)])
           (* make sure to close the pipe when we're done *)
           [(fd_write, Close)]
       in
       let (s2, pid) = 
         fork_and_subshell s1 cmd 
           FG Nothing (* no pgid *) false (* no job control *) 
       in
       Right (ESCommand "initializing subshell", 
              s2,
              NoTilde,
              [], 
              [K (LBacktick c pid fd_read)])
    | LBacktick corig pid fd_read ->
        match read_all_fd step_eval s0 fd_read with
        | (s1, Left step) ->
           Right (ESEval (ESCommand ("process with pid " ^ stringFromNat pid ^ " stepped"))
                    step,
                  s1,
                  NoTilde,
                  [],
                  [K (LBacktick corig pid fd_read)])
        | (s1, Right Nothing) -> 
           Left (ESCommand "broken pipe",
                 s1,
                 [])
        | (s1, Right (Just s)) ->
           (* "If the output contains any null bytes, the behavior is
              unspecified."

              "Any valid shell script can be used for command, except a
              script consisting solely of redirections which produces
              unspecified results."

            *)
           let s2 = close_fd s1 fd_read in
           let s_trimmed = trimr_newlines s in
           (* "If there is no command name, but the command contained
              a command substitution, the command shall complete with
              the exit status of the last command substitution
              performed." *)
           Right (ESCommand "command exited successfully, waiting",
                  s2, 
                  NoTilde,
                  [], 
                  [K (LBacktickWait corig pid s_trimmed)])
        end
    | LBacktickWait corig pid s ->
        match wait_for_pid step_eval s0 pid with
        | (s1, Nothing) ->
           Right (ESCommand "command process vanished, leaving exit code unset",
                  s1,
                  NoTilde,
                  [ExpS s],
                  [])
        | (s1, Just (Left step)) ->
           Right (ESEval (ESCommand "command process stepped") step,
                  s1,
                  NoTilde,
                  [],
                  [K (LBacktickWait corig pid s)])
        | (s1, Just (Right code)) ->
           Right (ESCommand "command process terminated",
                  exit_with code s1,
                  NoTilde,
                  [ExpS s],
                  [])
        end
    | Arith f [] ->
        match arith64 s0 (concat_expanded f) with
        | Right (s1, result) -> 
           Right (ESArith "computed arithmetic result", 
                  s1, NoTilde, expanded_words_of_fields result, [])
        | Left e -> Left (ESArith "arithmetic error", s0, [ExpS e])
        end
    | Arith f w ->
       match expand_words s0 split q YesTilde GeneratedString ([],w) with
       | Right (step, s1, tm1, f1, w1) -> 
          Right (ESNested (ESArith "before arithmetic parsing") step, 
                 s1, tm1, [], [K (Arith (f ++ f1) w1)])
       | Left err -> Left err
        end
   | Quote f [] ->
      Right (ESQuote "finished quote expansion", 
             s0, NoTilde, collapse_quoted f, [])
   | Quote f w -> 
       match expand_words s0 split Quoted NoTilde GeneratedString ([],w) with
       | Right (step, s1, _tm1, f1, w1) -> 
          Right (step, s1, NoTilde, [], [K (Quote (f ++ f1) w1)])
       | Left err -> Left err
       end
  end

and expand_words s0 split q tm sm (f,w) =
  match w with
    | [] -> Right (ESStep "done", s0, tm, f, w)
    | F::ws -> Right (ESStep "user field separator", s0, YesTilde, f ++ [UsrF], ws)
    | S ""::ws -> expand_words s0 split q tm sm (f,ws)
    | S s ::ws ->
       let f1 = match (q, sm) with
         | (Quoted, _) -> [DQuo (symbolic_string_of_string s)]
         | (Unquoted, UserString) -> [UsrS s]
         | (Unquoted, GeneratedString) -> [ExpS s]
       end in
       let last_char = head (reverse (toCharList s)) in
       let tm' = if last_char = #':' then YesTilde else NoTilde in
       Right (ESStep "plain string", s0, tm', f ++ f1, ws)
    | K k::ws ->
       match expand_control s0 split q tm k with
       | Right (step, s1, tm1, f1, w1) -> Right (step, s1, tm1, f++f1, (w1 ++ ws))
       | Left err -> Left err
       end
    | ESym c::ws -> Right (ESStep "skipping symbolic result", s0, tm, f ++ [EWSym c], ws)
  end

(**********************************************************************)
(* EXPANSION TRANSITIONS **********************************************)
(**********************************************************************)

 (* TECHNICAL DEBT 2019-03-04

   There are a variety of ways to run only part of expansion.

   dash accomplishes this with a variety of flags.

   we have a variety of ad hoc ways (boolean flags, interrupting
    stepping)

   can we make this uniform? how many different ways of expanding are
    there, really?
 *)
 (* TECHNICAL DEBT 2019-03-04

    ExpExpand below is _visible_ it steps to a final state before
    transitioning to the next stage of expansion. Plenty of bits of
    expansion/evaluation have the opportunity for visibility, but most
    of our step relations do some invisible work.

    It's probably better if _everything_ is made visible.
  *)

and step_expansion (os0,st) =
  match st with
  | ExpStart opts w0 -> 
     match expand_words os0 opts.splitting Unquoted YesTilde UserString ([],w0) with
     | Right (step, os1, tm, f1, w1) -> (step, os1, ExpExpand opts tm f1 w1)
     | Left (step, os1, f1) -> (step, os1, ExpError (fields_of_expanded_words f1))
     end
  | ExpExpand opts _tm0 f0 [] ->
     if should_split opts.splitting
     then (ESSplit "starting field splitting", os0, ExpSplit opts f0)
     else (ESSplit "skipping field splitting", os0, ExpPath opts (skip_field_splitting f0))
  | ExpExpand opts tm0 f0 w0 -> 
     match expand_words os0 opts.splitting Unquoted tm0 UserString (f0,w0) with
     | Right (step, os1, tm1, f1, w1) -> (step, os1, ExpExpand opts tm1 f1 w1)
     | Left (step, os1, f1) -> (step, os1, ExpError (fields_of_expanded_words f1))
     end
  | ExpSplit opts f0 -> (ESSplit "", os0, ExpPath opts (field_splitting os0 f0))
  | ExpPath opts ifs0 -> 
     if Set.member Sh_noglob os0.sh.opts || opts.globbing = false
     then (ESPath "skipping pathname expansion (set -f/assignment/etc.)", os0, 
           ExpQuote opts (unescape_intermediate_fields ifs0))
     else (ESPath "", os0, ExpQuote opts (pathname_expansion os0 ifs0))
  | ExpQuote _opts ifs0 -> (ESQuote "", os0, ExpDone (quote_removal ifs0))
  (* the following cases should never occur in calls from trace_expansion: *)
  | ExpError _ -> (ESStep "done in error state", os0, st)
  | ExpDone _ -> (ESStep "done in success state", os0, st)
  end

(**********************************************************************)   
(* EVALUATION *********************************************************)   
(**********************************************************************)   
   
(* Steps an expanding_redir along *)
and step_redir os0 er =
  let exp_state = get_expanding_redir_state er in
  let (step, os1, st1) = step_expansion (os0, exp_state) in
  match st1 with
   | ExpError err -> REError err
   | ExpDone f -> REDone os1 (expand_redir er f)
   | ExpPath opts ifs ->
      (* "Pathname expansion shall not be performed on the word [that
         is the target of redirection] by a non-interactive shell; an
         interactive shell may perform it, but shall do so only when
         the expansion would result in one word."

        "If no part of word is quoted, all lines of the here-document
         shall be expanded for parameter expansion, command
         substitution, and arithmetic expansion."

         i.e., skipping pathname expansion. the dash parser should
         take care of a lot of this. 
       *)
      let (msg,es') = 
        if is_interactive os1 && not (is_heredoc er) && opts.globbing
        then 
          let expanded = pathname_expansion os1 ifs in
          if length expanded = 1
          then ("performed pathname expansion in interactive shell",
                ExpQuote opts expanded)
          else ("skipped pathname expansion in interactive shell [produced " ^ 
                (stringFromNat (length expanded)) ^ " words]",
                ExpQuote opts (unescape_intermediate_fields ifs))
        else ("skipped pathname expansion", ExpQuote opts (unescape_intermediate_fields ifs))
      in
      REStep (ESPath msg) os1 (set_expanding_redir_state es' er)
   | _ -> REStep step os1 (set_expanding_redir_state st1 er)
   end

and step_redir_state os0 redir_state =
  match redir_state with
  | (_ers, Nothing, []) -> (os0, "done expanding redirs", Just (redir_state, Nothing))
  | (ers, Nothing, r::redirs) ->
     let opts = <| splitting = NoSplit; globbing = is_interactive os0 |> in
     let (msg, ers, exp_state) =
       match r with
       | RFile ty src w -> ("expanding file redirect", ers, Just (XRFile ty src (ExpStart opts w)))
       | RDup ty src tgt -> ("trivially expanded dup", ers ++ [ERDup ty LeaveOrig src tgt], Nothing)
       | RHeredoc XHere src w -> 
          ("expanding unquoted heredoc", ers, Just (XRHeredoc XHere src (ExpStart opts w)))
       | RHeredoc Here src w -> 
          ("not expanding quoted heredoc", 
           ers ++ [ERHeredoc Here src [symbolic_string_of_string (string_of_words w)]], 
           Nothing)
       end in
     (os0, msg, Just ((ers, exp_state, redirs), Nothing))
  | (ers, Just er, redirs) ->
     match step_redir os0 er with
     | REError err ->
        let msg = string_of_symbolic_string (symbolic_string_of_fields err) in
        (os0,
         msg,
         Nothing)
     | REDone os1 er' ->
        (os1,
         "expanded redirect",
         Just ((ers ++ [er'], Nothing, redirs), Nothing))
     | REStep step os1 er' ->
        (os1,
         "redirection expansion step",
         Just ((ers, Just er', redirs), Just step))
     end
  end

(* Steps the first, non-complete expansion_state and returns.
 * If it reached the base case, they are all complete, so
 *   we return the Left type to continue on the arg expansion. *)
and step_assign s0 assigns =
  match assigns with
  | [] -> SADone []
  | (_x, ExpError f)::_assigns -> SAError f
  | ((x, ExpDone f) as finished)::assigns' ->
    match step_assign s0 assigns' with
    | SAStep step s1 processed -> SAStep step s1 (finished::processed)
    | SAError err -> SAError err
    | SADone completed -> SADone ((x, f)::completed)
    end
  | (x, exp_state)::assigns' ->
    let (step, s1, next_state) = step_expansion (s0, exp_state) in
    SAStep (XSExpand (XSSimple x) step) s1 ((x, next_state)::assigns')
  end

and step_eval s0 checked stmt =
  (* 
     extremely subtle behavior with errors in expansion:
       an expansion error is NOT a field
       expansion errors cancel the current command with a failing exit status

     $ count() { echo $# ; }
     $ count ${x?one two three}                            # never runs count
     /Users/mgree/smoosh/dash/src/dash: 2: x: one two three
     $ count $(echo ${x?one two three})                    # subshell fails, but count will run!
     /Users/mgree/smoosh/dash/src/dash: 2: x: one two three
     0
     $ count $(echo ${x?one two three} four)
     /Users/mgree/smoosh/dash/src/dash: 3: x: one two three
     0
     $ count $(echo ${x?one two three}) four
     /Users/mgree/smoosh/dash/src/dash: 4: x: one two three
     1
     $ count $(${x? one two three}) four
     /Users/mgree/smoosh/dash/src/dash: 5: x:  one two three
  *)
  match stmt with
  (* COMMAND ******************************************************************)
  | Command assigns ws redirs opts ->
     Right (XSSimple "begin expansion",
            s0,
            CommandExpAssign
              (map (fun (x, w) -> (x, ExpStart <| splitting = NoSplit; globbing = false |> w)) assigns)
              ws
              redirs
              opts)
  (* COMMAND: SPECIAL CASE: plain assignment, no command **********************)
  (* in this case, we WANT the visibility between each assignment, so
     don't bother with the step_assigns rigamarole below

     "If there is no command name, but the command contained a command
     substitution, the command shall complete with the exit status of
     the last command substitution performed. Otherwise, the command
     shall complete with a zero exit status" *)
  | CommandExpAssign ((x,exp_state0)::assigns) [] redirs opts ->
     let (step, s1, exp_state1) = step_expansion (s0, exp_state0) in
     let opts' = <| opts with
         ran_cmd_subst = opts.ran_cmd_subst || ran_command_substitution step
       |>
     in
     match exp_state1 with
     | ExpDone f -> 
        match set_param x (symbolic_string_of_fields f) s1 with
        | Left err -> Left (XSSimple err, safe_write_stderr (err ^ "\n") s1)
        | Right s2 ->
           let s3 = trace (x ^ "=" ^ string_of_fields f) s2 in
           Right (XSSimple ("assign " ^ x),
                  s3, 
                  CommandExpAssign assigns [] redirs opts')
        end
     | ExpError err -> expansion_error true (* may exit *) s1 (XSSimple "assignment expansion") step err
     | _ -> 
        Right (XSExpand (XSSimple "") step,
               s1, 
               CommandExpAssign ((x,exp_state1)::assigns) [] redirs opts')
     end
  | CommandExpAssign [] [] redirs opts ->
     (* keep on expanding, since we have to actually expand the redirects no matter what *)
     Right (XSSimple "assignments complete", s0, CommandExpRedirs [] [] ([], Nothing, redirs) opts)

  (* GENERAL CASE: command with possible assignments, which no longer
     go in the general environment 

     we therefore fake ran_cmd_subst as 'true' below, not that it will
     matter 

     TODO 2019-03-14 bug vs. spec: these assignments should happen later
     
   *)
  | CommandExpAssign assigns ws redirs opts ->
     match step_assign s0 assigns with
     (* Perform an expansion step in an assignment *)
     | SAStep exp_step s1 assigns' ->
        Right (exp_step,
               s1,
               CommandExpAssign assigns' ws redirs opts)
     | SAError f -> expansion_error true (* may exit *) s0 (XSSimple "assign expansion") (ESStep "") f
     (* Done, move on to expanding arguments *)
     | SADone fields ->
        Right (XSSimple "assignments fully expanded",
               s0,
               CommandExpArgs fields (ExpStart <| splitting = Split; globbing = true |> ws) redirs opts)
    end
  | CommandExpArgs assigns exp_state redirs opts ->
      let (step, s1, st1) = step_expansion (s0, exp_state) in
      match st1 with
        | ExpError err -> expansion_error true (* may exit *) s1 (XSSimple "arg expansion") step err
        | ExpDone f ->
           let msg = 
             show (length f) ^ " " ^ if length f = 1 then "argument" else "arguments" ^ 
             " fully expanded (including command)"
           in
           Right (XSExpand (XSSimple msg) step, 
                  s1, 
                  CommandExpRedirs assigns f ([], Nothing, redirs) opts)
        | _ ->
           Right (XSExpand (XSSimple "argument expansion step") step,
                  s1,
                  CommandExpArgs assigns st1 redirs opts)
      end
  (* COMMAND: Redirect expansion **********************************************)
  (* expansion is done, try to run command *)
  | (CommandExpRedirs assigns (prog::args) (ers, Nothing, []) opts as cmd) ->
     if Set.member Sh_noexec s0.sh.opts
     then Right (XSSimple "set -n: skipping command", s0, Done)
     else
     let s0_traced = trace (string_of_stmt cmd) s0 in
     (* load exported variables, perform assignments *)
     let exported = 
       Map_extra.mapMaybe 
         (fun x v -> if Set.member x s0_traced.sh.export then Just v else Nothing)
         s0_traced.sh.env
     in
     let env = 
       foldr (fun (x,f) env' -> 
           Map.insert x (symbolic_string_of_fields f) env') 
         exported assigns
     in
     (* "If the command name is a special built-in utility, variable
        assignments shall affect the current execution environment."

        Unless the set -a option is on (see set), it is unspecified:

        Whether or not the variables gain the export attribute during
        the execution of the special built-in utility

        Whether or not export attributes gained as a result of the
        variable assignments persist after the completion of the
        special built-in utility

        If the command name is a function that is not a standard
        utility implemented as a function, variable assignments shall
        affect the current execution environment during the execution
        of the function. It is unspecified:

        Whether or not the variable assignments persist after the
        completion of the function

        Whether or not the variables gain the export attribute during
        the execution of the function

        Whether or not export attributes gained as a result of the
        variable assignments persist after the completion of the
        function (if variable assignments persist after the completion
        of the function)

        If any of the variable assignments attempt to assign a value
        to a variable for which the readonly attribute is set in the
        current shell environment (regardless of whether the
        assignment is made in that environment), a variable assignment
        error shall occur. See Consequences of Shell Errors for the
        consequences of these errors.

        *)
     let (s0_logged, concretized, prog_name) = concretize s0_traced prog in
     let prog_special = is_special_builtin prog_name in
     let s1 = 
       if not concretized && prog_special
       then
         (* need a call to set_param, which has the right logic for
            Sh_allexport.

            we don't need to worry about bad variable names in this
            setting because the parser rejects forms like `?=1 :` 
          *)
         let set (x,v) os = 
           match set_param x v os with
           | Left _ -> os
           | Right os' -> os'
           end
         in
         foldr set s0_logged (Map_extra.toList env)
       else s0_logged
     in
     let catching_errors = not (checked_exit checked) && Set.member Sh_errexit s1.sh.opts in
     let exit_on_error = 
       catching_errors ||
       (prog_special && not (is_interactive s1)) (* per table in 2.8.1 *)
     in
     match do_redirs s1 ers with
     | (s2, Left msg) ->
        check_traps
          (Right (XSSimple ("error in redirection: " ^ msg), 
                  fail_with msg s2, 
                  if exit_on_error then Exit else Done))
     | (s2, Right saved_fds) ->
       (* run command *)
       match run_command s2 opts checked prog args env with
       | Right (s3, stmt', restore) -> 
          Right (XSSimple ("ran " ^ string_of_symbolic_string prog), 
                 s3, 
                 if catching_errors && s3.sh.exit_code <> 0
                 then Exit
                 else if restore 
                 then pushredir stmt' saved_fds 
                 else stmt')
       | Left (s3,msg) -> 
          check_traps
            (Right (XSSimple "couldn't run command", 
                    fail_with (string_of_symbolic_string prog ^ ": " ^ msg) s3, 
                    if exit_on_error then Exit else pushredir Done saved_fds))
       end
     end
  (* expansion is done, but there's no command *)
  | (CommandExpRedirs _assigns [] (ers, Nothing, []) opts as cmd) ->
     (* we've already done whatever assignments above, in the special
        case.  it remains to set up redirects for side effects/file
        creation

        e.g., unset x y ; x=5 >${y=3} will set x to 5, y to 3, and
        create an empty file named 3 *)
     (* "If there is no command name, any redirections shall be
        performed in a subshell environment; it is unspecified whether
        this subshell environment is the same one as that used for a
        command substitution within the command. (To affect the
        current execution environment, see the exec special built-in.)
        If any of the redirections performed in the current shell
        execution environment fail, the command shall immediately fail
        with an exit status greater than zero, and the shell shall
        write an error message indicating the failure. See
        Consequences of Shell Errors for the consequences of these
        failures on interactive and non-interactive shells."  *)
     (* So... we're cheating on this a little. Rather than
        subshelling, we do the redirs and then record a pushredir. *)
     match do_redirs s0 ers with
     | (s1, Left msg) -> 
        (* dash doesn't set the variables if the redirect failed *)
        check_traps (Right (XSSimple ("error in redirection"), 
                            fail_with msg s1, 
                            Done))
     | (s1, Right saved_fds) ->
        let s2 = trace (string_of_stmt cmd) s1 in
        let s3 = if opts.ran_cmd_subst then s2 else exit_with 0 s2 in
        check_traps (Right (XSSimple "ran empty command",
                            s3,
                            pushredir Done saved_fds))
     end
   (* expand redirs *)
   | CommandExpRedirs assigns args redir_state opts ->
      match step_redir_state s0 redir_state with
      | (s1, msg, Nothing) ->
         let (s2, may_exit) =
           match args with
           | ss_prog::_ ->
              let (s2, _, prog) = concretize s1 ss_prog in
              (s2, is_special_builtin prog)
           | _ -> (s1, false)
           end
         in
         expansion_error may_exit s2 (XSSimple "error in redirect expansion") (ESStep "") 
           [symbolic_string_of_string msg]
      | (s1, msg, Just (redir_state', mstep)) ->
         let (ran_cmd_subst', step) =
           match mstep with
           | Just estep -> (opts.ran_cmd_subst || ran_command_substitution estep,
                            XSExpand (XSSimple msg) estep)
           | Nothing -> (opts.ran_cmd_subst, XSSimple msg)
         end in
         let opts' = <| opts with ran_cmd_subst = ran_cmd_subst' |> in
         Right (step, s1,
                CommandExpRedirs assigns args redir_state' opts')
      end

  (* PIPE *********************************************************************)
  | Pipe bg_mode stmts ->
     let (s1, pipeline, last_pid) = run_pipe s0 stmts bg_mode in
     let (s2, c) =
       let s2 = add_job s1 pipeline last_pid (Pipe bg_mode stmts) in
       if is_bg bg_mode
       then (set_last_pid last_pid s2, Done)
       else 
         (* If the pipeline is not in the background (see Asynchronous
            Lists), the shell shall wait for the last command
            specified in the pipeline to complete, and may also wait
            for all commands to complete. *)
         (s2, Wait last_pid checked Nothing) 
     in
     check_traps (Right (XSPipe "started pipe",
                         s2,
                         c))

  (* REDIR ********************************************************************)
  | Redir stmt' (ers, Nothing, []) ->
     check_traps 
       (match do_redirs s0 ers with
        | (s1, Left msg) -> 
           Right (XSRedir "error in redirection", 
                  fail_with msg s1, 
                  Done)
        | (s1, Right saved_fds) ->
           Right (XSRedir "running redirected command", 
                  s1, 
                  pushredir stmt' saved_fds)
        end)
  (* redirection steps *)
  | Redir stmt' redir_state ->
     match step_redir_state s0 redir_state with
     | (s1, msg, Nothing) ->
        check_traps
            (Right (XSRedir "error in redirect expansion", 
                   fail_with msg s1, 
                   Done))
     | (s1, msg, Just (redir_state', mstep)) ->
        let step =
          match mstep with
          | Just estep -> XSExpand (XSRedir msg) estep
          | Nothing -> XSRedir msg
          end in
        Right (step, s1, Redir stmt' redir_state')
     end

  (* BACKGROUND ***************************************************************)
  | Background stmt' ((ers, Nothing, []) as redir_state) ->
     let redir_state' =
       if not (is_monitoring s0) && not (any expanded_redir_has_stdin_redir ers)
       then
         (* If job control is disabled (see set, -m), the standard input
            for an asynchronous list, before any explicit redirections
            are performed, shall be considered to be assigned to a file
            that has the same properties as /dev/null. This shall not
            happen if job control is enabled. In all cases, explicit
            redirection of standard input shall override this
            activity. *)
         (* TODO 2019-04-11 make /dev/null path configurable *)
         (ERFile From 0 [symbolic_string_of_string "/dev/null"]::ers, Nothing, [])
       else redir_state
     in
     (* defer to Redir to load redirs *)
     let (s1,pid) = 
       fork_and_subshell s0 (Redir stmt' redir_state') 
         BG Nothing (* no pgid *) true (* job control *)
     in
     let s2 = add_job s1 [] (* no pipeline *)
                pid (Background stmt' redir_state (* don't show our munging *)) in
     let s3 = set_last_pid pid s2 in
     check_traps
       (Right (XSBackground ("started background process with pid " ^ 
                               (stringFromNat pid)), 
              s3, 
              Done))
  (* expand redirs *)
  | Background stmt' redir_state ->
     match step_redir_state s0 redir_state with
     | (s1, msg, Nothing) ->
        check_traps
          (Right (XSBackground "error in redirect expansion", 
                  fail_with msg s1, 
                  Done))
     | (s1, msg, Just (redir_state', mstep)) ->
        let step =
          match mstep with
          | Just estep -> XSExpand (XSBackground msg) estep
          | Nothing -> XSBackground msg
          end in
        Right (step, s1, Background stmt' redir_state')
     end
 
  (* SUBSHELL *****************************************************************)
  | Subshell stmt' ((_, Nothing, []) as redir_state) ->
     let (s1,pid) = 
       fork_and_subshell s0 (Redir stmt' redir_state)
         FG Nothing (* no pgid *) true (* job control *)
     in
     check_traps
       (Right (XSSubshell ("started subshell with pid " ^ stringFromNat pid), 
               s1, 
               Wait pid checked Nothing))
  | Subshell stmt' redir_state ->
     match step_redir_state s0 redir_state with
     | (s1, msg, Nothing) ->
        check_traps
          (Right (XSSubshell "error in redirect expansion", 
                  fail_with msg s1, 
                  Done))
     | (s1, msg, Just (redir_state', mstep)) ->
        let step =
          match mstep with
          | Just estep -> XSExpand (XSSubshell msg) estep
          | Nothing -> XSSubshell msg
          end in
        Right (step, s1, Subshell stmt' redir_state')
     end

  (* AND **********************************************************************)
  | And l r ->
      match step_eval s0 Checked l with
      | Left e -> Left e
      | Right (step, s1, Exit)       -> Right (step, s1, Exit)
      | Right (step, s1, Return)     -> Right (step, s1, Return)
      | Right (step, s1, Break n)    -> Right (step, s1, Break n)
      | Right (step, s1, Continue n) -> Right (step, s1, Continue n)
      | Right (_step, s1, Done) ->
         check_traps
           (if s1.sh.exit_code = 0
            then Right (XSAnd "exit code was 0, continuing", s1, r)
            else Right (XSAnd "exit code was non-zero, short-circuiting", s1, Done))
      | Right (step, s1, l') -> Right (XSNested (XSAnd "") step, s1, And l' r)
      end

  (* OR ***********************************************************************)
  | Or l r ->
      match step_eval s0 Checked l with
      | Left e -> Left e
      | Right (step, s1, Exit)       -> Right (step, s1, Exit)
      | Right (step, s1, Return)     -> Right (step, s1, Return)
      | Right (step, s1, Break n)    -> Right (step, s1, Break n)
      | Right (step, s1, Continue n) -> Right (step, s1, Continue n)
      | Right (_step, s1, Done) ->
         check_traps
           (if s1.sh.exit_code = 0
            then Right (XSOr "exit code was 0, short-circuiting", s1, Done)
            else Right (XSOr "exit code was non-zero, continuing", s1, r))
      | Right (step, s1, l') -> Right (XSNested (XSOr "") step, s1, Or l' r)
      end

  (* NOT **********************************************************************)
  | Not stmt' ->
      match step_eval s0 Checked stmt' with
      | Left e -> Left e
      | Right (step, s1, Exit)       -> Right (step, s1, Exit)
      | Right (step, s1, Return)     -> Right (step, s1, Return)
      | Right (step, s1, Break n)    -> Right (step, s1, Break n)
      | Right (step, s1, Continue n) -> Right (step, s1, Continue n)
      | Right (_step, s1, Done) ->
         check_traps
           (if s1.sh.exit_code = 0
            then Right (XSNot "0 -> 1", exit_with 1 s1, Done)
            else Right ((XSNot "_ -> 0"), exit_with 0 s1, Done))
      | Right (step, s1, stmt'') -> Right (XSNested (XSNot "") step, s1, Not stmt'')
      end

  (* SEMI *********************************************************************)
  | Semi l r ->
      match step_eval s0 checked l with
      | Left e -> Left e
      | Right (step, s1, Exit)       -> Right (step, s1, Exit)
      | Right (step, s1, Return)     -> Right (step, s1, Return)
      | Right (step, s1, Break n)    -> Right (step, s1, Break n)
      | Right (step, s1, Continue n) -> Right (step, s1, Continue n)
      | Right (step, s1, Done) -> 
         check_traps (Right (XSNested (XSSemi "done with LHS") step, s1, r))
      | Right (step, s1, l') -> Right (XSNested (XSSemi "") step, s1, Semi l' r)
      end

  (* IF ***********************************************************************)
  | If c t e ->
      match step_eval s0 Checked c with
      | Left e -> Left e
      | Right (step, s1, Exit)       -> Right (step, s1, Exit)
      | Right (step, s1, Return)     -> Right (step, s1, Return)
      | Right (step, s1, Break n)    -> Right (step, s1, Break n)
      | Right (step, s1, Continue n) -> Right (step, s1, Continue n)
      | Right (_step, s1, Done) ->
         check_traps
           (if s1.sh.exit_code = 0
            then Right (XSIf "exit code was 0, taking the true branch", s1, t)
            else Right (XSIf "exit code was non-zero, taking the false branch", s1, e))
      | Right (step, s1, c') -> Right (XSNested (XSIf "") step, s1, If c' t e)
      end

  (* WHILE ********************************************************************)
  | While c body -> 
     Right (XSWhile "start to evaluate the condtion", 
            enter_loop s0, 
            WhileCond c c body Nothing)
  | WhileCond c cur body saved_ec ->
      match step_eval s0 Checked cur with
      | Left e -> Left e
      | Right (step, s1, Exit)       -> Right (XSNested (XSWhile "exiting") step, 
                                               s1, Exit)
      | Right (step, s1, Return)     -> Right (XSNested (XSWhile "returning") step, 
                                               s1, Return)
      | Right (step, s1, Break 1)    -> Right (XSNested (XSWhile "breaking") step, 
                                               exit_loop s1, Done)
      | Right (step, s1, Break n)    -> Right (XSNested 
                                                 (XSWhile "breaking to outer loop") 
                                                 step, 
                                               exit_loop s1, Break (n-1))
      | Right (step, s1, Continue 1) -> Right (XSNested 
                                                 (XSWhile "continuing loop") step, 
                                               s1, WhileCond c c body saved_ec)
      | Right (step, s1, Continue n) -> Right (XSNested 
                                                 (XSWhile "continuing to outer loop") 
                                                 step, 
                                               exit_loop s1, Continue (n-1))
      | Right (_step, s1, Done) ->
         check_traps
           (if s1.sh.exit_code = 0
            then Right (XSWhile "exit code was 0, running the loop body", 
                        s1, WhileRunning c body body)
            else
              let ec =
                match saved_ec with
                | Nothing -> 0
                | Just ec -> ec
                end
              in
              Right (XSWhile "exit code was non-zero, taking the false branch", 
                        exit_with ec (exit_loop s1), Done))
      | Right (step, s1, cur') -> Right (XSNested (XSWhile "") step, s1, WhileCond c cur' body saved_ec)
      end
  | WhileRunning c body cur ->
      match step_eval s0 checked cur with
      | Left e -> Left e
      | Right (step, s1, Exit)       -> Right (XSNested (XSWhile "exiting") step, s1, Exit)
      | Right (step, s1, Return)     -> Right (XSNested (XSWhile "returning") step, s1, Return) 
      | Right (step, s1, Break 1)    -> Right (XSNested (XSWhile "breaking loop") step, exit_loop s1, Done)
      | Right (step, s1, Break n)    -> Right (XSNested (XSWhile "breaking to outer loop") step, exit_loop s1, Break (n-1))
      | Right (step, s1, Continue 1) -> Right (XSNested (XSWhile "continuing loop") step, s1, WhileCond c c body (Just s1.sh.exit_code))
      | Right (step, s1, Continue n) -> Right (XSNested (XSWhile "continuing to outer loop") step, exit_loop s1, Continue (n-1))
      | Right (step, s1, Done) -> check_traps (Right (XSNested (XSWhile "finished iteration of while loop; retesting condition") step, s1, WhileCond c c body (Just s1.sh.exit_code)))
      | Right (step, s1, cur') -> Right (XSNested (XSWhile "") step, s1, WhileRunning c body cur')
      end

  (* FOR **********************************************************************)
  | For var ws body -> Right (XSFor "begin arg expansion", s0, ForExpArgs var (ExpStart <| splitting = Split; globbing = true |> ws) body)
  | ForExpArgs var exp_state body ->
      let (step, os1, st1) = step_expansion (s0, exp_state) in
      match st1 with
        | ExpError err -> expansion_error true (* may exit *) os1 (XSFor "arg expansion") step err
        | ExpDone f ->
           Right (XSFor "arguments fully expanded",
                  os1,
                  ForExpanded var f body)
        | (_ as in_progress) ->
           Right (XSExpand (XSFor "argument expansion step") step,
                  os1,
                  ForExpArgs var in_progress body)
      end
  (* FOR: Special case, no items exit status is zero **************************)
  | ForExpanded _var [] _body ->
     check_traps
       (Right (XSFor "no items, exit code is 0", 
               exit_with 0 s0, 
               Done))
  | ForExpanded var (i::f) body ->
     match set_param var i s0 with
     | Left err -> Left (XSFor err, s0)
     | Right s1 ->
        let s2 = enter_loop s1 in
        Right 
          (XSFor ("starting for loop with " ^ var ^ " = " ^ (string_of_symbolic_string i)),
           s2, 
           ForRunning var f body body)
     end
  | ForRunning var f body cur ->
      match step_eval s0 checked cur with
      | Left e -> Left e
      | Right (step, s1, Exit)       -> Right (XSNested (XSFor "exiting") step, s1, Exit)
      | Right (step, s1, Return)     -> Right (XSNested (XSFor "returning") step, s1, Return)
      | Right (step, s1, Break 1)    -> Right (XSNested (XSFor "breaking loop") step, exit_loop s1, Done)
      | Right (step, s1, Break n)    -> Right (XSNested (XSFor "breaking to outer loop") step, exit_loop s1, Break (n-1))
      | Right (step, s1, Continue 1) ->
          match f with
          | [] -> Right (XSNested (XSFor "continued at last iteration") step, exit_loop s1, Done)
          | (i::f') -> Right (XSNested (XSFor ("continuing to next iteration with " ^ var ^ " = " ^ string_of_symbolic_string i)) step,
                              (* if the var name was good the first time, it's still good *)
                              internal_set_param var i s1,
                              ForRunning var f' body body)
          end
      | Right (step, s1, Continue n) -> Right (XSNested (XSFor "continuing to outer loop") step, s1, Continue (n-1))
      | Right (step, s1, Done) ->
         check_traps
           (match f with
            | [] -> Right (XSNested (XSFor "finished last iteration") step, exit_loop s1, Done)
            | (i::f') -> Right (XSNested (XSFor ("starting next iteration with " ^ var ^ " = " ^ string_of_symbolic_string i)) step,
                                internal_set_param var i s1,
                                ForRunning var f' body body)
            end)
      | Right (step, s1, cur') -> Right (XSNested (XSFor "") step, s1, ForRunning var f body cur')
      end

  (* CASE *********************************************************************)
  | Case ws cases -> Right (XSCase "begin arg expansion", s0, CaseExpArg (ExpStart <| splitting = NoSplit; globbing = false |> ws) cases)
  | CaseExpArg exp_state cases ->
      let (step, os1, st1) = step_expansion (s0, exp_state) in
      match st1 with
        | ExpError err -> expansion_error true (* may exit *) os1 (XSCase "arg expansion") step err
        | ExpExpand _opts _tm ew [] ->
        (* "...matched by the string resulting from the tilde
           expansion, parameter expansion, command substitution,
           arithmetic expansion, and quote removal of the given word." *)
           let ss = symbolic_string_of_expanded_words false (* don't keep quotes *) ew in
           Right (XSCase "argument fully expanded", os1, CaseMatch ss cases)
        | (_ as in_progress) ->
           Right(XSExpand (XSCase "argument expansion step") step,
                 os1,
                 CaseExpArg in_progress cases)
      end
  | CaseMatch f cases ->
      match cases with
        | [] ->
           check_traps (Right (XSCase "no match in case statement", s0, Done))
        | ([], _cmd)::cases' ->
           Right (XSCase "exhausted patterns, checking next case",
                  s0,
                  CaseMatch f cases')
        | (pat::pats', cmd)::cases' ->
           Right (XSCase "checking pattern match",
                  s0,
                  CaseCheckMatch f (ExpStart <| splitting = NoSplit; globbing = false |> pat) cmd ((pats',cmd)::cases'))
      end
  | CaseCheckMatch f pat cmd cases ->
      let (step, os1, st1) = step_expansion (s0, pat) in
      match st1 with
        | ExpError err -> expansion_error true (* may exit *)os1 (XSCase "error in argument expansion") step err
        | ExpExpand _opts _tm ew [] ->
           (* "each pattern that labels a compound-list shall be
              subjected to tilde expansion, parameter expansion,
              command substitution, and arithmetic expansion" ...
            *)
           (* TODO 2018-08-29 use proper locale *)
           let pat' = symbolic_string_of_expanded_words true (* keep quotes *) ew in
           match match_exact lc_ambient pat' f with
           | NoMatch -> Right (XSCase "case did not match, trying the next",
                               os1, CaseMatch f cases)
           | Match _ -> check_traps (Right (XSCase "case matched, evaluating cmd", os1, cmd))
           | Symbolic -> Left (XSCase "case on symbolic value, gave up", os1)
           end
        | (_ as in_progress) ->
           Right(XSExpand (XSCase "pattern expansion step") step,
                 os1,
                 CaseCheckMatch f in_progress cmd cases)
      end

  (* DEFUN ********************************************************************)
  | Defun name body -> 
     if is_special_builtin name
     then Left (XSDefun ("invalid function name " ^ name ^ " (shadows special built-in)"), s0)
     else check_traps (Right (XSDefun ("defined " ^ name), defun name body s0, Done))

  (* CALL *********************************************************************)
  | Call old_loop_nest old_positional_params f orig c ->
     match step_eval s0 checked c with
     | Left e -> Left e
     | Right (step, s1, Done) ->
        check_traps
          (Right (XSStack (f ^ ": implicit return") step,
                  set_function_params old_loop_nest old_positional_params s1,
                  Done))
     | Right (step, s1, Return) ->
        check_traps 
          (Right (XSStack (f ^ ": explicit return") step,
                  set_function_params old_loop_nest old_positional_params s1,
                  Done))
     | Right (step, s1, Exit) ->
        Right (XSStack (f ^ ": exit") step,
               set_function_params old_loop_nest old_positional_params s1,
               Exit)
     (* what do we do if there's a break or continue in a call? 
        
        break/continue don't seem to ever be lexically enclosed in a loop, so behavior is unspecified.
        bash supports "non local break", dash doesn't:

          $ brk() { break 5; echo post; }        
          $ while true; do brk; done 

        dash diverges, printing post
        bash breaks immediately, no printing

        following dash is tricky: 
        wherever there's a break, you have look at loop_nest.
        when i refactor step_eval to treat terminating control differently, we'll be made.
        for now, we'll follow bash.
      *)
     | Right (step, s1, Break n) ->
        let s2 = set_function_params old_loop_nest old_positional_params s1 in
        let s3 = log_unspecified "non-lexical break in function call" s2 in
        Right (XSStack (f ^ ": break [unspecified behavior]") step,
               s3,
               Break n)
     | Right (step, s1, Continue n) ->
        let s2 = set_function_params old_loop_nest old_positional_params s1 in
        let s3 = log_unspecified "non-lexical continue in function call" s2 in
        Right (XSStack (f ^ ": continue [unspecified behavior]") step,
               s3,
               Continue n)
     | Right (step, s1, c') ->
        Right (XSStack f step,
               s1,
               Call old_loop_nest old_positional_params f orig c')
     end

  (* EVALLOOP *****************************************************************)

  | EvalLoop linno ((sstr,stackmark) as ctx) src interactive shell_level ->
     let s1 = show_changed_jobs s0 in
     let (s2, parsed) = parse_next s1 interactive stackmark in
     check_traps
       (match parsed with
        | ParseDone -> 
           let _ = if is_toplevel shell_level then () else parse_done sstr in
           let (s3, c) = 
             if is_interactive_mode interactive && 
                  is_toplevel shell_level && Set.member Sh_ignoreeof s2.sh.opts
             then (write_stderr "Use \"exit\" to leave the shell.\n" s2, 
                   EvalLoop linno ctx src interactive shell_level)
             else (s2, Done)
           in
           Right (XSEval linno src "done", s3, c)
        | ParseError -> 
           let _ = if is_toplevel shell_level then () else parse_done sstr (* TODO ??? *) in
           Right (XSEval linno src "parse error", exit_with 1 s2, Done)
        | ParseNull ->
           Right (XSEval linno src "empty line", s2, 
                  EvalLoop (linno+1) ctx src interactive shell_level)
        | ParseStmt c ->
           Right (XSEval linno src "", s2,
                  EvalLoopCmd (linno+1) ctx src interactive shell_level c)
        end)
  | EvalLoopCmd linno ctx src interactive shell_level c ->
     match step_eval s0 checked c with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (step, s1, Exit)
      | Right (step, s1, c') ->
         if is_terminating_control c' (* Exit already ruled out *)
         then
           (* we got some kind of terminating control other than Exit *)
           check_traps
             (Right (XSNested (XSEval linno src "returning to loop") step,
                     s1, 
                     if not (is_toplevel shell_level) && parse_source_propagates_control src
                     then
                       (* when break/return/continue occur in an eval, allow it! *)
                       c'
                     else 
                       (* when they occur at the toplevel or in dot, ignore them *)
                       EvalLoop linno ctx src interactive shell_level))
         else 
           (* keep on running *)
           Right (XSNested (XSEval linno src "") step, s1, 
                  EvalLoopCmd linno ctx src interactive shell_level c')
      end

  (* EXEC *********************************************************************)
  | Exec cmd args env binsh ->
     (* INVARIANT: we should have called check_execve before generating an Exec *)
     match execve s0 cmd args env binsh with
     | (s1, Left msg) -> Left (XSExec msg, s1)
     | (_s1, Right _stmt) -> 
        (* we'll only actually return if we're running symbolically.
           with real OS calls, that execve never comes back! *)
        Left (XSExec "symbolic execve unimplemented", s0)
     end

  (* WAIT *********************************************************************)
  | Wait n _checked (Just 0) -> (* out of steps *)
     check_traps
       (Right (XSWait ("stopped blocking on process with pid " ^ stringFromNat n),
               s0,
               Done))
   
  | Wait pid checking bound -> 
     let exit_on_error = not (checked_exit checking) && Set.member Sh_errexit s0.sh.opts in
     let s_pid = stringFromNat pid in
     match wait_for_pid step_eval s0 pid with
     | (s1, Nothing) -> 
        check_traps
          (Right (XSWait ("couldn't step process with pid " ^ s_pid), 
                  safe_write_stderr ("wait: pid " ^ s_pid ^ " is not a child of this shell") s1, 
                  Done))
     | (s1, Just (Left step)) ->
        (* we took a step, so record it *)
        let bound' = 
          match bound with
          | Nothing -> Nothing
          | Just n -> Just (n - 1)
          end
        in
        Right (XSNested (XSWait ("process with pid " ^ s_pid ^ " stepped")) 
                        step,
               s1,
               Wait pid checking bound')
     | (s1, Just (Right code)) ->
        let s2 = delete_job_with_pid s1 pid in
        check_traps
          (Right (XSWait ("process with pid " ^ s_pid ^ " completed"),
                  exit_with code s2,
                  if exit_on_error && code <> 0
                  then Exit
                  else Done))
     end            

  (* EXEC *********************************************************************)
  | Trapped signal old_ec c_handler c_cont ->
     if is_terminating_control c_handler
     then 
       let (s1, c) =
         if c_handler = Exit
         then (s0, Exit) (* don't restore old exit code! *)
         else (exit_with old_ec s0, c_cont)
       in
       Right (XSTrap signal "finished",
              s1,
              c)
     else match step_eval s0 Unchecked c_handler with
          | Left (step, s1) -> 
             Right (XSNested (XSTrap signal "errored out") step,
                    exit_with old_ec s1,
                    c_cont)
          | Right (step, s1, c_handler') ->
             Right (XSNested (XSTrap signal "") step,
                    s1,
                    Trapped signal old_ec c_handler' c_cont)
          end

  (* PUSHREDIR ****************************************************************)
  | Pushredir c saved_fds ->
     if is_terminating_control c
     then check_traps
            (Right (XSRedir "popping redirects", 
                    restore_fds s0 saved_fds, 
                    c))
     else match step_eval s0 checked c with
          | Left e -> Left e
          | Right (step, s1, c') -> 
             Right (XSNested (XSRedir "") step, 
                    s1, 
                    Pushredir c' saved_fds)
          end

  (* BREAK/CONTINUE/RETURN/EXIT/DONE ******************************************)
  | Break _n -> check_traps (Right (XSSimple "break bottomed out", s0, Done))
  | Continue _n -> check_traps (Right (XSSimple "continue bottomed out", s0, Done))
  | Return -> check_traps (Right (XSSimple "return bottomed out", s0, Done))
  | Exit -> 
     let (s1,m_cmd) = exit_trap s0 in
     match m_cmd with
     | Nothing -> Right (XSSimple "exited", exit s1, Done)
     | Just cmd -> Right (XSSimple "trapped on exit", s1, Semi cmd Exit)
     end
  | Done -> check_traps (Right (XSSimple "", s0, Done))
  end

(* Evaluation **********************************************************)

and full_evaluation os0 stmt0 =
  if out_of_fuel os0
  then os0
  else 
    let os1 = tick os0 in
    match stmt0 with
    | Done -> os1
    | _ -> 
       match step_eval os1 Unchecked stmt0 with
       | Right (step, os2, stmt1) -> full_evaluation (log_step step os2) stmt1
       | Left (step, os2) ->
          let os3 = write_stderr (string_of_evaluation_step step ^ "\n") os2 in
          log_step step (exit_with 1 os3)
       end
    end

and eval os0 stmt0 =
  let os1 = full_evaluation os0 stmt0 in
  let os2 = full_evaluation os1 Exit in
  os2.sh.exit_code

(**********************************************************************)   
(* TRACING ************************************************************)   
(**********************************************************************)   
(* These functions are for testing and the expansion tool. *)

open import Os_symbolic

(* Expansion **********************************************************) 
(* unbounded functions for testing final expansion results (used in
   test_expansion.ml)

   this function is a little unfaithful to the expansion semantics
   because we're not keeping track of whether the result was a message
   printed to stderr or the actual result of expansion
 *)
val symbolic_run_full_expansion 
    : os_state symbolic -> expansion_state -> os_state symbolic * fields
let rec symbolic_run_full_expansion os0 st0 =
  match st0 with
  | ExpError f -> (os0, f)
  | ExpDone f -> (os0, f)
  | _ -> 
     let (_step,os1,st1) = step_expansion (os0,st0) in
     symbolic_run_full_expansion os1 st1
  end

val symbolic_full_expansion 
    : os_state symbolic -> words -> os_state symbolic * fields
let symbolic_full_expansion s0 w0 = symbolic_run_full_expansion s0 (ExpStart <| splitting = Split; globbing = true |> w0)

val symbolic_full_evaluation : os_state symbolic -> stmt -> os_state symbolic
let symbolic_full_evaluation s0 c = full_evaluation s0 c
   
(* Tracing evaluation *************************************************)
(* used in expand.ml *)

val run_trace_evaluation : os_state symbolic -> stmt -> evaluation_trace
let rec run_trace_evaluation os0 stmt0 =
  if out_of_fuel os0
  then ([(XSStep "out of fuel", os0.sh, os0.symbolic, stmt0)], os0)
  else if os0.symbolic.exited
  then ([], os0)
  else 
    let os1 = tick os0 in
    match stmt0 with
    | Done -> 
       match exit_trap os0 with
       | (s1, Nothing) -> ([], s1)
       | (s1, Just c_handler) -> run_trace_evaluation s1 c_handler
       end
    | _ ->
        match step_eval os1 Unchecked stmt0 with
        | Right (step, os2, stmt1) -> 
           let entry = (step, os2.sh, os2.symbolic, stmt1) in
           let (trace,os3) = run_trace_evaluation os2 stmt1 in
           (entry::trace, os3)
        | Left (step, os2) -> ([(step, os2.sh, os2.symbolic, Done)], os2)
        end
    end
  
(* Real evaluation ****************************************************)
(* convenience functions for shell.ml *)
open import Os_system

val real_eval : os_state system -> stmt -> os_state system
let real_eval = full_evaluation

val real_eval_for_exit_code : os_state system -> stmt -> nat
let real_eval_for_exit_code = eval
