include import Smoosh_prelude
include import Os

val dash_parse_init : parse_source -> maybe dash_string
declare ocaml target_rep function dash_parse_init = `Shim.parse_init`

val morbig_parse_init : parse_source -> maybe morbig_string
declare ocaml target_rep function morbig_parse_init = `Morbig_shim.parse_init`

val parse_init : parser_type -> parse_source -> parser_string
let parse_init pt ps =
  match pt with
    ParserMorbig -> MorbigString (morbig_parse_init ps)
    | ParserDash -> DashString (dash_parse_init ps)
  end

val stack_init : unit -> stackmark
declare ocaml target_rep function stack_init = `Dash.init_stack`

val stack_pop : stackmark -> unit
declare ocaml target_rep function stack_pop = `Dash.pop_stack`

val dash_parse_done : maybe dash_string -> maybe stackmark -> unit
declare ocaml target_rep function dash_parse_done = `Shim.parse_done`

val morbig_parse_done : maybe morbig_string -> maybe stackmark -> unit
declare ocaml target_rep function morbig_parse_done = `Morbig_shim.parse_done`

val parse_done : parser_string -> maybe stackmark -> unit
let parse_done ps sm =
  match ps with
    DashString s -> dash_parse_done s sm
    | MorbigString s -> morbig_parse_done s sm
  end

val dash_parse_next_internal : interactivity_mode -> parse_result
declare ocaml target_rep function dash_parse_next_internal = `Shim.parse_next`

val morbig_parse_next_internal : interactivity_mode -> parse_result
declare ocaml target_rep function morbig_parse_next_internal = `Morbig_shim.parse_next`

val parse_next_internal : parser_type -> interactivity_mode -> parse_result
let parse_next_internal pt im =
  match pt with
    ParserMorbig -> morbig_parse_next_internal im
    | ParserDash -> dash_parse_next_internal im
  end

val parse_next : forall 'a. OS 'a => os_state 'a -> interactivity_mode -> os_state 'a * parse_result
let parse_next s0 interactive =
  match parse_next_internal s0.parser interactive with
  | ParseDone    -> (s0,ParseDone)
  | ParseError s -> (s0,ParseError s)
  | ParseNull    -> (s0,ParseNull)
  | ParseStmt  c ->
     let s1 = 
       if Set.member Sh_verbose s0.sh.opts
       then safe_write_stderr (string_of_stmt c ^ "\n") s0
       else s0
     in
     (s1, ParseStmt c)
  end

val dash_parse_cleanup : maybe dash_string -> maybe stackmark -> shell_level -> unit
let dash_parse_cleanup mss smark shell_level =
  if is_toplevel shell_level then () else dash_parse_done mss smark

val morbig_parse_cleanup : maybe morbig_string -> maybe stackmark -> shell_level -> unit
let morbig_parse_cleanup mss smark shell_level =
  if is_toplevel shell_level then () else morbig_parse_done mss smark

val parse_cleanup : parser_string -> maybe stackmark -> shell_level -> unit
let parse_cleanup ps =
  match ps with
    DashString s -> dash_parse_cleanup s
    | MorbigString s -> morbig_parse_cleanup s
  end


val parse_string_morbig_internal : string -> stmt
declare ocaml target_rep function parse_string_morbig_internal = `Morbig_shim.parse_string_morbig`

val parse_string_morbig : string -> stmt
let parse_string_morbig s0 = parse_string_morbig_internal s0
