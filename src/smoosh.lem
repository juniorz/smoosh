include import Smoosh_prelude
include import Os

val parse_init : parse_source -> maybe morbig_string
declare ocaml target_rep function parse_init = `Morbig_shim.parse_init`

val stack_init : unit -> stackmark
declare ocaml target_rep function stack_init = `Dash.init_stack`

val stack_pop : stackmark -> unit
declare ocaml target_rep function stack_pop = `Dash.pop_stack`

val parse_done : maybe morbig_string -> maybe stackmark -> unit
declare ocaml target_rep function parse_done = `Morbig_shim.parse_done`

val parse_next_internal : interactivity_mode -> parse_result
declare ocaml target_rep function parse_next_internal = `Morbig_shim.parse_next`

val parse_next : forall 'a. OS 'a => os_state 'a -> interactivity_mode -> os_state 'a * parse_result
let parse_next s0 interactive =
  match parse_next_internal interactive with
  | ParseDone    -> (s0,ParseDone)
  | ParseError s -> (s0,ParseError s)
  | ParseNull    -> (s0,ParseNull)
  | ParseStmt  c ->
     let s1 = 
       if Set.member Sh_verbose s0.sh.opts
       then safe_write_stderr (string_of_stmt c ^ "\n") s0
       else s0
     in
     (s1, ParseStmt c)
  end

val parse_cleanup : maybe morbig_string -> maybe stackmark -> shell_level -> unit
let parse_cleanup mss smark shell_level =
  if is_toplevel shell_level then () else parse_done mss smark

val parse_string_morbig_internal : string -> stmt
declare ocaml target_rep function parse_string_morbig_internal = `Morbig_shim.parse_string_morbig`

val parse_string_morbig : string -> stmt
let parse_string_morbig s0 = parse_string_morbig_internal s0
