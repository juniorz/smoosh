include import Pervasives_extra
include import Smoosh_num
include import Signal

import Debug

(* ??? What character set does lem use for strings? Does it matter? *)

(**********************************************************************)
(* UTILITY FUNCTIONS **************************************************)
(**********************************************************************)

val uppercase : string -> string
let uppercase s = toString (List.map uppercase_char (toCharList s))

let parens s = "( " ^ s ^ " )"

val tails : forall 'a. list 'a -> list (list 'a)
let rec tails xs =
  xs :: match xs with
        | [] -> []
        | _::xs' -> tails xs'
        end

val insertBy : forall 'a. ('a -> 'a -> bool) -> 'a -> list 'a -> list 'a
let rec insertBy lte x ys =
  match ys with
  | [] -> [x]
  | y::ys' -> if lte x y then x::y::ys' else y::(insertBy lte x ys')
  end

val sortBy : forall 'a. ('a -> 'a -> bool) -> list 'a -> list 'a
let sortBy lte xs = foldr (insertBy lte) [] xs

val sort : forall 'a. Ord 'a => list 'a -> list 'a
let sort = sortBy (<=)

val isInfixOf : forall 'a. Eq 'a => list 'a -> list 'a -> bool
let isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)

val ltrim_newlines_cl : list char -> list char
let rec ltrim_newlines_cl cl =
  match cl with
  | [] -> []
  | #'\n'::cl' -> ltrim_newlines_cl cl'
  | _ -> cl
  end

val intersperse : forall 'a. 'a -> list 'a -> list 'a
let rec intersperse sep xs =
  match xs with
  | [] -> []
  | [x] -> [x]
  | x::xs' -> x::sep::intersperse sep xs'
  end

val trimr_one_newline : string -> string
let trimr_one_newline s =
  let cl = toCharList s in
  match reverse cl with
  | [] -> ""
  | #'\n'::cl' -> toString (reverse cl')
  | _ -> s
  end

val trimr_newlines : string -> string
let trimr_newlines s =
  let cl = toCharList s in
  toString (reverse (ltrim_newlines_cl (reverse cl)))

val pad_left_with : char -> string -> nat -> string
let pad_left_with c s len =
  let padding = max (len - stringLength s) 0 in
  toString (replicate padding c)  ^ s

val pad_right_with : char -> string -> nat -> string
let pad_right_with c s len =
  let padding = max (len - stringLength s) 0 in
  s ^ toString (replicate padding c) 

val pad_right : string -> nat -> string
let pad_right = pad_right_with #' '

val maximum : forall 'a. OrdMaxMin 'a => list 'a -> 'a
let rec maximum xs =
  match xs with
  | [] -> failwith "maximum got empty list"
  | [x] -> x
  | x::xs' -> max x (maximum xs')
  end

(* puts the thing that the predicate matches on the right (for easy access) *)
val break : forall 'a. ('a -> bool) -> list 'a -> (list 'a) * (list 'a)
let rec break p ls =
  match ls with
  | [] -> ([], [])
  | x::xs ->
    if p x
    then ([], x::xs)
    else let (xs', xs'') = break p xs in (x::xs', xs'')
  end

val spaced : string -> string -> string
let spaced s1 s2 =
  let sep = if s1 <> "" && s2 <> "" then " " else "" in
  s1 ^ sep ^ s2

val spaced_many : list string -> string
let rec spaced_many ss =
  match ss with
  | [] -> ""
  | [s] -> s
  | s::ss' -> spaced s (spaced_many ss')
  end

val break_on_esc : bool -> char -> list char -> (list char) * (list char)
let rec break_on_esc escapable sep ls =
  match (escapable,ls) with
  | (_,[]) -> ([], [])
  | (true,#'\\'::c::cs) ->
     let (cs', cs'') = break_on_esc escapable sep cs in 
     (#'\\'::c::cs', cs'')
  | (_,c::cs) ->
    if sep = c
    then ([], cs)
    else let (cs', cs'') = break_on_esc escapable sep cs in 
         (c::cs', cs'')
  end

val split_on : bool -> char -> list char -> list (list char)
let rec split_on escapable sep cs =
  match break_on_esc escapable sep cs with
  | ([], []) -> []
  | (cs', []) -> [cs']
  | (cs', cs'') -> cs'::(split_on escapable sep cs'')
  end

val split_string_on : bool -> char -> string -> list string
let split_string_on escapable sep s =
  map toString (split_on escapable sep (toCharList s))

val adjust_nth : forall 'a 'b. list 'a -> nat -> ('a -> 'a * 'b) -> maybe (list 'a * 'b)
let rec adjust_nth l n f =
  match (l,n) with
  | ([],_) -> Nothing
  | (v::l',0) -> 
     let (v',res) = f v in
     Just (v'::l',res)
  | (v::l',_) ->
     match adjust_nth l' (n-1) f with
     | Nothing -> Nothing
     | Just (l'',res) -> Just (v::l'',res)
     end
  end

(**********************************************************************)
(* LOCALES ************************************************************)
(**********************************************************************)

type range_char = 
    RChar of char
  | RCollating of string

type locale = 
  <| name : string ;
     collates : char -> string -> bool ; 
     equiv : char -> string -> bool ; 
     charclass : char -> string -> bool ; 
     range : char -> range_char -> range_char -> bool |>

(* TODO: look at LC_ environment variables, decide what to do *)

(* need functions for various locale operations on, e.g., matching collating elements, equivalence classes, character classes, and ranges *)

let between lo c hi = lo <= c && c <= hi

let rec ambient_charclass c cls = 
  match cls with     (* TODO expose is_ functions from ctypes into ocaml, just use those *)
  | "alnum" -> ambient_charclass c "alpha" || ambient_charclass c "digit"
  | "alpha" -> ambient_charclass c "upper" || ambient_charclass c "lower"
  | "blank" -> elem c (toCharList " \t")
  | "cntrl" -> ord c < ord #' ' || ord c = 127 (* del *)
  | "digit" -> elem c (toCharList "0123456789")
  | "graph" -> ambient_charclass c "alnum" || ambient_charclass c "punct"
  | "lower" -> between (ord #'a') (ord c) (ord #'z')
  | "print" -> ambient_charclass c "graph" || c = #' '
  | "punct" -> elem c (toCharList "!\"#$%&'()*+,-./:;<=>?@[\\]^_{}~|") || ord c = 200 (* grave accent *)
  | "space" -> elem c (toCharList " \t\n\r") || ord c = 11 (* VT *) || ord c = 14 (* FF *)
  | "upper" -> between (ord #'A') (ord c) (ord #'Z')
  | "xdigit" -> elem c (toCharList "0123456789ABCDEFabcdef")
  | _ -> false
  end 

let lc_ambient = 
  let collates c cls = elem c (toCharList cls) in (* TODO strcoll-ish *)
  let equiv c cls = elem c (toCharList cls) in (* derp derp *)
  let rchar (rc:range_char) : maybe char =
    match rc with
    | RChar c -> Just c
    | RCollating s -> 
       match toCharList s with
       | [c] -> Just c
       | _ -> Nothing
       end
    end in
  let range c rlo rhi = 
    match (rchar rlo, rchar rhi) with
    | (Just lo, Just hi) -> between (ord lo) (ord c) (ord hi)
    | _ -> false
    end in
  <| name = "ambient" ; collates = collates ; equiv = equiv ; charclass = ambient_charclass ; range = range |>

(**********************************************************************)
(* FILE PERMISSIONS ***************************************************)
(**********************************************************************)

type file_perm = Read | Write | Execute

(* can be interpreted as a mask or as actual permissions *)
type perms = <|
    setuid: bool;
    setgid: bool;
    sticky: bool;
    user: set file_perm;
    group: set file_perm;
    other: set file_perm
  |>

val perms_all_clear : perms
let perms_all_clear =
  <| setuid = false; setgid = false; sticky = false;
     user = Set.empty;
     group = Set.empty;
     other = Set.empty |>

val all_file_perms : set file_perm
let all_file_perms = Set.fromList [Read; Write; Execute]

val default_umask : perms
let default_umask = <| setuid = false; setgid = false; sticky = false;
                       user = Set.empty;
                       group = Set.singleton Write;
                       other = Set.singleton Write |>

val invert_file_perms : set file_perm -> set file_perm
let invert_file_perms fperms = Set.difference all_file_perms fperms

val invert_perms : perms -> perms
let invert_perms perms =
  <| setuid = not perms.setuid;
     setgid = not perms.setgid;
     sticky = not perms.sticky;
     user   = invert_file_perms perms.user;
     group  = invert_file_perms perms.group;
     other  = invert_file_perms perms.other
  |>

(**********************************************************************)
(* Basic parsing and rendering of perms *******************************)
(**********************************************************************)

val nat_of_file_perms : set file_perm -> nat
let nat_of_file_perms fperms =
  let bit0 = if Set.member Execute fperms then 1 else 0 in
  let bit1 = if Set.member Write   fperms then 2 else 0 in
  let bit2 = if Set.member Read    fperms then 4 else 0 in
  bit0 + bit1 + bit2

val file_perms_of_nat : nat -> set file_perm
let file_perms_of_nat n =
  let r = if has_bit n 0 then Set.singleton Execute else Set.empty in
  let w = if has_bit n 1 then Set.singleton Write   else Set.empty in
  let x = if has_bit n 2 then Set.singleton Read    else Set.empty in
  Set.(union) r (Set.(union) w x)

val perms_of_nat : nat -> perms
let perms_of_nat n =
  <| other  = file_perms_of_nat n;
     group  = file_perms_of_nat (n / 8);
     user   = file_perms_of_nat (n / 64);
     sticky = has_bit n 9;
     setgid = has_bit n 10;
     setuid = has_bit n 11
  |>

val nat_of_perms : perms -> nat
let nat_of_perms perms =
  let bit0 = if perms.sticky then 1 else 0 in
  let bit1 = if perms.setgid then 2 else 0 in
  let bit2 = if perms.setuid then 4 else 0 in
  let first  = bit0 + bit1 + bit2 in
  let second = nat_of_file_perms perms.user in
  let third  = nat_of_file_perms perms.group in
  let fourth = nat_of_file_perms perms.other in
  (2**9 * first) + (2**6 * second) + (2**3 * third) + fourth

val octal_string_of_perms : perms -> string
let octal_string_of_perms perms =
  let bit0 = if perms.sticky then 1 else 0 in
  let bit1 = if perms.setgid then 2 else 0 in
  let bit2 = if perms.setuid then 4 else 0 in
  let first  = stringFromNat (bit0 + bit1 + bit2) in
  let second = stringFromNat (nat_of_file_perms perms.user) in
  let third  = stringFromNat (nat_of_file_perms perms.group) in
  let fourth = stringFromNat (nat_of_file_perms perms.other) in
  first ^ second ^ third ^ fourth

val string_of_file_perms : set file_perm -> string
let string_of_file_perms fperms = 
  let r = if Set.member Read    fperms then "r" else "" in
  let w = if Set.member Write   fperms then "w" else "" in
  let x = if Set.member Execute fperms then "x" else "" in
  r ^ w ^ x

val string_of_perms : perms -> string
let string_of_perms perms =
  let u = string_of_file_perms perms.user in
  let g = string_of_file_perms perms.group in
  let o = string_of_file_perms perms.other in
  "u=" ^ u ^ "," ^
  "g=" ^ g ^ "," ^
  "o=" ^ o

(**********************************************************************)
(* Symbolic file permissions a la chmod *******************************)
(**********************************************************************)

(* Grammar fragments taken from chmod spec
   http://pubs.opengroup.org/onlinepubs/9699919799/utilities/chmod.html *)

(*
wholist          : who | wholist who
who              : 'u' | 'g' | 'o' | 'a'
*)
type perms_who = WhoU | WhoG | WhoO

let perms_wholist_all = Set.fromList [WhoU; WhoG; WhoO]

val perms_who : perms_who -> perms -> set file_perm
let perms_who who perms =
  match who with
  | WhoU -> perms.user
  | WhoG -> perms.group
  | WhoO -> perms.other
  end

val perms_for : (set file_perm -> set file_perm) -> perms_who -> perms -> perms
let perms_for f who perms =
  match who with
  | WhoU -> <| perms with user = f perms.user |>
  | WhoG -> <| perms with group = f perms.group |>
  | WhoO -> <| perms with other = f perms.other |>
  end

val perms_for_many : (set file_perm -> set file_perm) -> set perms_who -> perms -> perms
let perms_for_many f who perms = List.foldr (perms_for f) perms (Set_extra.toList who)

val perms_clear : set perms_who -> perms -> perms
let perms_clear who perms = perms_for_many (fun _ -> Set.empty) who perms

val perms_wholist_of_cl 
    : set perms_who -> list char -> either string (set perms_who * list char)
let rec perms_wholist_of_cl who cs = 
  match cs with
  | #'u'::cs' -> perms_wholist_of_cl (Set.insert WhoU who) cs'
  | #'g'::cs' -> perms_wholist_of_cl (Set.insert WhoG who) cs'
  | #'o'::cs' -> perms_wholist_of_cl (Set.insert WhoO who) cs'
  | #'a'::cs' -> perms_wholist_of_cl perms_wholist_all cs'
  | _ -> 
     if Set.null who 
     then Left "empty wholist: need to specify one of ugoa"
     else Right (who, cs)
  end

(* 
permlist         : perm | perm permlist
perm             : 'r' | 'w' | 'x' | 'X' | 's' | 't'  
*)
(* renaming to perms_flag just for clarity *)
type perms_flag = PermR | PermW | PermX | PermBigX | PermS | PermT

val flag_of_file_perm : file_perm -> perms_flag
let flag_of_file_perm fp =
  match fp with
  | Read -> PermR
  | Write -> PermW
  | Execute -> PermX
  end

val perms_flaglist_of_cl
  : set perms_flag -> list char -> either string (set perms_flag * list char)
let rec perms_flaglist_of_cl perms cs =
  match cs with
  | #'r'::cs' -> perms_flaglist_of_cl (Set.insert PermR perms) cs'
  | #'w'::cs' -> perms_flaglist_of_cl (Set.insert PermW perms) cs'
  | #'x'::cs' -> perms_flaglist_of_cl (Set.insert PermX perms) cs'
  | #'X'::cs' -> perms_flaglist_of_cl (Set.insert PermBigX perms) cs'
  | #'s'::cs' -> perms_flaglist_of_cl (Set.insert PermS perms) cs'
  | #'t'::cs' -> perms_flaglist_of_cl (Set.insert PermT perms) cs'
  | _ -> 
     if Set.null perms 
     then Left "empty permlist: need to specify one of rwxXst"
     else Right (perms, cs) 
  end

(*
actionlist       : action | actionlist action
action           : op | op permlist | op permcopy
permcopy         : 'u' | 'g' | 'o'
op               : '+' | '-' | '='
*)

type perms_op = OpPlus | OpMinus | OpEqual
type perms_action = 
    ActOp of perms_op 
  | ActPerms of perms_op * set perms_flag
  | ActCopy of perms_op * perms_who

val perms_op_of_cl : list char -> either string (perms_op * list char)
let perms_op_of_cl cs =
  match cs with
  | #'+'::cs' -> Right (OpPlus, cs')
  | #'-'::cs' -> Right (OpMinus, cs')
  | #'='::cs' -> Right (OpEqual, cs')
  | c::_ -> Left ("expected op (one of +-=), got '" ^ toString [c] ^ "'")
  | [] -> Left ("expected op (one of +-=, got empty string")
  end

val perms_actionlist_of_cl 
  : list perms_action -> list char -> either string (list perms_action * list char)
let rec perms_actionlist_of_cl actions cs =
  match perms_op_of_cl cs with
  | Right (op, cs') ->
     (* we need to check whether we have a list of perms, a ugo to copy, or nothing 
      *)
     match (cs', perms_flaglist_of_cl Set.empty cs') with
       (* ugo? *)
     | (#'u'::cs'', _) -> perms_actionlist_of_cl ((ActCopy op WhoU)::actions) cs''
     | (#'g'::cs'', _) -> perms_actionlist_of_cl ((ActCopy op WhoG)::actions) cs''
     | (#'o'::cs'', _) -> perms_actionlist_of_cl ((ActCopy op WhoO)::actions) cs''
       (* permlist? *)
     | (_, Right (permlist,cs'')) ->
        perms_actionlist_of_cl (ActPerms op permlist::actions) cs''
       (* must be plain! *)
     | _ -> perms_actionlist_of_cl (ActOp op::actions) cs'
     end
  | Left msg -> 
     (* we didn't get an op, so just make sure our list is nonempty *)
     if null actions
     then Left ("empty actionlist: " ^ msg)
     else 
       (* reverse to get them back in the original order *)
       Right (List.reverse actions, cs)
  end


(* 
clause           : actionlist | wholist actionlist
*)

type perms_clause = (set perms_who) * list perms_action

val perms_clause_of_cl : list char -> either string (perms_clause * list char)
let perms_clause_of_cl cs =
  let (who, cs') =
    match perms_wholist_of_cl Set.empty cs with
    | Right (who, cs') -> (who, cs')
    | Left _ -> 
       (* when unspecified, perms mean ALL *)
       (perms_wholist_all, cs)
    end 
  in
  match perms_actionlist_of_cl [] cs' with
  | Right (actions, cs'') -> Right ((who, actions), cs'')
  | Left msg -> Left ("bad clause: " ^ msg)
  end

(* symbolic_mode    : clause | symbolic_mode ',' clause *)
type perms_symbolic = list perms_clause

val perms_symbolic_of_cl 
    : perms_symbolic -> list char -> either string (perms_symbolic * list char)
let rec perms_symbolic_of_cl perms cs =
  match perms_clause_of_cl cs with
  | Left msg -> Left ("no clauses found: " ^ msg)
  | Right (clause, []) -> Right (clause::perms, [])
  | Right (clause, #','::cs') -> perms_symbolic_of_cl (clause::perms) cs'
  | Right (_,c::_) -> 
     Left ("expected comma between clauses, found '" ^ toString [c] ^ "'")
  end

val perms_symbolic_of_string : string -> either string perms_symbolic
let rec perms_symbolic_of_string s = 
  match perms_symbolic_of_cl [] (toCharList s) with
  | Left msg -> Left msg
  | Right (perms,[]) -> Right perms
  | Right (_,cs') -> Left ("invalid symbolic permissions: " ^ toString cs')
  end

(**********************************************************************)
(* SHELL OPTIONS ******************************************************)
(**********************************************************************)
  
type sh_opt = 
    Sh_allexport   
  | Sh_errexit
  | Sh_ignoreeof
  | Sh_earlyhash   (* not supported by dash *)
  | Sh_interactive
  | Sh_monitor     (* UP option *)
  | Sh_noclobber
  | Sh_noglob
  | Sh_noexec
  | Sh_nolog
  | Sh_notify      (* UP option *)
  | Sh_nounset
  | Sh_verbose
  | Sh_vi
  | Sh_xtrace      

let all_sh_opts = 
  [ Sh_allexport
  ; Sh_errexit
  ; Sh_ignoreeof
  ; Sh_earlyhash
  ; Sh_interactive
  ; Sh_monitor 
  ; Sh_noclobber
  ; Sh_noglob
  ; Sh_noexec
  ; Sh_errexit
  ; Sh_nolog
  ; Sh_notify
  ; Sh_nounset
  ; Sh_verbose
  ; Sh_vi
  ; Sh_xtrace ]

let unimplemented_sh_opts = 
  [ (* will not support these *)
    Sh_earlyhash
  ; Sh_vi

    (* TODO 2018-10-02 job control *)
  ; Sh_notify

    (* TODO 2018-09-10 implement remaining set flags *)
    (* need an equivalent of EV_TESTED: extra param to step_eval? *)
  ; Sh_errexit
    (* need history *)
  ; Sh_nolog
  ]

let string_of_sh_opt o =
  match o with
  | Sh_allexport   -> "allexport"
  | Sh_errexit     -> "errexit"
  | Sh_ignoreeof   -> "ignoreeof"
  | Sh_earlyhash   -> "earlyhash"
  | Sh_interactive -> "interactive"
  | Sh_monitor     -> "monitor"
  | Sh_noclobber   -> "noclobber"
  | Sh_noglob      -> "noglob"
  | Sh_noexec      -> "noexec"
  | Sh_nolog       -> "nolog"
  | Sh_notify      -> "notify"
  | Sh_nounset     -> "nounset"
  | Sh_verbose     -> "verbose"
  | Sh_vi          -> "vi"
  | Sh_xtrace      -> "xtrace"
  end

let char_of_sh_opt o =
  match o with
  | Sh_allexport -> Just #'a'
  | Sh_errexit -> Just #'e'
  | Sh_ignoreeof -> Nothing
  | Sh_earlyhash -> Just #'h'
  | Sh_interactive -> Just #'i'
  | Sh_monitor  -> Just #'m'
  | Sh_noclobber -> Just #'C'
  | Sh_noglob -> Just #'f'
  | Sh_noexec -> Just #'n'
  | Sh_nolog -> Nothing
  | Sh_notify  -> Just #'b'
  | Sh_nounset -> Just #'u'
  | Sh_verbose -> Just #'v'
  | Sh_vi -> Nothing
  | Sh_xtrace -> Just #'x'
  end

let sh_opt_of_shortopt so = 
  match so with
  | #'a' -> Just Sh_allexport
  | #'b' -> Just Sh_notify   
  | #'C' -> Just Sh_noclobber
  | #'e' -> Just Sh_errexit  
  | #'f' -> Just Sh_noglob   
  | #'h' -> Just Sh_earlyhash
  | #'m' -> Just Sh_monitor  
  | #'n' -> Just Sh_noexec   
  | #'u' -> Just Sh_nounset  
  | #'v' -> Just Sh_verbose  
  | #'x' -> Just Sh_xtrace   
  | _ -> Nothing
  end

let sh_opt_of_longopt lo =
  match lo with
  | "allexport" -> Just Sh_allexport
  | "errexit" -> Just Sh_errexit
  | "ignoreeof" -> Just Sh_ignoreeof
  | "monitor" -> Just Sh_monitor
  | "noclobber" -> Just Sh_noclobber
  | "noglob" -> Just Sh_noglob
  | "noexec" -> Just Sh_noexec
  | "nolog" -> Just Sh_nolog
  | "notify" -> Just Sh_notify
  | "nounset" -> Just Sh_nounset
  | "verbose" -> Just Sh_verbose
  | "vi" -> Just Sh_vi
  | "xtrace" -> Just Sh_xtrace
  | _ -> Nothing
  end
  
(**********************************************************************)
(* Patterns ***********************************************************)
(**********************************************************************)

type substring_mode =
  Shortest
| Longest
| Exact

type substring_side =
  Prefix
| Suffix  

type tilde_mode =
    NoTilde
  | YesTilde

(**********************************************************************)
(* Commands ***********************************************************)
(**********************************************************************)

type redir_type = To | Clobber | From | FromTo | Append
type dup_type = ToFD | FromFD
type heredoc_type = Here (* quoted heredoc name, for when the heredoc shouldn't do any expansion *) | XHere (* unquoted, do expansion *)

(**********************************************************************)
(* AST ****************************************************************)
(**********************************************************************)

type pid = nat

type format =
    Normal
  | Default of words
  | NDefault of words
  | Assign of words
  | NAssign of words
  | Error of words
  | NError of words
  | Alt of words
  | NAlt of words
  | Length
  | Substring of substring_side * substring_mode * words
                                
(* Treating parameters niavely led to a problem when evaluating
 * ${x=${x=foo}bar${x=baz}} incorrectly when x was unset
 *)
and control =
    Tilde
  | TildeUser of string
  | Param of string * format
  | LAssign of string * expanded_words * words (* runtime technicality *)
  | LMatch of fields * substring_side * substring_mode * expanded_words * words (* runtime technicality *)
  | LError of string * expanded_words * words (* runtime technicality *)
  | Backtick of stmt
  | LBacktick of stmt (* original stmt *) * pid * fd (* pipe [read] *)
  | Arith of expanded_words (* runtime technicality *) * words
  | Quote of expanded_words (* runtime technicality *) * words

and entry =
    S of string
  | K of control
  | F
  | ESym of sym (* embedded symbolic entries *)

and words = list entry

and stmt =
    Command of list (string * words) * words * list redir
  | CommandExpAssign of list (string * expansion_state) * words * list redir
  | CommandExpArgs of list (string * fields) * expansion_state * list redir
  | CommandExpRedirs of list (string * fields) * fields * redir_state * bool (* allow function ? *)
  | Pipe of bool (* bg? *) * list stmt
  | Redir of stmt * redir_state
  | Background of stmt * redir_state
  | Subshell of stmt * redir_state
  | And of stmt * stmt
  | Or of stmt * stmt
  | Not of stmt
  | Semi of stmt * stmt
  | If of stmt * stmt * stmt
  | While of stmt * stmt
  | WhileCond of stmt (* original cond *) * stmt (* current cond *) * stmt (* original body *)
  | WhileRunning of stmt (* original cond *) * stmt (* original body *) * stmt (* current body *)
  | For of string * words * stmt
  | ForExpArgs of string * expansion_state * stmt
  | ForExpanded of string * fields * stmt
  | ForRunning of string * fields * stmt (* original body *) * stmt (* current body *)
  | Case of words * list (list words * stmt)
  | CaseExpArg of expansion_state * list (list words * stmt)
  | CaseMatch of symbolic_string * list (list words * stmt)
  | CaseCheckMatch of symbolic_string * expansion_state (* current pattern *) * stmt (* current command(s) *) * list (list words * stmt) (* remaining cases *)
  | Defun of string * stmt
  | Call of nat (* outer loop_nest, to be restored *) * fields (* outer $1, $2, $3, etc *) * string (* function name *) * stmt (* orig body *) * stmt (* current body *)
  | Break of nat
  | Continue of nat
  | Return
  | Exit
  | Exec of symbolic_string * list symbolic_string * env
  | Wait of pid * maybe nat (* Nothing = block; Just n = n steps *)
  | Pushredir of stmt * saved_fds
  | Done

(* TODO 2018-08-24 refactor into redir 'a with appropriate params *)
and redir = 
   | RFile of redir_type * nat * words
   | RDup of dup_type * nat * maybe nat (* Nothing if we're just closing *)
   | RHeredoc of heredoc_type * nat * words

and expanding_redir =
   | XRFile of redir_type * nat * expansion_state
   | XRHeredoc of heredoc_type * nat * expansion_state

and expanded_redir = 
   | ERFile of redir_type * nat * fields
   | ERDup of dup_type * bool (* close_orig? *) * nat * maybe nat
   | ERHeredoc of heredoc_type * nat * fields

and redir_state = list expanded_redir * maybe expanding_redir * list redir

(**********************************************************************)
(* Expansion **********************************************************)
(**********************************************************************)

and expanded_word =
   UsrF
 | ExpS of string
 | UsrS of string
 | At of fields
 | DQuo of symbolic_string
 | EWSym of sym

and expanded_words = list expanded_word

(* final expansion output *)
and sym =
    SymArith of fields (* symbolic result of arithmetic evaluation *) (* TODO is fields necessary? *)
  | SymCommand of stmt (* symbolic result of evaluating a command *)
  | SymPat of substring_side * substring_mode * symbolic_string * symbolic_string (* symbolic result of pattern matching (mode, pat, string) *)
and symbolic_char =
    C of char
  | Sym of sym
and symbolic_string = list symbolic_char

and fields = list (symbolic_string)

and tmp_field =
    WFS
  | FS
  | Field of symbolic_string
  | QField of symbolic_string

and intermediate_fields = list tmp_field

and expansion_state = 
    (* the constructor name indicates the *next* step to perform *)
    ExpStart of words
  | ExpExpand of tilde_mode * expanded_words * words 
  | ExpSplit of expanded_words
  | ExpPath of intermediate_fields
  | ExpQuote of intermediate_fields
  | ExpError of fields
  | ExpDone of fields

and expansion_step =
    ESTilde of string
  | ESParam of string
  | ESCommand of string
  | ESArith of string
  | ESSplit of string
  | ESPath of string
  | ESQuote of string
  | ESStep of string
  | ESNested of expansion_step * expansion_step
  | ESEval of expansion_step * evaluation_step

and evaluation_step =
    XSSimple of string
  | XSPipe of string
  | XSRedir of string
  | XSBackground of string
  | XSSubshell of string
  | XSAnd of string
  | XSOr of string
  | XSNot of string
  | XSSemi of string
  | XSIf of string
  | XSWhile of string
  | XSFor of string
  | XSCase of string
  | XSDefun of string
  | XSStack of string (* function name *) * evaluation_step 
  | XSStep of string
  | XSExec of string
  | XSWait of string
  | XSProc of pid * stmt
  | XSNested of evaluation_step * evaluation_step
  | XSExpand of evaluation_step * expansion_step

(**********************************************************************)
(* SHELL STATE ********************************************************)
(**********************************************************************)

(* File descriptors *)         
and fd = nat

(* Paths *)
and path = string

(* Information for saved FDs during redirect: put in a list to indicate each FD
   e.g., Map.fromList [(0,Close);(1,Saved 31);(4,Close)] says that:
     - STDIN was opened for a redirect and should be closed
     - that STDOUT was saved as fd 31 
     - STDERR was closed before and should stay closed
     - fd 3 was closed before and should stay closed
     - fd 4 was opened for the redirect but should be closed
 *)

and saved_fd_info = Saved of fd | Close 

and saved_fds = list (fd * saved_fd_info)

(* environments *)       
and env = Map.map string symbolic_string

and job_stopped = TSTP | STOP | TTIN | TTOU

and job_status = 
    JobRunning 
  | JobStopped of job_stopped 
  | JobTerminated of signal
  | JobDone of nat

and job_info = <| 
    id: nat; (* tricky invariant... shouldn't be any dups *)
    pid: pid;
    cmd: stmt;
    status: job_status;
    pgrp: nat |>

and shell_state = <|
    opts: set sh_opt;
    (* each signal is either:
         not present (default)
         ""          (ignore)
         cmd         (handle)
    *)
    traps: map signal symbolic_string;
    (* tricky invariant with job ids! *)
    jobs: list job_info;
    (* no explicit stack of params... we use Call stmt as a stack frame *)
    positional_params: list symbolic_string; (* $0, $1, $2, $3, ... *)
    env: env;
    readonly: set string;
    export: set string;
    funcs: Map.map string stmt;                 
    aliases: Map.map string string;
    cwd: string;
    locale: locale;
    loop_nest: nat (* for tracking break/continue *)
 |>

val STDIN : fd
val STDOUT : fd
val STDERR : fd
let STDIN = 0
let STDOUT = 1
let STDERR = 2

(* for sorting the job list *)
instance (Eq job_info)
  let (=) job1 job2 = job1.id = job2.id
  let (<>) job1 job2 = job1.id <> job2.id
end

instance (Ord job_info)
  let compare job1 job2 = compare job1.id job2.id
  let (<) job1 job2 = job1.id < job2.id
  let (<=) job1 job2 = job1.id <= job2.id
  let (>) job1 job2 = job1.id > job2.id
  let (>=) job1 job2 = job1.id >= job2.id
end

(**********************************************************************)
(* SYMBOLIC STRING FUNCTIONS ******************************************)
(**********************************************************************)

val first_is_slash : path -> bool
let first_is_slash path = 
  path <> "" && nth path 0 = #'/'

val last_is_slash : path -> bool
let last_is_slash path = 
  path <> "" && nth path (stringLength path - 1) = #'/'

val join_path : path -> path -> path
let join_path root ext = root ^ (if last_is_slash root then "" else "/") ^ ext

val null_sym : sym -> maybe bool
let null_sym sym =
  match sym with
  | SymArith _ -> Just false
  | SymCommand _ -> Nothing
  | SymPat _ _ _ _-> Nothing
  end

val null_char : symbolic_char -> maybe bool
let null_char c =
  match c with
  | C _ -> Just false
  | Sym sym -> null_sym sym
  end

val null_string : symbolic_string -> maybe bool
let rec null_string sym_str = 
  match sym_str with
  | [] -> Just true
  | c::cs ->
    let only_false mb =
      match mb with
      | Just true -> Nothing
      | Just false -> Just false
      | Nothing -> Nothing
      end
    in
    match null_char c with
    | Just true -> only_false (null_string cs)
    | Just false -> Just false
    | Nothing -> only_false (null_string cs)
    end
  end

val null_fields : fields -> maybe bool
let rec null_fields fs = 
  match fs with
  | [] -> Just true
  | f::fs -> 
     match (null_string f, null_fields fs) with
     | (Just true,  Just true)  -> Just true
     | (Just false, _)          -> Just false
     | (_,          Just false) -> Just false
     | (_,          _)          -> Nothing
     end
   end

val symbolic_string_of_fields : fields -> symbolic_string
let rec symbolic_string_of_fields fs = 
  match fs with
  | [] -> []
  | [f] -> f
  | f::fs' -> f ++ [C #' '] ++ symbolic_string_of_fields fs'
  end

val maximal_char_list : symbolic_string -> (list char * symbolic_string)
let rec maximal_char_list sym_str =
  match sym_str with
  | [] -> ([], [])
  | C c::rest ->
    let (cs, sym_str') = maximal_char_list rest in
    (c::cs, sym_str')
  | Sym _::_ -> ([], sym_str)
  end

val words_of_symbolic_string : symbolic_string -> words
let rec words_of_symbolic_string sym_str =
  match sym_str with
  | [] -> []
  | C _::_ ->
    let (cs, sym_str') = maximal_char_list sym_str in
    S (toString cs)::words_of_symbolic_string sym_str'
  | Sym sym::sym_str' -> ESym sym::words_of_symbolic_string sym_str'
  end

val words_of_fields : fields -> words
let words_of_fields fs = words_of_symbolic_string (symbolic_string_of_fields fs)

val expanded_words_of_symbolic_string : symbolic_string -> expanded_words
let rec expanded_words_of_symbolic_string sym_str =
  match sym_str with
  | [] -> []
  | C _::_ ->
    let (cs, sym_str') = maximal_char_list sym_str in
    ExpS (toString cs)::expanded_words_of_symbolic_string sym_str'
  | Sym sym::sym_str' -> EWSym sym::expanded_words_of_symbolic_string sym_str'
  end

val expanded_words_of_fields : fields -> expanded_words
let expanded_words_of_fields fs = expanded_words_of_symbolic_string (symbolic_string_of_fields fs)

val symbolic_string_of_char_list : list char -> symbolic_string
let symbolic_string_of_char_list cs = map C cs

val symbolic_string_of_string : string -> symbolic_string
let symbolic_string_of_string s = symbolic_string_of_char_list (toCharList s)

val fields_of_symbolic_string : symbolic_string -> fields
let fields_of_symbolic_string s = [s]

val try_concrete : symbolic_string -> maybe string
let rec try_concrete vs =
  match vs with
  | [] -> Just ""
  | C(c)::vs' -> 
     match try_concrete vs' with
     | Nothing -> Nothing
     | Just cs -> Just (toString [c] ^ cs)
     end
  | Sym _::_ -> Nothing
  end

val try_concrete_fields : fields -> maybe string
let rec try_concrete_fields fs =
  match fs with
  | [] -> Just ""
  | [ss] -> try_concrete ss
  | ss::fs' ->
     match try_concrete ss with
     | Nothing -> Nothing
     | Just s -> 
        match try_concrete_fields fs' with
        | Nothing -> Nothing
        | Just s' -> Just (s ^ " " ^ s')
        end
     end
  end       

val try_concrete_fields_list : fields -> maybe (list string)
let rec try_concrete_fields_list fs =
  match fs with
  | [] -> Just []
  | ss::fs' -> 
     match (try_concrete ss, try_concrete_fields_list fs') with
     | (Just s, Just rest) -> Just (s::rest)
     | _ -> Nothing
     end
  end

val string_of_symbolic : sym -> string
let string_of_symbolic _sym = "<<SYMBOLIC>>"

val string_of_symbolic_char : symbolic_char -> string
let string_of_symbolic_char c =
  match c with
  | C c -> toString [c]
  | Sym sym -> string_of_symbolic sym
  end

val char_list_of_symbolic_string : symbolic_string -> list char
let rec char_list_of_symbolic_string sym_str =
  match sym_str with
  | [] -> []
  | (C c::cs) -> c::char_list_of_symbolic_string cs
  | (Sym sym)::cs -> toCharList (string_of_symbolic sym) ++ char_list_of_symbolic_string cs
  end
   
val string_of_symbolic_string : symbolic_string -> string
let rec string_of_symbolic_string sym_str =
  match sym_str with
  | [] -> ""
  | c::cs -> string_of_symbolic_char c ^ string_of_symbolic_string cs
  end

val string_of_fields : fields -> string
let rec string_of_fields fs = 
  match fs with
  | [] -> ""
  | [f] -> string_of_symbolic_string f
  | f::fs' -> string_of_symbolic_string f ^ " " ^ string_of_fields fs'
  end

val concat_expanded : expanded_words -> symbolic_string
let rec concat_expanded w =
  match w with
  | [] -> symbolic_string_of_string ""
  | UsrF::ws -> symbolic_string_of_string " " ++ concat_expanded ws
  | ExpS s::ws -> symbolic_string_of_string s ++ concat_expanded ws
  | DQuo ss::ws -> 
    (* we don't include the quotes, since they'll be ultimately erased anyway! *)
     ss ++ concat_expanded ws
  | At fs::ws -> 
     (* we collapse the result of $@ expansion, too. special cased in expand_control *)
     symbolic_string_of_fields fs ++ concat_expanded ws
  | EWSym sym::ws -> Sym sym::concat_expanded ws
  | UsrS _::_ -> Assert_extra.failwith "broken invariant in concat_expanded: no UsrS should be found"
  end

val collapse_quoted : expanded_words -> expanded_words
let collapse_quoted w = 
  let is_at e = 
    match e with
    | At _ -> true
    | _ -> false
  end in
  match break is_at w with
  | (w',[]) -> [DQuo (concat_expanded w')] (* no At anywhere, just collapse it *)
  | (pre_w, (At fs)::post_w) ->
     (* we have an At---attach pre_w to the first one, post_w to the last one *)
     pre_w ++ intersperse UsrF (map DQuo fs) ++ post_w
  | _ -> Assert_extra.failwith "broken invariant in collapse_quoted: couldn't find At anywhere, but got weird output"
  end

val fields_of_expanded_words : expanded_words -> fields
let fields_of_expanded_words w = [concat_expanded w]

val split_equal : string -> symbolic_string -> string * maybe symbolic_string
let rec split_equal var ss =
  match ss with
  | [] -> (var, Nothing)
  | (C #'=')::ss' -> (var, Just ss')
  | (C c)::ss' -> split_equal (var ^ toString [c]) ss'
  | _ -> (var ^ string_of_symbolic_string ss, Nothing)
  end

val try_split_assign : symbolic_string -> string * maybe symbolic_string
let try_split_assign ss = split_equal "" ss

val quote : string -> string
let rec quote s = 
  (* TODO 2018-09-05 implement *)
  s
                                    
(* Number type helpers *)

val integerToFields : integer -> fields
let integerToFields n = [symbolic_string_of_string (write n)]

val int32ToFields : int32 -> fields
let int32ToFields n = [symbolic_string_of_string (write n)]

val int64ToFields : int64 -> fields
let int64ToFields n = [symbolic_string_of_string (write n)]

(**********************************************************************)
(* AST HELPERS/SMART CONSTRUCTORS *************************************)
(**********************************************************************)

val assigns_of_env : env -> list (string * fields)
let assigns_of_env env = map (fun (x,v) -> (x,[v])) (Map_extra.toList env)

val sequence : list stmt -> stmt
let rec sequence stmts =
  match stmts with
  | [] -> Done
  | [stmt] -> stmt
  | stmt::stmts' -> Semi stmt (sequence stmts')
  end

val simple_command : string -> fields -> env -> stmt
let simple_command cmd args env =
  CommandExpRedirs
    (assigns_of_env env)
    ((symbolic_string_of_string cmd)::args)
    ([], Nothing, [])
    true (* allow functions *)

val skip : stmt
let skip = simple_command ":" [] Map.empty

val command_eval : symbolic_string -> stmt
let command_eval cmd = simple_command "eval" [cmd] Map.empty

val pushredir : stmt -> saved_fds -> stmt
let pushredir stmt saved_fds =
  if null saved_fds
  then stmt
  else Pushredir stmt saved_fds

val with_redirs : stmt -> list expanded_redir -> stmt
let with_redirs stmt ers =
  if null ers
  then stmt
  else Redir stmt (ers,Nothing,[])

val close_fd_and_then : fd -> stmt -> stmt
let close_fd_and_then fd stmt =
  Semi (Pushredir Done [(fd, Close)]) stmt

val is_terminating_control : stmt -> bool
let is_terminating_control c =
  match c with
  | Exit -> true
  | Return -> true
  | Break _ -> true
  | Continue _ -> true
  | Done -> true
  | _ -> false
  end

val get_expanding_redir_state : expanding_redir -> expansion_state
let get_expanding_redir_state er =
  match er with
  | XRFile _ _ es -> es
  | XRHeredoc _ _ es -> es
  end

val is_heredoc : expanding_redir -> bool
let is_heredoc er =
  match er with
  | XRFile _ _ _ -> false
  | XRHeredoc _ _ _ -> true
  end

val set_expanding_redir_state : expansion_state -> expanding_redir -> expanding_redir
let set_expanding_redir_state es er =
  match er with
  | XRFile ty src _ -> XRFile ty src es
  | XRHeredoc ty src _ -> XRHeredoc ty src es
  end

val expand_redir : expanding_redir -> fields -> expanded_redir
let expand_redir er f =
  match er with
  | XRFile ty src _ -> ERFile ty src f
  | XRHeredoc ty src _ -> ERHeredoc ty src f
  end

val is_active_job : job_info -> bool
let is_active_job job = 
  match job.status with
  | JobRunning -> true
  | JobStopped _ -> true
  | JobTerminated _ -> false
  | JobDone _ -> false
  end

val string_of_job_status : job_status -> string
let string_of_job_status status =
  match status with
  | JobRunning -> "Running"
  | JobStopped TSTP -> "Stopped (SIGTSTP)"
  | JobStopped STOP -> "Stopped (SIGSTOP)"
  | JobStopped TTIN -> "Stopped (SIGTTIN)"
  | JobStopped TTOU -> "Stopped (SIGTTOU)"
  | JobTerminated signal -> "Terminated (" ^ string_of_signal signal ^ ")"
  | JobDone 0 -> "Done"
  | JobDone code -> "Done (" ^ stringFromNat code ^ ")"
  end

(**********************************************************************)
(* PRETTY PRINTING ****************************************************)
(**********************************************************************)

val string_of_stmt : stmt -> string
val string_of_words : words -> string
val string_of_entry : entry -> string
val string_of_expansion_step : expansion_step -> string
val string_of_evaluation_step : evaluation_step -> string

let braces s = "{ " ^ s ^ " ; }"

(* we translate 
           cmds... &
   to
           { cmds & }
   this avoids issues with parsing; in particular,
     cmd1 & ; cmd2 & ; cmd3
   doesn't parse; it must be:
     cmd1 & cmd2 & cmd3
   it's a little too annoying to track "was the last thing
   backgrounded?" so the braces resolve the issue. testing
   indicates that they're semantically equivalent.
*)
let background s = "{ " ^ s ^ " & }"

let show_unless expected actual =
  if expected = actual
  then ""
  else stringFromNat actual

val string_of_simple 
    : forall 'a 'c 'r. 
      ('a -> string) -> ('c -> string) -> ('r -> string) ->
      list (string * 'a) -> 'c -> 'r -> string
let string_of_simple f_a f_c f_r assigns cmds redirs =
  let s_assigns = concat " " (List.map (fun (v,a) -> v ^ "=" ^ f_a a) assigns) in
  let s_cmds = f_c cmds in
  let s_redirs = f_r redirs in
  spaced_many [s_assigns; s_cmds; s_redirs]

let rec string_of_stmt c = 
  match c with
  | Command assigns cmds redirs ->
     string_of_simple string_of_words string_of_words string_of_redirs
       assigns cmds redirs
  | CommandExpAssign assigns cmds redirs -> 
     string_of_simple string_of_expansion_state string_of_words string_of_redirs
       assigns cmds redirs
  | CommandExpArgs assigns cmds redirs -> 
     string_of_simple string_of_fields string_of_expansion_state string_of_redirs
       assigns cmds redirs
  | CommandExpRedirs assigns cmds redir_state _allow_fun ->
     string_of_simple string_of_fields string_of_fields string_of_redir_state
       assigns cmds redir_state
  | Pipe bg cmds ->
     let p = concat " | " (List.map string_of_stmt cmds) in
     if bg then background p else p
  | Redir cmd redir_state -> 
     spaced (string_of_stmt cmd) (string_of_redir_state redir_state)
  | Background cmd redir_state -> 
     background (spaced (string_of_stmt cmd) (string_of_redir_state redir_state))
  | Subshell cmd redir_state ->
     parens (spaced (string_of_stmt cmd) (string_of_redir_state redir_state))
  | And cmd1 cmd2 ->
     string_of_stmt cmd1 ^ " && " ^ string_of_stmt cmd2
  | Or cmd1 cmd2 ->
     string_of_stmt cmd1 ^ " || " ^ string_of_stmt cmd2
  | Semi cmd1 cmd2 ->
     string_of_stmt cmd1 ^ " ; " ^ string_of_stmt cmd2
  | Not cmd ->
     "! " ^ string_of_stmt cmd
  | If c1 c2 c3 ->
     string_of_if c1 c2 c3
  | While c1 c2 -> string_of_while c1 c2
  | WhileCond c cur body -> 
     "if " ^ string_of_stmt cur ^ 
     "; then " ^ string_of_stmt body ^ "; " ^ string_of_while c body ^ "; fi"
  | WhileRunning c body cur -> 
     string_of_stmt cur ^ "; " ^ string_of_while c body
  | For x w c ->
     "for " ^ x ^ " in " ^ string_of_words w ^ "; do " ^ string_of_stmt c ^ "; done"
  | ForExpArgs x exp_state body ->
     "for " ^ x ^ " in " ^ string_of_expansion_state exp_state ^ "; do " ^ 
       string_of_stmt body ^ "; done"
  | ForExpanded x f body -> 
     "for " ^ x ^ " in " ^ string_of_fields f ^ "; do " ^ 
       string_of_stmt body ^ "; done"
  | ForRunning x f body cur -> 
     string_of_stmt cur ^ "; " ^ 
     "for " ^ x ^ " in " ^ string_of_fields f ^ "; do " ^ string_of_stmt body ^ "; done"
  | Case w cs ->
     "case " ^ string_of_words w ^ " in " ^ 
       concat " " (List.map string_of_case cs) ^ " esac"
  | CaseExpArg exp cs -> 
     "case " ^ string_of_expansion_state exp ^ " in " ^ 
       concat " " (List.map string_of_case cs) ^ " esac"
  | CaseMatch s cs ->
     "case " ^ string_of_symbolic_string s ^ " in " ^ 
       concat " " (List.map string_of_case cs) ^ " esac"
  | CaseCheckMatch s exp c cs -> 
     "case " ^ string_of_symbolic_string s ^ " in " ^ 
       string_of_expansion_state exp ^ ") " ^ string_of_stmt c ^ ";; " ^
       concat " " (List.map string_of_case cs) ^ " esac"
  | Defun name cmd -> name ^ "() {\n" ^ string_of_stmt cmd ^ "\n}"
  | Call _loopnest _argv _f _body c -> string_of_stmt c (* TODO leaving stuff out *)
  | Break n -> "break " ^ show n
  | Continue n -> "continue " ^ show n
  | Return -> "return"
  | Exit -> "exit"
  | Exec cmd args _env -> spaced "exec" (string_of_fields (cmd::args))
  | Wait n _steps -> "wait " ^ stringFromNat n
  | Pushredir s _saved -> string_of_stmt s (* TODO leaving stuff out *)
  | Done -> "Done"
  end

and string_of_while c body =
  match c with
  | Not c' -> "until " ^ string_of_stmt c' ^ "; do " ^ string_of_stmt body ^ "; done "
  | _ ->  "while " ^ string_of_stmt c ^ "; do " ^ string_of_stmt body ^ "; done "
  end

and string_of_if c t e =
  "if " ^ string_of_stmt c ^
  "; then " ^ string_of_stmt t ^
  (match e with
   | Command [] [] [] -> "; fi" (* one-armed if *)
   | If c t e -> "; el" ^ string_of_if c t e
   | _ -> "; else " ^ string_of_stmt e ^ "; fi"
   end)

and string_of_case (w,c) =
  concat "|" (List.map string_of_words w) ^ ") " ^ string_of_stmt c ^ ";;"

and string_of_rfile ty fd =
  match ty with
  | To      -> show_unless 1 fd ^ ">"
  | Clobber -> show_unless 1 fd ^ ">|"
  | From    -> show_unless 0 fd ^ "<"
  | FromTo  -> show_unless 0 fd ^ "<>"
  | Append  -> show_unless 1 fd ^ ">>"
  end

and string_of_rdup ty fd =
  match ty with
  | ToFD -> show_unless 1 fd ^ ">&"
  | FromFD -> show_unless 0 fd ^ "<&"
  end

and string_of_heredoc ty fd heredoc =
  (* TODO 2018-09-04 use sound marker *)
  let marker = "EOF" in
  show_unless 0 fd ^ "<<" ^
  (if ty = XHere then marker else "'" ^ marker ^ "'") ^ "\n" ^ heredoc ^ marker ^ "\n"

and string_of_redir r = 
  match r with
  | RFile ty fd a    -> string_of_rfile ty fd ^ string_of_words a
  | RDup ty fd tgt   -> 
     string_of_rdup ty fd ^ 
       match tgt with
       | Nothing -> "-"
       | Just fd_tgt -> stringFromNat fd_tgt
       end
  | RHeredoc ty fd a -> string_of_heredoc ty fd (string_of_words a)
  end 

and string_of_expanding_redir exp_redir =
  match exp_redir with
  | Nothing -> ""
  | Just (XRFile ty fd exp_state) -> 
     string_of_rfile ty fd ^ string_of_expansion_state exp_state
  | Just (XRHeredoc ty fd exp_state) ->
     string_of_heredoc ty fd (string_of_expansion_state exp_state)
  end

and string_of_expanded_redir er =
  match er with
  | ERFile ty fd a   ->  string_of_rfile ty fd ^ string_of_fields a
  | ERDup ty _close_orig fd tgt  -> 
     string_of_rdup ty fd ^ 
       match tgt with
       | Nothing -> "-"
       | Just fd_tgt -> stringFromNat fd_tgt
       end
  | ERHeredoc ty fd a -> string_of_heredoc ty fd (string_of_fields a)
  end 

and string_of_expanded_redirs ers =
  concat " " (List.map string_of_expanded_redir ers)
and string_of_redirs rs = 
  concat " " (List.map string_of_redir rs)

and string_of_redir_state (ers, exp_redir, rs) =
  let s_ers = string_of_expanded_redirs ers in
  let s_exp_redir = string_of_expanding_redir exp_redir in
  let s_rs = string_of_redirs rs in
  spaced_many [s_ers; s_exp_redir; s_rs]

and string_of_tmp_field tf =
  match tf with
  | WFS -> " "
  | FS -> " "
  | Field s -> string_of_symbolic_string s
  | QField s -> "\"" ^ string_of_symbolic_string s ^ "\""
  end

and string_of_intermediate_fields ifs =
  match ifs with
  | [] -> ""
  | tf::ifs' -> string_of_tmp_field tf ^ string_of_intermediate_fields ifs'
  end

and string_of_expanded_words ew = 
  match ew with
  | [] -> ""
  | UsrF::ws -> " " ^ string_of_expanded_words ws
  | ExpS s::ws -> s ^ string_of_expanded_words ws
  | DQuo ss::ws -> 
    (* we don't include the quotes, since they'll be ultimately erased anyway! *)
     "\"" ^ string_of_symbolic_string ss ^ "\"" ^ string_of_expanded_words ws
  | At fs::ws -> 
     (* we collapse the result of $@ expansion, too. special cased in expand_control *)
     string_of_fields fs ^ string_of_expanded_words ws
  | EWSym sym::ws -> string_of_symbolic sym ^ string_of_expanded_words ws
  | UsrS s::ws -> s ^ string_of_expanded_words ws
  end

and string_of_words w = List.foldr (^) "" (List.map string_of_entry w)
and string_of_entry e =
  match e with
  | S str -> str
  | ESym _ -> "<<SYMBOLIC>>" (* TODO "R(" ^ string_of_symbolic_string c ^ ")" *)
  | K code -> string_of_control code
  | F -> " "
  end

and string_of_control code =
  match code with
  | Tilde -> "~"
  | TildeUser user -> "~" ^ user
  | Param var Normal -> "$" ^ var
  | Param var Length -> "${#" ^ var ^ "}"
  | Param var fmt -> "${" ^ var ^ string_of_format fmt ^ "}"
  | LAssign var ew w -> 
     "${" ^ var ^ "=" ^ string_of_expanded_words ew ^ string_of_words w ^ "}"
  | LMatch f _side _mode _ew _w -> string_of_fields f (* TODO leaving stuff out *)
  | LError var ew w ->
     "${" ^ var ^ "?" ^ string_of_expanded_words ew ^ string_of_words w ^ "}"
  | Backtick c -> 
     "$( " ^ string_of_stmt c ^ " )" (* spaces to prevent arith parsing issues *)
  | LBacktick c _pid _fd -> "$( " ^ string_of_stmt c ^ " )"
  | Arith ew w -> "$(( " ^ string_of_expanded_words ew ^ string_of_words w ^ " ))"
  | Quote ew w -> "\"" ^ string_of_expanded_words ew ^ string_of_words w ^ "\""
  end

and string_of_format fmt = 
  match fmt with
  | Normal -> "" (* but is special case *)
  | Length -> "#" (* but is special case *)
  | Default w -> "-" ^ string_of_words w
  | NDefault w-> ":-" ^ string_of_words w
  | Assign w -> "=" ^ string_of_words w
  | NAssign w -> ":=" ^ string_of_words w
  | Error w -> "?" ^ string_of_words w
  | NError w -> ":?" ^ string_of_words w
  | Alt w -> "+" ^ string_of_words w
  | NAlt w -> ":+" ^ string_of_words w
  | Substring side mode w -> string_of_substring side mode ^ string_of_words w
  end

and string_of_substring side mode =
  match side with
  | Prefix -> if mode = Longest then "##" else "#"
  | Suffix -> if mode = Longest then "%%" else "%"
  end

and string_of_expansion_state exp_state =
  match exp_state with
  | ExpStart w -> string_of_words w
  | ExpExpand _tm ew w -> string_of_expanded_words ew ^ string_of_words w
  | ExpSplit ew -> string_of_expanded_words ew
  | ExpPath ifs -> string_of_intermediate_fields ifs
  | ExpQuote ifs -> string_of_intermediate_fields ifs
  | ExpError f -> string_of_fields f
  | ExpDone f -> string_of_fields f
  end

and string_of_expansion_step estep =
  match estep with
  | ESTilde s -> "Tilde " ^ s
  | ESParam s -> "Param " ^ s
  | ESCommand s -> "Command " ^ s
  | ESArith s -> "Arith " ^ s
  | ESSplit s -> "Split " ^ s
  | ESPath s -> "Path " ^ s
  | ESQuote s -> "Quote " ^ s
  | ESStep s -> "Step " ^ s
  | ESNested estep_outer estep_inner ->
     parens (string_of_expansion_step estep_outer) ^ " " ^
     parens (string_of_expansion_step estep_inner)
  | ESEval estep' step ->
     parens (string_of_expansion_step estep') ^ " " ^
     parens (string_of_evaluation_step step)
  end

and string_of_evaluation_step step =
  match step with
  | XSSimple s -> "Simple " ^ s
  | XSPipe s -> "Pipe " ^ s
  | XSRedir s -> "Redir " ^ s
  | XSBackground s -> "Background " ^ s
  | XSSubshell s -> "Subshell " ^ s
  | XSAnd s -> "And " ^ s
  | XSOr s -> "Or " ^ s
  | XSNot s -> "Not " ^ s
  | XSSemi s -> "Semi " ^ s
  | XSIf s -> "If " ^ s
  | XSWhile s -> "While " ^ s
  | XSFor s -> "For " ^ s
  | XSCase s -> "Case " ^ s
  | XSDefun s -> "Defun " ^ s
  | XSStack s step' -> "Stack " ^ s ^ parens (string_of_evaluation_step step')
  | XSStep s -> "Step " ^ s
  | XSExec s -> "Exec " ^ s
  | XSWait s -> "Wait " ^ s
  | XSProc _pid c -> "Proc " ^ string_of_stmt c
  | XSNested step_outer step_inner -> 
     parens (string_of_evaluation_step step_outer) ^ " " ^ 
     parens (string_of_evaluation_step step_inner)
  | XSExpand step' estep ->
     parens (string_of_evaluation_step step') ^ " " ^ 
     parens (string_of_expansion_step estep)
  end

(**********************************************************************)
(* DEFAULT SHELL STATE ************************************************)
(**********************************************************************)

let env_default : env = Map.insert "?" (symbolic_string_of_string "0") Map.empty

let default_shell_state = <|
      opts = Set.empty;
      traps = Map.empty;
      jobs = [];
      positional_params = []; (* $0, $1, $2, $3 ... *)
      env = env_default;
      readonly = Set.empty;
      export = Set.empty;
      funcs = Map.empty;
      aliases = Map.empty;
      cwd = "/";
      locale = lc_ambient;
      loop_nest = 0
  |>

