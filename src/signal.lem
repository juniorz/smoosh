open import Pervasives

(* signal numbers for the local platform are generated by mk_signal_platform.sh *)

(* use OCaml's uppercasing just to be safe/complete *)
val uppercase_char : char -> char
declare ocaml target_rep function uppercase_char = `Char.uppercase_ascii` 

(* dropping XSI/XSR signals *)
type signal = 
  | EXIT    (* shell only, for trap *)
  | SIGABRT
  | SIGALRM
  | SIGBUS
  | SIGCHLD
  | SIGCONT
  | SIGFPE
  | SIGHUP
  | SIGILL
  | SIGINT
  | SIGKILL
  | SIGPIPE
  | SIGQUIT
  | SIGSEGV
  | SIGSTOP
  | SIGTERM
  | SIGTSTP
  | SIGTTIN
  | SIGTTOU
  | SIGUSR1
  | SIGUSR2
  | SIGTRAP
  | SIGURG
  | SIGXCPU
  | SIGXFSZ

let all_signals =
  [ EXIT
  ; SIGABRT
  ; SIGALRM
  ; SIGBUS
  ; SIGCHLD
  ; SIGCONT
  ; SIGFPE
  ; SIGHUP
  ; SIGILL
  ; SIGINT
  ; SIGKILL
  ; SIGPIPE
  ; SIGQUIT
  ; SIGSEGV
  ; SIGSTOP
  ; SIGTERM
  ; SIGTSTP
  ; SIGTTIN
  ; SIGTTOU
  ; SIGUSR1
  ; SIGUSR2
  ; SIGTRAP
  ; SIGURG
  ; SIGXCPU
  ; SIGXFSZ]

let undefined_traps =
  [ SIGKILL
  ; SIGSTOP]

val string_of_signal : signal -> string
let string_of_signal signal =
  match signal with
  | EXIT      -> "EXIT"
  | SIGABRT   -> "ABRT"
  | SIGALRM   -> "ALRM"
  | SIGBUS    -> "BUS"
  | SIGCHLD   -> "CHLD"
  | SIGCONT   -> "CONT"
  | SIGFPE    -> "FPE"
  | SIGHUP    -> "HUP"
  | SIGILL    -> "ILL"
  | SIGINT    -> "INT"
  | SIGKILL   -> "KILL"
  | SIGPIPE   -> "PIPE"
  | SIGQUIT   -> "QUIT"
  | SIGSEGV   -> "SEGV"
  | SIGSTOP   -> "STOP"
  | SIGTERM   -> "TERM"
  | SIGTSTP   -> "TSTP"
  | SIGTTIN   -> "TTIN"
  | SIGTTOU   -> "TTOU"
  | SIGUSR1   -> "USR1"
  | SIGUSR2   -> "USR2"
  | SIGTRAP   -> "TRAP"
  | SIGURG    -> "URG"
  | SIGXCPU   -> "XCPU"
  | SIGXFSZ   -> "XFSZ"
  end

val signal_of_string : string -> maybe signal
let signal_of_string s =
  (* convert to uppercase, remove SIG prefix *)
  let s' = 
    match List.map uppercase_char (toCharList s) with
    | #'S'::#'I'::#'G'::signal -> toString signal
    | s' -> toString s'
    end 
  in
  match s' with
  | "EXIT" -> Just EXIT
  | "ABRT" -> Just SIGABRT
  | "ALRM" -> Just SIGALRM
  | "BUS"  -> Just SIGBUS
  | "CHLD" -> Just SIGCHLD
  | "CONT" -> Just SIGCONT
  | "FPE"  -> Just SIGFPE
  | "HUP"  -> Just SIGHUP
  | "ILL"  -> Just SIGILL
  | "INT"  -> Just SIGINT
  | "KILL" -> Just SIGKILL
  | "PIPE" -> Just SIGPIPE
  | "QUIT" -> Just SIGQUIT
  | "SEGV" -> Just SIGSEGV
  | "STOP" -> Just SIGSTOP
  | "TERM" -> Just SIGTERM
  | "TSTP" -> Just SIGTSTP
  | "TTIN" -> Just SIGTTIN
  | "TTOU" -> Just SIGTTOU
  | "USR1" -> Just SIGUSR1
  | "USR2" -> Just SIGUSR2
  | "TRAP" -> Just SIGTRAP
  | "URG"  -> Just SIGURG
  | "XCPU" -> Just SIGXCPU
  | "XFSZ" -> Just SIGXFSZ
  | _ -> Nothing
  end

val ocaml_sigabrt   : int
declare ocaml target_rep function ocaml_sigabrt = `Sys.sigabrt`
val ocaml_sigalrm   : int
declare ocaml target_rep function ocaml_sigalrm = `Sys.sigalrm`
val ocaml_sigbus    : int
declare ocaml target_rep function ocaml_sigbus = `Sys.sigbus`
val ocaml_sigchld   : int
declare ocaml target_rep function ocaml_sigchld = `Sys.sigchld`
val ocaml_sigcont   : int
declare ocaml target_rep function ocaml_sigcont = `Sys.sigcont`
val ocaml_sigfpe    : int
declare ocaml target_rep function ocaml_sigfpe = `Sys.sigfpe`
val ocaml_sighup    : int
declare ocaml target_rep function ocaml_sighup = `Sys.sighup`
val ocaml_sigill    : int
declare ocaml target_rep function ocaml_sigill = `Sys.sigill`
val ocaml_sigint    : int
declare ocaml target_rep function ocaml_sigint = `Sys.sigint`
val ocaml_sigkill   : int
declare ocaml target_rep function ocaml_sigkill = `Sys.sigkill`
val ocaml_sigpipe   : int
declare ocaml target_rep function ocaml_sigpipe = `Sys.sigpipe`
val ocaml_sigquit   : int
declare ocaml target_rep function ocaml_sigquit = `Sys.sigquit`
val ocaml_sigsegv   : int
declare ocaml target_rep function ocaml_sigsegv = `Sys.sigsegv`
val ocaml_sigstop   : int
declare ocaml target_rep function ocaml_sigstop = `Sys.sigstop`
val ocaml_sigterm   : int
declare ocaml target_rep function ocaml_sigterm = `Sys.sigterm`
val ocaml_sigtstp   : int
declare ocaml target_rep function ocaml_sigtstp = `Sys.sigtstp`
val ocaml_sigttin   : int
declare ocaml target_rep function ocaml_sigttin = `Sys.sigttin`
val ocaml_sigttou   : int
declare ocaml target_rep function ocaml_sigttou = `Sys.sigttou`
val ocaml_sigusr1   : int
declare ocaml target_rep function ocaml_sigusr1 = `Sys.sigusr1`
val ocaml_sigusr2   : int
declare ocaml target_rep function ocaml_sigusr2 = `Sys.sigusr2`
val ocaml_sigtrap   : int
declare ocaml target_rep function ocaml_sigtrap = `Sys.sigtrap`
val ocaml_sigurg    : int
declare ocaml target_rep function ocaml_sigurg = `Sys.sigurg`
val ocaml_sigxcpu   : int
declare ocaml target_rep function ocaml_sigxcpu = `Sys.sigxcpu`
val ocaml_sigxfsz   : int
declare ocaml target_rep function ocaml_sigxfsz = `Sys.sigxfsz`

val ocaml_signal_of_signal : signal -> int
let ocaml_signal_of_signal signal =
  match signal with
  | EXIT      -> 0 (* unused by OCaml (which uses negative signal numbers) *)
  | SIGABRT   -> ocaml_sigabrt
  | SIGALRM   -> ocaml_sigalrm
  | SIGBUS    -> ocaml_sigbus
  | SIGCHLD   -> ocaml_sigchld
  | SIGCONT   -> ocaml_sigcont
  | SIGFPE    -> ocaml_sigfpe
  | SIGHUP    -> ocaml_sighup
  | SIGILL    -> ocaml_sigill
  | SIGINT    -> ocaml_sigint
  | SIGKILL   -> ocaml_sigkill
  | SIGPIPE   -> ocaml_sigpipe
  | SIGQUIT   -> ocaml_sigquit
  | SIGSEGV   -> ocaml_sigsegv
  | SIGSTOP   -> ocaml_sigstop
  | SIGTERM   -> ocaml_sigterm
  | SIGTSTP   -> ocaml_sigtstp
  | SIGTTIN   -> ocaml_sigttin
  | SIGTTOU   -> ocaml_sigttou
  | SIGUSR1   -> ocaml_sigusr1
  | SIGUSR2   -> ocaml_sigusr2
  | SIGTRAP   -> ocaml_sigtrap
  | SIGURG    -> ocaml_sigurg
  | SIGXCPU   -> ocaml_sigxcpu
  | SIGXFSZ   -> ocaml_sigxfsz
  end
