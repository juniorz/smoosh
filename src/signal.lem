open import Pervasives_extra

(* signal numbers for the local platform are generated by mk_signal_platform.sh *)

(* use OCaml's uppercasing just to be safe/complete *)
val uppercase_char : char -> char
declare ocaml target_rep function uppercase_char = `Char.uppercase_ascii` 

(* TODO 2018-10-22 missing XSI/XSR signals

   SIGPOLL
   SIGPROF
   SIGSYS
   SIGVTALRM
*)
type signal = 
  | EXIT    (* shell only, for trap *)
  | SIGABRT
  | SIGALRM
  | SIGBUS
  | SIGCHLD
  | SIGCONT
  | SIGFPE
  | SIGHUP
  | SIGILL
  | SIGINT
  | SIGKILL
  | SIGPIPE
  | SIGQUIT
  | SIGSEGV
  | SIGSTOP
  | SIGTERM
  | SIGTSTP
  | SIGTTIN
  | SIGTTOU
  | SIGUSR1
  | SIGUSR2
  | SIGTRAP
  | SIGURG
  | SIGXCPU
  | SIGXFSZ

let all_signals =
  [ EXIT
  ; SIGABRT
  ; SIGALRM
  ; SIGBUS
  ; SIGCHLD
  ; SIGCONT
  ; SIGFPE
  ; SIGHUP
  ; SIGILL
  ; SIGINT
  ; SIGKILL
  ; SIGPIPE
  ; SIGQUIT
  ; SIGSEGV
  ; SIGSTOP
  ; SIGTERM
  ; SIGTSTP
  ; SIGTTIN
  ; SIGTTOU
  ; SIGUSR1
  ; SIGUSR2
  ; SIGTRAP
  ; SIGURG
  ; SIGXCPU
  ; SIGXFSZ]

let undefined_traps =
  [ SIGKILL
  ; SIGSTOP]

let stopped_signals =
  [ SIGTSTP
  ; SIGSTOP
  ; SIGTTIN
  ; SIGTTOU
  ]

val string_of_signal : signal -> string
let string_of_signal signal =
  match signal with
  | EXIT      -> "EXIT"
  | SIGABRT   -> "ABRT"
  | SIGALRM   -> "ALRM"
  | SIGBUS    -> "BUS"
  | SIGCHLD   -> "CHLD"
  | SIGCONT   -> "CONT"
  | SIGFPE    -> "FPE"
  | SIGHUP    -> "HUP"
  | SIGILL    -> "ILL"
  | SIGINT    -> "INT"
  | SIGKILL   -> "KILL"
  | SIGPIPE   -> "PIPE"
  | SIGQUIT   -> "QUIT"
  | SIGSEGV   -> "SEGV"
  | SIGSTOP   -> "STOP"
  | SIGTERM   -> "TERM"
  | SIGTSTP   -> "TSTP"
  | SIGTTIN   -> "TTIN"
  | SIGTTOU   -> "TTOU"
  | SIGUSR1   -> "USR1"
  | SIGUSR2   -> "USR2"
  | SIGTRAP   -> "TRAP"
  | SIGURG    -> "URG"
  | SIGXCPU   -> "XCPU"
  | SIGXFSZ   -> "XFSZ"
  end

val signal_of_string : string -> maybe signal
let signal_of_string s =
  (* convert to uppercase, remove SIG prefix *)
  let s' = 
    match List.map uppercase_char (toCharList s) with
    | #'S'::#'I'::#'G'::signal -> toString signal
    | s' -> toString s'
    end 
  in
  match s' with
  | "EXIT" -> Just EXIT
  | "ABRT" -> Just SIGABRT
  | "ALRM" -> Just SIGALRM
  | "BUS"  -> Just SIGBUS
  | "CHLD" -> Just SIGCHLD
  | "CONT" -> Just SIGCONT
  | "FPE"  -> Just SIGFPE
  | "HUP"  -> Just SIGHUP
  | "ILL"  -> Just SIGILL
  | "INT"  -> Just SIGINT
  | "KILL" -> Just SIGKILL
  | "PIPE" -> Just SIGPIPE
  | "QUIT" -> Just SIGQUIT
  | "SEGV" -> Just SIGSEGV
  | "STOP" -> Just SIGSTOP
  | "TERM" -> Just SIGTERM
  | "TSTP" -> Just SIGTSTP
  | "TTIN" -> Just SIGTTIN
  | "TTOU" -> Just SIGTTOU
  | "USR1" -> Just SIGUSR1
  | "USR2" -> Just SIGUSR2
  | "TRAP" -> Just SIGTRAP
  | "URG"  -> Just SIGURG
  | "XCPU" -> Just SIGXCPU
  | "XFSZ" -> Just SIGXFSZ
  | _ -> Nothing
  end

val ocaml_sigabrt   : int
declare ocaml target_rep function ocaml_sigabrt = `Sys.sigabrt`
val ocaml_sigalrm   : int
declare ocaml target_rep function ocaml_sigalrm = `Sys.sigalrm`
val ocaml_sigbus    : int
declare ocaml target_rep function ocaml_sigbus = `Sys.sigbus`
val ocaml_sigchld   : int
declare ocaml target_rep function ocaml_sigchld = `Sys.sigchld`
val ocaml_sigcont   : int
declare ocaml target_rep function ocaml_sigcont = `Sys.sigcont`
val ocaml_sigfpe    : int
declare ocaml target_rep function ocaml_sigfpe = `Sys.sigfpe`
val ocaml_sighup    : int
declare ocaml target_rep function ocaml_sighup = `Sys.sighup`
val ocaml_sigill    : int
declare ocaml target_rep function ocaml_sigill = `Sys.sigill`
val ocaml_sigint    : int
declare ocaml target_rep function ocaml_sigint = `Sys.sigint`
val ocaml_sigkill   : int
declare ocaml target_rep function ocaml_sigkill = `Sys.sigkill`
val ocaml_sigpipe   : int
declare ocaml target_rep function ocaml_sigpipe = `Sys.sigpipe`
val ocaml_sigquit   : int
declare ocaml target_rep function ocaml_sigquit = `Sys.sigquit`
val ocaml_sigsegv   : int
declare ocaml target_rep function ocaml_sigsegv = `Sys.sigsegv`
val ocaml_sigstop   : int
declare ocaml target_rep function ocaml_sigstop = `Sys.sigstop`
val ocaml_sigterm   : int
declare ocaml target_rep function ocaml_sigterm = `Sys.sigterm`
val ocaml_sigtstp   : int
declare ocaml target_rep function ocaml_sigtstp = `Sys.sigtstp`
val ocaml_sigttin   : int
declare ocaml target_rep function ocaml_sigttin = `Sys.sigttin`
val ocaml_sigttou   : int
declare ocaml target_rep function ocaml_sigttou = `Sys.sigttou`
val ocaml_sigusr1   : int
declare ocaml target_rep function ocaml_sigusr1 = `Sys.sigusr1`
val ocaml_sigusr2   : int
declare ocaml target_rep function ocaml_sigusr2 = `Sys.sigusr2`
val ocaml_sigtrap   : int
declare ocaml target_rep function ocaml_sigtrap = `Sys.sigtrap`
val ocaml_sigurg    : int
declare ocaml target_rep function ocaml_sigurg = `Sys.sigurg`
val ocaml_sigxcpu   : int
declare ocaml target_rep function ocaml_sigxcpu = `Sys.sigxcpu`
val ocaml_sigxfsz   : int
declare ocaml target_rep function ocaml_sigxfsz = `Sys.sigxfsz`

val ocaml_signal_of_signal : signal -> maybe int
let ocaml_signal_of_signal signal =
  match signal with
  | EXIT      -> Just 0
  | SIGABRT   -> Just ocaml_sigabrt
  | SIGALRM   -> Just ocaml_sigalrm
  | SIGBUS    -> Just ocaml_sigbus
  | SIGCHLD   -> Just ocaml_sigchld
  | SIGCONT   -> Just ocaml_sigcont
  | SIGFPE    -> Just ocaml_sigfpe
  | SIGHUP    -> Just ocaml_sighup
  | SIGILL    -> Just ocaml_sigill
  | SIGINT    -> Just ocaml_sigint
  | SIGKILL   -> Just ocaml_sigkill
  | SIGPIPE   -> Just ocaml_sigpipe
  | SIGQUIT   -> Just ocaml_sigquit
  | SIGSEGV   -> Just ocaml_sigsegv
  | SIGSTOP   -> Just ocaml_sigstop
  | SIGTERM   -> Just ocaml_sigterm
  | SIGTSTP   -> Just ocaml_sigtstp
  | SIGTTIN   -> Just ocaml_sigttin
  | SIGTTOU   -> Just ocaml_sigttou
  | SIGUSR1   -> Just ocaml_sigusr1
  | SIGUSR2   -> Just ocaml_sigusr2
  | SIGTRAP   -> Just ocaml_sigtrap
  | SIGURG    -> Just ocaml_sigurg
  | SIGXCPU   -> Just ocaml_sigxcpu
  | SIGXFSZ   -> Just ocaml_sigxfsz
  end

val signal_of_ocaml_signal : int -> signal
let signal_of_ocaml_signal ocaml_signal =
  if      ocaml_signal = ocaml_sigabrt
  then SIGABRT
  else if ocaml_signal = ocaml_sigalrm
  then SIGALRM
  else if ocaml_signal = ocaml_sigbus
  then SIGBUS
  else if ocaml_signal = ocaml_sigchld
  then SIGCHLD
  else if ocaml_signal = ocaml_sigcont
  then SIGCONT
  else if ocaml_signal = ocaml_sigfpe
  then SIGFPE
  else if ocaml_signal = ocaml_sighup
  then SIGHUP
  else if ocaml_signal = ocaml_sigill
  then SIGILL
  else if ocaml_signal = ocaml_sigint
  then SIGINT
  else if ocaml_signal = ocaml_sigkill
  then SIGKILL
  else if ocaml_signal = ocaml_sigpipe
  then SIGPIPE
  else if ocaml_signal = ocaml_sigquit
  then SIGQUIT
  else if ocaml_signal = ocaml_sigsegv
  then SIGSEGV
  else if ocaml_signal = ocaml_sigstop
  then SIGSTOP
  else if ocaml_signal = ocaml_sigterm
  then SIGTERM
  else if ocaml_signal = ocaml_sigtstp
  then SIGTSTP
  else if ocaml_signal = ocaml_sigttin
  then SIGTTIN
  else if ocaml_signal = ocaml_sigttou
  then SIGTTOU
  else if ocaml_signal = ocaml_sigusr1
  then SIGUSR1
  else if ocaml_signal = ocaml_sigusr2
  then SIGUSR2
  else if ocaml_signal = ocaml_sigtrap
  then SIGTRAP
  else if ocaml_signal = ocaml_sigurg
  then SIGURG
  else if ocaml_signal = ocaml_sigxcpu
  then SIGXCPU
  else if ocaml_signal = ocaml_sigxfsz
  then SIGXFSZ
  else Assert_extra.failwith ("unknown OCaml signal " ^ stringFromInt ocaml_signal)

(* from http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html *)
type signal_behavior = 
    SigBeh_Terminate of bool (* additional actions? false = T, true = A *)
  | SigBeh_Ignore            (* I *)
  | SigBeh_Stop              (* S *)
  | SigBeh_Continue          (* C *)

val signal_default_behavior : signal -> signal_behavior
let signal_default_behavior signal =
  let T = SigBeh_Terminate false in
  let A = SigBeh_Terminate true in
  let I = SigBeh_Ignore in
  let S = SigBeh_Stop in
  let C = SigBeh_Continue in
  match signal with
  | EXIT      -> I (* not really a signal, but okay *)
  | SIGABRT   -> A
  | SIGALRM   -> T
  | SIGBUS    -> A
  | SIGCHLD   -> I
  | SIGCONT   -> C
  | SIGFPE    -> A
  | SIGHUP    -> T
  | SIGILL    -> A
  | SIGINT    -> T
  | SIGKILL   -> T
  | SIGPIPE   -> T
  | SIGQUIT   -> A
  | SIGSEGV   -> A
  | SIGSTOP   -> S
  | SIGTERM   -> T
  | SIGTSTP   -> S
  | SIGTTIN   -> S
  | SIGTTOU   -> S
  | SIGUSR1   -> T
  | SIGUSR2   -> T
  | SIGTRAP   -> A
  | SIGURG    -> I 
  | SIGXCPU   -> A
  | SIGXFSZ   -> A
  end
