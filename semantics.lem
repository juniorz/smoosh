open import Fsh

open import Arith
open import Pattern
open import Path

(**********************************************************************)   
(* SHARED DECLARATIONS FOR EXPANSION AND EVALUATION *******************)   
(**********************************************************************)   

type string_mode =
    UserString
  | GeneratedString

type quoting_mode =
    Unquoted
  | Quoted

val expand_control : ty_os_state -> quoting_mode -> control ->
                     either (expansion_step * ty_os_state * expanded_words) 
                            (expansion_step * ty_os_state * expanded_words * words)
val expand_words : ty_os_state -> quoting_mode -> string_mode -> (expanded_words * words) ->
                   either (expansion_step * ty_os_state * expanded_words) 
                          (expansion_step * ty_os_state * expanded_words * words)
val step_expansion : ty_os_state * expansion_state -> 
                     ty_os_state * expansion_state * expansion_step
val step_assign : ty_os_state -> list (string * expansion_state) ->
                  either (ty_os_state * list (string * fields)) (* Done state *)
                         (ty_os_state * list (string * expansion_state) * evaluation_step) (* In progress *)

val run_command : ty_os_state -> 
                  symbolic_string (* prog *) -> 
                  fields (* argv *) ->
                  env ->
                  fds ->
                  either (ty_os_state * string) (ty_os_state * stmt)
val step_eval : ty_os_state -> stmt -> 
                either (ty_os_state * evaluation_step) (* error case *)
                       (ty_os_state * stmt * evaluation_step) (* success *)

val exit_with : nat -> ty_os_state -> ty_os_state
let exit_with ec os = set_param "?" (symbolic_string_of_string (stringFromNat ec)) os

val last_pid : nat -> ty_os_state -> ty_os_state
let last_pid pid os = set_param "!" (symbolic_string_of_string (stringFromNat pid)) os

val is_special_builtin : string -> bool
let is_special_builtin s =
  match s with
  | "break" -> true
  | ":" -> true
  | "continue" -> true
  | "." -> true
  | "eval" -> true
  | "exec" -> true
  | "exit" -> true
  | "export" -> true
  | "readonly" -> true
  | "return" -> true
  | "set" -> true
  | "shift" -> true
  | "times" -> true
  | "trap" -> true
  | "unset" -> true
  | _ -> false
  end

val is_unspecified_utility : string -> bool
let is_unspecified_utility s =
  match s with
  | "alloc" -> true
  | "autoload" -> true
  | "bind" -> true
  | "bindkey" -> true
  | "builtin" -> true
  | "bye" -> true
  | "caller" -> true
  | "cap" -> true
  | "chdir" -> true
  | "clone" -> true
  | "comparguments" -> true
  | "compcall" -> true
  | "compctl" -> true
  | "compdescribe" -> true
  | "compfiles" -> true
  | "compgen" -> true
  | "compgroups" -> true
  | "complete" -> true
  | "compquote" -> true
  | "comptags" -> true
  | "comptry" -> true
  | "compvalues" -> true
  | "declare" -> true
  | "dirs" -> true
  | "disable" -> true
  | "disown" -> true
  | "dosh" -> true
  | "echotc" -> true
  | "echoti" -> true
  | "help" -> true
  | "history" -> true
  | "hist" -> true
  | "let" -> true
  | "local" -> true
  | "login" -> true
  | "logout" -> true
  | "map" -> true
  | "mapfile" -> true
  | "popd" -> true
  | "print" -> true
  | "pushd" -> true
  | "readarray" -> true
  | "repeat" -> true
  | "savehistory" -> true
  | "source" -> true
  | "shopt" -> true
  | "stop" -> true
  | "suspend" -> true
  | "typeset" -> true
  | "whence" -> true
  | _ -> false
  end

(**********************************************************************)   
(* LATE STAGE EXPANSION ***********************************************)   
(**********************************************************************)
(* These functions are kept out of the recursive knot of
   expansion/evaluation, just to keep the file simple. Unfortunately,
   that means they show up first, out of logical order. Sorry! *)
   
(*
 * Stage 2 Expansion: Field Splitting
 *)

val is_ws : char -> bool
val collect_non_ifs : list char -> list char -> (list char) * (list char)
(*val collect_ifs_whitespace : list char -> list char -> list char*)
val split_expstring : list char -> list char -> intermediate_fields
val split_word : list char -> (intermediate_fields * expanded_words) -> (intermediate_fields * expanded_words)
val split_fields : ty_os_state -> expanded_words -> intermediate_fields
val clean_fields : intermediate_fields -> intermediate_fields
val field_splitting: ty_os_state -> expanded_words -> intermediate_fields

let is_ws c = elem c (toCharList " \n\t")

let rec collect_non_ifs ifs ls =
  match ls with
  | [] -> ([], [])
  | (c::cs) ->
      if elem c ifs
      then ([], c::cs)
      else let (f, remaining) = collect_non_ifs ifs cs in
           (c::f, remaining)
  end

let rec split_expstring ifs clst =
   match clst with
   | [] -> []
   | c::cs ->
       if elem c ifs
       then let fs = if is_ws c then WFS else FS 
            in fs::split_expstring ifs cs
       else let (cc, cs1) = collect_non_ifs ifs cs in 
            (Field (symbolic_string_of_char_list (c::cc)))::(split_expstring ifs cs1)
  end

let rec split_word ifs p =
  match p with
  | (f, []) -> (f, [])
  | (f, UsrF::wrds) -> split_word ifs (f ++ [FS], wrds)
  | (f, ExpS(s)::wrds) ->
      let new_fields = split_expstring ifs (toCharList s) in
      split_word ifs (f ++ new_fields, wrds)
  | (f, UsrS(s)::wrds) -> split_word ifs (f ++ [Field (symbolic_string_of_string s)], wrds)
  | (f, DQuo(s)::wrds) -> split_word ifs (f ++ [QField (symbolic_string_of_string s)], wrds)
  | (f, EWSym sym::wrds) -> split_word ifs (f ++ [Field [Sym sym]], wrds)
  end

let split_fields s0 exp_words =
  let ifs = lookup_param s0 "IFS" in
  let (f, _) = match ifs with
    | Nothing -> split_word (toCharList " \n\t") ([], exp_words)
    | Just fs -> 
       match try_concrete fs with
       | Nothing -> (* TODO symbolic, a symbolic IFS makes it nearly-impossible to model field splitting *)
          split_word (toCharList " \n\t") ([], exp_words)
       | Just "" -> ([Field (concat_expanded exp_words)], [])
       | Just s -> split_word (toCharList s) ([], exp_words)
       end
  end in f

let rec combine_fields f =
  match f with
  | [] -> []
  | [WFS] -> [] (* Remove trailing field separators *)
  | (WFS::WFS::rst) -> combine_fields (WFS::rst) (* Combine adjacent whitespace separators *)
  | (WFS::FS::rst) -> combine_fields (FS::rst)
  | (FS::WFS::rst) -> combine_fields (FS::rst)
  | (Field(s1)::Field(s2)::rst) -> combine_fields (Field(s1 ++ s2)::rst)
  | (WFS::rst) -> FS::(combine_fields rst)
  | (f::rst) -> f::(combine_fields rst)
  end

let rec clean_fields f =
  match f with
  | (WFS::rst) -> clean_fields rst
  | _ -> combine_fields f
  end

let field_splitting s0 w = clean_fields (split_fields s0 w)

(*
 * Stage 3 Expansion: Pathname expansion
 *)

val insert_field_separators : list string -> intermediate_fields
let rec insert_field_separators fs =
  match fs with
  | [] -> []
  | [f] -> [Field (symbolic_string_of_string f)]
  | f::fs' -> Field (symbolic_string_of_string f)::FS::insert_field_separators fs'
  end
    
val pathname_expansion : ty_os_state -> intermediate_fields -> intermediate_fields

(* Parameter expansion only happens on unquoted fields *)
let rec pathname_expansion s0 f =
  match f with
  | [] -> []
  | (Field(s)::rst) -> 
     let matches = 
       match try_concrete s with
       | Just pat -> match_path s0 pat
       | Nothing -> [] (* slightly inaccurate: we're not modeling symbolic pathname expansions *)
       end 
     in
     let expansions = 
       if null matches 
       then [Field s] 
       else insert_field_separators matches 
     in
     expansions ++ pathname_expansion s0 rst
  | (f::rst) -> f::(pathname_expansion s0 rst)
  end

(*
 * Stage 4 Expansion: Quote Removal
 *)

val remove_quotes : intermediate_fields -> intermediate_fields
val to_fields : intermediate_fields -> fields
val finalize_fields : intermediate_fields -> fields
val quote_removal : ty_os_state -> intermediate_fields -> fields

let rec remove_quotes f =
  match f with
  | [] -> []
  | (QField(s)::rst) -> Field(s)::(remove_quotes rst)
  | (f::rst) -> f::(remove_quotes rst)
  end

let rec to_fields f =
  match f with
  | []           -> []
  | FS::FS::rst  -> (symbolic_string_of_string "")::(to_fields rst)
  | Field fs::rst -> 
     fs::(to_fields rst)
  | FS::rst      -> to_fields rst
  (* TODO 2017-12-01 Preferably we need an AST that doesn't have WFS or QField's at this point, or lem failure *)
  | WFS::_       -> [symbolic_string_of_string "broken invariant"]
  | QField _::_  -> [symbolic_string_of_string "broken invariant"]
  end

let rec finalize_fields f =
  match f with
  | (FS::rst) -> symbolic_string_of_string ""::finalize_fields rst
  | _ -> to_fields f
  end

let quote_removal _s0 f =
  let no_quotes = combine_fields (remove_quotes f) in
  finalize_fields no_quotes

(**********************************************************************)   
(* EXPANSION **********************************************************)   
(**********************************************************************)   
   
(*
 * Stage 1 Expansion: Word expansion
 *)

val expand_param : ty_os_state -> quoting_mode -> string -> format -> words
(* Runs expansion all the way, for testing purposes only *)
val control_code_expansion : ty_os_state -> quoting_mode -> words -> (ty_os_state * expanded_words)

let match_substring (lc:locale) (side:substring_side) (mode:substring_mode) (pat:expanded_words) (str:fields) : symbolic_string =
  let sympat : symbolic_string = (concat_expanded pat) in
  let symstr : symbolic_string = symbolic_string_of_fields str in
  try_match_prefix lc side mode sympat symstr

(* TODO 2017-12-01
 * In an N____ case, when null_string fs is Nothing, the
 * string is entirely symbolic so we need
 * to represent the symbolic result of "it could be either
 * true or false, we don't know". This means we need to branch
 * and allow for both cases to progress.
 *)
let expand_param s0 _q str f =
  let value = lookup_param s0 str in
  match (value, f) with
  (* NORMAL *)
  | (Nothing, Normal)     -> [S ""] (* null *)
  | (Just fs, Normal)     -> words_of_symbolic_string fs
  (* DEFAULT *)
  | (Nothing, Default w)  -> w
  | (Just fs, Default _)  -> words_of_symbolic_string fs
  | (Nothing, NDefault w) -> w
  | (Just fs, NDefault w) ->
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> w
     | Just false -> words_of_symbolic_string fs
     end
  (* ASSIGN *)
  | (Nothing, Assign w)  -> [K (LAssign str [] w)]
  | (Just fs, Assign _)  -> words_of_symbolic_string fs       
  | (Nothing, NAssign w) -> [K (LAssign str [] w)]
  | (Just fs, NAssign w) -> 
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> [K (LAssign str [] w)]
     | Just false -> words_of_symbolic_string fs
     end
  (* ERROR *)
  | (Nothing, Error w)  -> [K (LError str [] w)]
  | (Just fs, Error _)  -> words_of_symbolic_string fs
  | (Nothing, NError w) -> [K (LError str [] w)]
  | (Just fs, NError w) -> 
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> [K (LError str [] w)]
     | Just false -> words_of_symbolic_string fs
     end
  (* LENGTH *)
  | (Nothing, Length) -> [S "0"]
  | (Just fs, Length) ->
     match try_concrete fs with
     | Nothing -> (* TODO This should be the length of the symbolic result of fs *) [S "0"]
     | Just strs -> [S (show (stringLength strs))]
     end
  (* ALT *)
  | (Nothing, Alt _)  -> [S ""]
  | (Just _, Alt w)  -> w
  | (Nothing, NAlt _) -> [S ""]
  | (Just fs, NAlt w) ->
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> [S ""]
     | Just false -> w
     end
  (* SUBTRINGS (prefix/suffix) *)
  | (Nothing, Substring _ _ _) -> [S ""]
  | (Just fs, Substring s m w) -> [K (LMatch [fs] s m [] w)]
  end

(* TODO 2017-12-22 refactor to have step info last *)
let rec expand_control s0 q k =
    match k with
    | Tilde ->
       let (msg, dir) = match expand_param s0 Unquoted "HOME" Normal with
         (* if HOME is unset, results are unspecified---we return "~" 
            dash:
              $ unset HOME
              $ echo ~
              ~
              $ HOME=""
              $ echo ~
              ~
              $ HOME="/Users/mgree"
              $ echo ~
              /Users/mgree

            bash:
              $ unset HOME
              $ echo ~
              /Users/mgree
              $ HOME=""
              $ echo ~
              
              $ HOME="/Users/mgree"
              $ echo ~
              /Users/mgree            

            lol
          *)
         | [S ""] -> ("defaulting to dash behavior for unset HOME (unspec per 2.6.1)", [S "~"])
         | dir -> ("", dir)
         end in
       Right (ESTilde msg, s0, [], dir)
    | TildeUser usr -> 
       match get_pwdir s0 usr with
       | Nothing -> Right (ESTilde "defaulting to dash behavior for failed getpwnam (unspec per 2.6.1)", s0, [], [S ("~" ^ usr)]) (* unspec per 2.6.1, but we follow dash *)
       | Just path -> Right (ESTilde "", s0, [], [S path])
       end
    | Param s f -> expand_words s0 q GeneratedString ([], expand_param s0 q s f)
    | LAssign s f [] ->
        let s1 = set_param s (concat_expanded f) s0 in
        Right (ESParam "finished assignment", s1, f, [])
    | LAssign s f w ->
       match expand_words s0 q GeneratedString ([], w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESParam "assignment") step, s1, [], [K (LAssign s (f ++ f1) w1)])
       | Left err -> Left err
       end
    | LMatch str side mode f [] -> Right (ESParam "finished match", s0, [], words_of_symbolic_string (match_substring s0.sh.locale side mode f str))
    | LMatch s side mode f w ->
       match expand_words s0 q GeneratedString ([], w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESParam "match") step, s1, [], [K (LMatch s side mode (f ++ f1) w1)])
       | Left err -> Left err
       end
    | LError str f [] -> Left (ESParam "raising requested error", s0, ExpS (str ^ ": ")::f) (* dash seems to print erroring variable name; TODO should we also have linno? *)
    | LError str f w ->
       match expand_words s0 q GeneratedString ([], w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESParam "error") step, s1, [], [K (LError str (f ++ f1) w1)])
       | Left err -> Left err
       end
    | Backtick c ->
       Right (ESCommand "initializing subshell", s0, [], [K (LBacktick s0.sh c c)]) (* TODO should set up pipes *)
    | LBacktick subsh corig c0 ->
       match step_eval <| s0 with sh = subsh |> c0 with
       (* When a subshell errors, it should evaluate to the null string and print its error message. *)
       | Left (s1, step) -> Right (ESEval (ESCommand "command exited with error") step, <| s1 with sh = s0.sh |>, [], [])
       (* The shell shall expand the command substitution by executing
          command in a subshell environment (see Shell Execution
          Environment) and replacing the command substitution (the text
          of command plus the enclosing "$()" or backquotes) with the
          standard output of the command, removing sequences of one or
          more <newline>s at the end of the substitution POSIX 2.6.3 
 
          TODO 2017-12-22 read result from pipe, trim newlines
        *) 
       | Right (s1, Done, step) -> Right (ESEval (ESCommand "command exited successfully; returning symbolic result") step, <| s1 with sh = s0.sh |>, [EWSym (SymCommand corig)], [])
       | Right (s1, c1, step) -> Right (ESEval (ESCommand "") step, <| s1 with sh = s0.sh |>, [], [K (LBacktick s1.sh corig c1)])
       end
    | Arith f [] ->
        match arith64 s0 (concat_expanded f) with
        | Right (s1, result) -> Right (ESArith "computed arithmetic result", s1, expanded_words_of_fields result, [])
        | Left e -> Left (ESArith "arithmetic error", s0, [ExpS e])
        end
    | Arith f w ->
       match expand_words s0 q GeneratedString ([],w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESArith "before arithmetic parsing") step, s1, [], [K (Arith (f ++ f1) w1)])
       | Left err -> Left err
       end
    | Quote w -> (* TODO 2018-02-02 properly accumulate quote while running *)
       match expand_words s0 Quoted GeneratedString ([],w) with
       | Right (step, s1, f1, []) -> Right (step, s1, f1, [])
       | Right (step, s1, f1, w1) -> Right (step, s1, f1, [K (Quote w1)])
       | Left err -> Left err
       end
  end

and expand_words s0 q sm (f,w) =
  match w with
    | [] -> Right (ESStep "done", s0, f, w)
    | (F::ws) -> Right (ESStep "user field separator", s0, f ++ [UsrF], ws)
    | (S(s)::ws) ->
        let f1 = match (q, sm) with
        | (Quoted, _) -> [DQuo s]
        | (Unquoted, UserString) -> [UsrS s]
        | (Unquoted, GeneratedString) -> [ExpS s]
        end in
        Right (ESStep "plain string", s0, f ++ f1, ws)
    | (K(k)::ws) ->
       match expand_control s0 q k with
       | Right (step, s1, f1, w1) -> Right (step, s1, f++f1, (w1 ++ ws))
       | Left err -> Left err
       end
    | (ESym(c)::ws) -> Right (ESStep "skipping symbolic result", s0, f ++ [EWSym c], ws)
  end

and control_code_expansion s0 q w =
  match expand_words s0 q UserString ([],w) with
  | Right (_step, s1, f1, w1) ->
     match w1 with
     | [] -> (s1, f1)
     | _ -> let (s2, f2) = control_code_expansion s1 q w1 in
            (s2, (f1 ++ f2))
     end
  | Left (_step, s1, err1) -> (s1, err1)
  end

(**********************************************************************)
(* EXPANSION TRANSITIONS **********************************************)
(**********************************************************************)

and step_expansion (os0,st) =
  match st with
  | ExpStart w0 -> 
     match expand_words os0 Unquoted UserString ([],w0) with
     | Right (step, os1, f1, w1) -> (os1, ExpExpand f1 w1, step)
     | Left (step, os1, f1) -> (os1, ExpError (fields_of_expanded_words f1), step)
     end
  | ExpExpand f0 w0 -> 
     match expand_words os0 Unquoted UserString (f0,w0) with
     | Right (step, os1, f1, w1) ->
        match w1 with
        | [] -> (os1, ExpSplit f1, step)
        | _ ->  (os1, ExpExpand f1 w1, step)
        end
     | Left (step, os1, f1) -> (os1, ExpError (fields_of_expanded_words f1), step)
     end
  | ExpSplit f0 -> (os0, ExpPath (field_splitting os0 f0), ESSplit "")
  | ExpPath ifs0 -> (os0, ExpQuote (pathname_expansion os0 ifs0), ESPath "")
  | ExpQuote ifs0 -> (os0, ExpDone (quote_removal os0 ifs0), ESQuote "")
  (* the following cases should never occur in calls from trace_expansion: *)
  | ExpError _ -> (os0, st, ESStep "done in error state")
  | ExpDone _ -> (os0, st, ESStep "done in success state")
  end

(**********************************************************************)   
(* EVALUATION *********************************************************)   
(**********************************************************************)   
   
(* Steps the first, non-complete expansion_state and returns.
 * If it reached the base case, they are all complete, so
 *   we return the Left type to continue on the arg expansion. *)
and step_assign s0 assigns =
  match assigns with
  | [] -> Left (s0, [])
  | ((x, ExpError f) as error)::assigns' ->
    match step_assign s0 assigns' with
    | Right (s1, processed, step) -> Right (s1, error::processed, step)
    | Left (s1, completed) -> Left (s1, (x, f)::completed)
    end
  | ((x, ExpDone f) as finished)::assigns' ->
    match step_assign s0 assigns' with
    | Right (s1, processed, step) -> Right (s1, finished::processed, step)
    | Left (s1, completed) -> Left (s1, (x, f)::completed)
    end
  | (x, exp_state)::assigns' ->
    let (s1, next_state, step) = step_expansion (s0, exp_state) in
    Right (s1, (x, next_state)::assigns', XSExpand (XSSimple x) step)
  end

(* TODO 2018-01-26 implement builtins 

  BUILTINS IMPLEMENTED BY DASH

     [ / test
     alias
     bg
     cd
     chdir
     command
     echo
     false
     fg
     getopts
     hash
     jobs
     kill
     local
     printf
     pwd
     read
     true
     type
     ulimit
     umask
     unalias
     wait

   SPECIAL BUILTINS (need particular environment treatment)

     break
     :
     continue
     .
     eval
     exec
     exit
     export
     readonly
     return
     set
     shift
     times
     trap
     unset
 *)

and run_command s0 prog argv env fds =
  match try_concrete prog with
  (*  1a. If the command name matches the name of a special built-in utility, that special built-in utility shall be invoked. 

  .
  eval
  exec
  exit
  export
  readonly
  set
  shift
  times
  trap
  unset
*)

  | Just ":" -> Right (exit_with 0 s0,Done)
  | Just "break" ->
     match argv with
     | [] -> Right (s0,Break 1) (* default to just breaking the immediate loop *)
     | [s] -> match readInteger 10 0 (char_list_of_symbolic_string s) with
              | Right n -> 
                 if n < 1
                 then Left (s0,"break: " ^ write n ^ ": loop count out of range")
                 else Right (s0,Break (toNat n))
              | Left _ -> Left (s0,"break: " ^ string_of_symbolic_string s ^ ": numeric argument required")
              end
     | _ -> Left (s0,"break: too many arguments")
     end
  | Just "continue" ->
     match argv with
     | [] -> Right (s0,Continue 1) (* default to just continuing the immediate loop *)
     | [s] -> match readNat (char_list_of_symbolic_string s) with
              | Right n -> Right (s0,Continue n)
              | Left _ -> Left (s0,"continue: " ^ string_of_symbolic_string s ^ ": numeric argument required")
              end
     | _ -> Left (s0,"continue: too many arguments")
     end
  | Just "exit" ->
     match argv with
     | [] -> Right (s0,Exit) (* default to exit code of last command *)
     | [s] -> match readInteger 10 0 (char_list_of_symbolic_string s) with
              | Right n -> 
                 if n < 1
                 then Left (s0,"exit: " ^ write n ^ ": illegal number")
                 else Right (exit_with (toNat n) s0,Exit)
              | Left _ -> Left (s0,"exit: " ^ string_of_symbolic_string s ^ ": numeric argument required")
              end
     | _ -> Left (s0,"exit: too many arguments")
     end
  | Just "return" ->
     (* 2018-03-2 the present arrangement yields exit code of 1 on error; bash gives 255 for return; dash does 2.
        unspecified in POSIX docs *)
     match argv with
     | [] -> Right (s0,Return) (* just keep the last command's return status *)
     | [s] -> match readNat (char_list_of_symbolic_string s) with
              | Right n -> Right (exit_with n s0,Return)
              | Left _ -> Left (s0,"return: " ^ string_of_symbolic_string s ^ ": numeric argument required")
              end
     | _ -> Left (s0,"return: too many arguments")
     end
  | Just script_name -> 
     (* 1b. b. If the command name matches the name of a utility
        listed in the following table, the results are unspecified. *)
     if is_unspecified_utility script_name  
     then Right (s0,Done)
     else 
       (* 1c. If the command name matches the name of a function known
          to this shell, the function shall be invoked as described in
          Function Definition Command. If the implementation has
          provided a standard utility in the form of a function, it
          shall not be recognized at this point. It shall be invoked
          in conjunction with the path search in step 1e. *)
       match lookup_function script_name s0 with
       | Just body ->
           (* TODO 2018-02-12 set $*, $@, and $0, $1, ... 
              
              save pre-existing numerical arguments, $@, and $*
              
              so: does the shell need to know the maximal positional argument at any given time?
            *)
           Right (set_function_params 0 argv s0,
                  Call s0.sh.loop_nest (get_positional_params s0) script_name body body)
       | Nothing -> 
           (*   1d. If the command name matches the name [XSI] [Option Start]  of the type or ulimit utility, or [Option End]  of a utility listed in the following table, that utility shall be invoked.

alias
bg
cd
command
false
fc
fg
getopts
hash
jobs
kill
newgrp
pwd
read
true
umask
unalias
wait
*)
           Left (s0,"TODO 2018-02-12 not implemented")
       end
  | _ ->
     
(*
Otherwise, the command shall be searched for using the PATH environment variable as described in XBD Environment Variables :

If the search is successful:

If the system has implemented the utility as a regular built-in or as a shell function, it shall be invoked at this point in the path search.

Otherwise, the shell executes the utility in a separate utility environment (see Shell Execution Environment) with actions equivalent to calling the execl() function as defined in the System Interfaces volume of POSIX.1-2008 with the path argument set to the pathname resulting from the search, arg0 set to the command name, and the remaining execl() arguments set to the command arguments (if any) and the null terminator.

If the execl() function fails due to an error equivalent to the [ENOEXEC] error defined in the System Interfaces volume of POSIX.1-2008, the shell shall execute a command equivalent to having a shell invoked with the pathname resulting from the search as its first operand, with any remaining arguments passed to the new shell, except that the value of "$0" in the new shell may be set to the command name. If the executable file is not a text file, the shell may bypass this command execution. In this case, it shall write an error message, and shall return an exit status of 126.

It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not used to initialize shell variables (see Shell Variables) because they had invalid names, are included in the environment passed to execl() and (if execl() fails as described above) to the new shell.

Once a utility has been searched for and found (either as a result of this specific search or as part of an unspecified shell start-up activity), an implementation may remember its location and need not search for the utility again unless the PATH variable has been the subject of an assignment. If the remembered location fails for a subsequent invocation, the shell shall repeat the search to find the new location for the utility, if any.

If the search is unsuccessful, the command shall fail with an exit status of 127 and the shell shall write an error message.

If the command name contains at least one <slash>, the shell shall execute the utility in a separate utility environment with actions equivalent to calling the execl() function defined in the System Interfaces volume of POSIX.1-2008 with the path and arg0 arguments set to the command name, and the remaining execl() arguments set to the command arguments (if any) and the null terminator.

If the execl() function fails due to an error equivalent to the [ENOEXEC] error, the shell shall execute a command equivalent to having a shell invoked with the command name as its first operand, with any remaining arguments passed to the new shell. If the executable file is not a text file, the shell may bypass this command execution. In this case, it shall write an error message and shall return an exit status of 126.

It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not used to initialize shell variables (see Shell Variables) because they had invalid names, are included in the environment passed to execl() and (if execl() fails as described above) to the new shell.

If the utility would be executed with file descriptor 0, 1, or 2 closed, implementations may execute the utility with the file descriptor open to an unspecified file. If a standard utility or a conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing, the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or application might not behave as described in this standard.
*)
     let (s1,pid) = execve s0 prog argv env fds in
     (* TODO 2018-02-09 actually wait for pid to finish, set exit_code appropriately! *)
     Right (last_pid pid (exit_with 0 (* TODO 2018-02-09 FIXME *) s1),Done)
  end

and step_eval s0 stmt =
  match stmt with
  (* 
When a given simple command is required to be executed (that is, when any conditional construct such as an AND-OR list or a case statement has not bypassed the simple command), the following expansions, assignments, and redirections shall all be performed from the beginning of the command text to the end:

The words that are recognized as variable assignments or redirections according to Shell Grammar Rules are saved for processing in steps 3 and 4.

The words that are not variable assignments or redirections shall be expanded. If any fields remain following their expansion, the first field shall be considered the command name and remaining fields are the arguments for the command.

Redirections shall be performed as described in Redirection.

Each variable assignment shall be expanded for tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal prior to assigning the value.

In the preceding list, the order of steps 3 and 4 may be reversed if no command name results from step 2 or if the command name matches the name of a special built-in utility; see Special Built-In Utilities.

Variable assignments shall be performed as follows:

If no command name results, variable assignments shall affect the current execution environment.

If the command name is not a special built-in utility or function, the variable assignments shall be exported for the execution environment of the command and shall not affect the current execution environment except as a side-effect of the expansions performed in step 4. In this case it is unspecified:

Whether or not the assignments are visible for subsequent expansions in step 4

Whether variable assignments made as side-effects of these expansions are visible for subsequent expansions in step 4, or in the current shell execution environment, or both

If the command name is a standard utility implemented as a function (see XBD Utility), the effect of variable assignments shall be as if the utility was not implemented as a function.

If the command name is a special built-in utility, variable assignments shall affect the current execution environment. Unless the set -a option is on (see set), it is unspecified:

Whether or not the variables gain the export attribute during the execution of the special built-in utility

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the special built-in utility

If the command name is a function that is not a standard utility implemented as a function, variable assignments shall affect the current execution environment during the execution of the function. It is unspecified:

Whether or not the variable assignments persist after the completion of the function

Whether or not the variables gain the export attribute during the execution of the function

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the function (if variable assignments persist after the completion of the function)

If any of the variable assignments attempt to assign a value to a variable for which the readonly attribute is set in the current shell environment (regardless of whether the assignment is made in that environment), a variable assignment error shall occur. See Consequences of Shell Errors for the consequences of these errors.

If there is no command name, any redirections shall be performed in a subshell environment; it is unspecified whether this subshell environment is the same one as that used for a command substitution within the command. (To affect the current execution environment, see the exec special built-in.) If any of the redirections performed in the current shell execution environment fail, the command shall immediately fail with an exit status greater than zero, and the shell shall write an error message indicating the failure. See Consequences of Shell Errors for the consequences of these failures on interactive and non-interactive shells.

If there is a command name, execution shall continue as described in Command Search and Execution [run_command]. If there is no command name, but the command contained a command substitution, the command shall complete with the exit status of the last command substitution performed. Otherwise, the command shall complete with a zero exit status.

TODO 2018-01-28 special builtins vs. simple builtins

but:

  y=${x=5} cmd
  - side-effects of expansion happen in CURRENT env, even if in an assignment for a command
  - cmd sees y (but not x, because x isn't set for export)
  - env sees x (but not y, less surprisingly)

  export x
  y=${x=5} cmd
  - side effects of expansion happen in CURRENT env
  - cmd sees x and y
  - env sees x

  y=${x=5}
  - side effects of expansion happen in CURRENT env
  - env sees x and y (just an assignment)

so: how do we implement it?
  it seems consistent to do all of the expansions in the CURRENT environment, regardless of the kind of command
    but don't set it in the environment yet
  each assignment sees the previous ones
    set manually each time... or manually use a local environment?

  decide at the end whether or not to publish to the current environment

*)
  | Command assigns ws redirs ->
     Right (s0,
            CommandExpAssign
              (map (fun (x, w) -> (x, ExpStart w)) assigns)
              ws
              redirs,
            XSSimple "begin expansion")

  (* SPECIAL CASE: plain assignment, no command *)
  | CommandExpAssign ((x,exp_state0)::assigns) [] redirs ->
     match step_expansion (s0, exp_state0)  with
     | (s1, ExpDone f, _step) -> Right (set_param x (symbolic_string_of_fields f) s1, CommandExpAssign assigns [] redirs, XSSimple ("assign " ^ x))
     | (s1, ExpError f, step) -> Right (s1, CommandExpAssign assigns [] redirs, XSExpand (XSSimple ("error in " ^ x ^ ": " ^ fields_to_string f)) step)
     | (s1, exp_state1, step) -> Right (s1, CommandExpAssign ((x,exp_state1)::assigns) [] redirs, XSExpand (XSSimple "") step)
     end
  | CommandExpAssign [] [] redirs ->
     (* keep on expanding, since we have to actually expand the redirects no matter what *)
     Right (s0, CommandExpanded [] [] redirs, XSSimple "assignments complete")

  (* TODO 2018-01-26 special case, special builtins treat the environment specially
   *   "If the command name is a special built-in utility, variable assignments shall affect the current execution environment."
   *)

  (* GENERAL CASE: command with possible assignments, which no longer go in the general environment *)
  | CommandExpAssign assigns ws redirs ->
     match step_assign s0 assigns with
     (* Perform an expansion step in an assignment *)
     | Right (s1, assigns', exp_step) ->
        Right (s1,
               CommandExpAssign assigns' ws redirs,
               exp_step)
     (* Done, move on to expanding arguments *)
     | Left (s1, fields) ->
        Right (s1,
               CommandExpArgs fields (ExpStart ws) redirs,
               XSSimple "assignments fully expanded")
     end
  | CommandExpArgs assigns exp_state redirs ->
      let (os1, st1, step) = step_expansion (s0, exp_state) in
      match st1 with
        | ExpError _ ->
           Left (os1,
                 XSSimple "error in argument expansion")
        | ExpDone f ->
          Right (os1,
                 CommandExpanded assigns f redirs,
                 XSSimple "arguments fully expanded")
        | (_ as in_progress) ->
          Right(os1,
                CommandExpArgs assigns in_progress redirs,
                XSExpand (XSSimple "argument expansion step") step)
      end
  (* assigns are done, check on args 

extremely subtle behavior with errors in expansion:
  an expansion error is NOT a field

$ count() { echo $# ; }
$ count $(echo ${x?one two three})
/Users/mgree/fsh/dash/src/dash: 2: x: one two three
0
$ count $(echo ${x?one two three} four)
/Users/mgree/fsh/dash/src/dash: 3: x: one two three
0
$ count $(echo ${x?one two three}) four
/Users/mgree/fsh/dash/src/dash: 4: x: one two three
1
$ count $(${x? one two three}) four
/Users/mgree/fsh/dash/src/dash: 5: x:  one two three
      *)
  (* TODO 2017-12-22 add a CommandExpRedir to expand all of the redirect targets/heredocs *)
  | CommandExpanded assigns (prog::args) _redirs ->
     (* perform assignments *)
     (* TODO 2018-02-09 check to see if it's a special built-in, in which case assign to GLOBAL env *)
     let env = 
       foldr (fun (x,f) env' -> 
           Map.insert x (symbolic_string_of_fields f) env') 
         s0.sh.env assigns
     in
     (* TODO 2018-02-09 setup redirects *)
     let fds = s0.sh.fds in
     (* run command *)
     match run_command s0 prog args env fds with
     | Right (s1,stmt') -> Right (s1, stmt', XSSimple ("running " ^ string_of_symbolic_string prog))
     | Left (s1,msg) -> 
        (* TODO 2018-03-02 output msg to stderr *)
        Right (exit_with 1 (print_stderr s1 msg), Done, XSSimple "couldn't run command")
     end
  | CommandExpanded _assigns [] _redirs ->
     (* TODO 2018-02-09 setup redirects for side effects/file creation

        e.g., unset x y ; x=5 >${y=3}
              will set x to 5, y to 3, and create an empty file named 3
      *)
     Right (s0, Done, XSSimple "ran empty command")
  | Pipe _bg stmts -> 
     (* generate fifos between each statement *)
     let (s1,_pipe_fifos) = mkfifos s0 (length stmts - 1) in
     (* TODO 2018-02-09 spawn each process with fds set appropriately 

        builds fds1 ... fdsn such that:

        stmt1   STDOUT |-> fifo1    in fds1
        stmt2   STDOUT |-> fifo2    in fds2
        ...
        stmtn-1 STDOUT |-> fifon-1  in fdsn-1
        stmtn uses ambient          in fdsn

        stmt1 uses ambient          in fds1
        stmt2   STDIN  |-> fifo1    in fds2
        stmt3   STDIN  |-> fifo2    in fds3
        ...
        stmtn   STDIN  |-> fifon-1  in fdsn

        then spawn each subshell in its own fds
      *)     
     (* wait TODO 2018-02-09 depending on bg! *)
     Right (s1,Done,XSPipe "started pipe")
  | Redir _stmt' _redirs -> Left (s0, XSRedir "TODO")
  | Background _stmt' _redirs -> Left (s0, XSBackground "TODO")
  | Subshell _stmt' _redirs -> Left (s0, XSSubshell "TODO")
  | And l r ->
      match step_eval s0 l with
      | Left e -> Left e
      | Right (s1, Exit, step) -> Right (s1, Exit, step)
      | Right (s1, Return, step) -> Right (s1, Return, step)
      | Right (s1, Break n, step) -> Right (s1, Break n, step)
      | Right (s1, Continue n, step) -> Right (s1, Continue n, step)
      | Right (s1, Done, _step) ->
          match lookup_concrete_param s1 "?" with
          | Just "0" -> Right (s1, r, XSAnd "exit code was 0, continuing")
          | Just _ -> Right (s1, Done, XSAnd "exit code was non-zero, short-circuiting")
          | Nothing -> Left (s1, XSAnd "unset or symbolic exit code")
          end
      | Right (s1, l', step) -> Right (s1, And l' r, XSNested (XSAnd "") step)
      end
  | Or l r ->
      match step_eval s0 l with
      | Left e -> Left e
      | Right (s1, Exit, step) -> Right (s1, Exit, step)
      | Right (s1, Return, step) -> Right (s1, Return, step)
      | Right (s1, Break n, step) -> Right (s1, Break n, step)
      | Right (s1, Continue n, step) -> Right (s1, Continue n, step)
      | Right (s1, Done, _step) ->
          match lookup_concrete_param s1 "?" with
          | Just "0" -> Right (s1, Done, XSOr "exit code was 0, short-circuiting")
          | Just _ -> Right (s1, r, XSOr "exit code was non-zero, continuing")
          | Nothing -> Left (s1, XSOr "unset or symbolic exit code")
          end
      | Right (s1, l', step) -> Right (s1, Or l' r, XSNested (XSOr "") step)
      end
  | Not stmt' ->
      match step_eval s0 stmt' with
      | Left e -> Left e
      | Right (s1, Exit, step) -> Right (s1, Exit, step)
      | Right (s1, Return, step) -> Right (s1, Return, step)
      | Right (s1, Break n, step) -> Right (s1, Break n, step)
      | Right (s1, Continue n, step) -> Right (s1, Continue n, step)
      | Right (s1, Done, _step) ->
          match lookup_concrete_param s1 "?" with
          | Just "0" -> Right (set_param "?" (symbolic_string_of_string "1") s1, Done, XSNot "0 -> 1")
          (* Not bothering to check whether the exit code is numeric *)
          | Just _ -> Right (set_param "?" (symbolic_string_of_string "0") s1, Done, XSNot "_ -> 0")
          | Nothing -> Left (s1, XSNot "unset or symbolic exit code")
          end
      | Right (s1, stmt'', step) -> Right (s1, Not stmt'', XSNested (XSNot "") step)
      end
  | Semi l r ->
      match step_eval s0 l with
      | Left e -> Left e
      | Right (s1, Exit, step) -> Right (s1, Exit, step)
      | Right (s1, Return, step) -> Right (s1, Return, step)
      | Right (s1, Break n, step) -> Right (s1, Break n, step)
      | Right (s1, Continue n, step) -> Right (s1, Continue n, step)
      | Right (s1, Done, step) -> Right (s1, r, XSNested (XSSemi "continuing") step)
      | Right (s1, l', step) -> Right (s1, Semi l' r, XSNested (XSSemi "") step)
      end
  | If c t e ->
      match step_eval s0 c with
      | Left e -> Left e
      | Right (s1, Exit, step) -> Right (s1, Exit, step)
      | Right (s1, Return, step) -> Right (s1, Return, step)
      | Right (s1, Break n, step) -> Right (s1, Break n, step)
      | Right (s1, Continue n, step) -> Right (s1, Continue n, step)
      | Right (s1, Done, _step) ->
          match lookup_concrete_param s1 "?" with
          | Just "0" -> Right (s1, t, XSIf "exit code was 0, taking the true branch")
          | Just _ -> Right (s1, e, XSIf "exit code was non-zero, taking the false branch")
          | Nothing -> Left (s1, XSIf "unset or symbolic exit code")
          end
      | Right (s1, c', step) -> Right (s1, If c' t e, XSNested (XSIf "") step)
      end
  | While c body -> Right (enter_loop s0, WhileCond c c body, XSWhile "start to evaluate the condtion")
  | WhileCond c cur body ->
      match step_eval s0 cur with
      | Left e -> Left e
      | Right (s1, Break 1, step) -> Right (exit_loop s1, Done, XSNested (XSWhile "breaking") step)
      | Right (s1, Break n, step) -> Right (exit_loop s1, Break (n-1), XSNested (XSWhile "breaking to outer loop") step)
      | Right (s1, Continue 1, step) -> Right (s1, WhileCond c c body, XSNested (XSWhile "continuing loop") step)
      | Right (s1, Continue n, step) -> Right (exit_loop s1, Continue (n-1), XSNested (XSWhile "continuing to outer loop") step)
      | Right (s1, Done, _step) ->
          match lookup_concrete_param s1 "?" with
          | Just "0" -> Right (s1, WhileRunning c body body, XSWhile "exit code was 0, running the loop body")
          | Just _ -> Right (exit_loop s1, Done, XSWhile "exit code was non-zero, taking the false branch")
          | Nothing -> Left (s1, XSWhile "unset or symbolic exit code")
          end
      | Right (s1, cur', step) -> Right (s1, WhileCond c cur' body, XSNested (XSWhile "") step)
      end
  | WhileRunning c body cur ->
      match step_eval s0 cur with
      | Left e -> Left e
      | Right (s1, Break 1, step) -> Right (exit_loop s1, Done, XSNested (XSWhile "breaking loop") step)
      | Right (s1, Break n, step) -> Right (exit_loop s1, Break (n-1), XSNested (XSWhile "breaking to outer loop") step)
      | Right (s1, Continue 1, step) -> Right (s1, WhileCond c c body, XSNested (XSWhile "continuing loop") step)
      | Right (s1, Continue n, step) -> Right (exit_loop s1, Continue (n-1), XSNested (XSWhile "continuing to outer loop") step)
      | Right (s1, Done, step) -> Right (s1, WhileCond c c body, XSNested (XSWhile "finished iteration of while loop; retesting condition") step)
      | Right (s1, cur', step) -> Right (s1, WhileRunning c body cur', XSNested (XSWhile "") step)
      end
  | For var ws body -> Right (s0, ForExpArgs var (ExpStart ws) body, XSFor "begin arg expansion")
  | ForExpArgs var exp_state body ->
      let (os1, st1, step) = step_expansion (s0, exp_state) in
      match st1 with
        | ExpError _ ->
           Left (os1,
                 XSFor "error in argument expansion")
        | ExpDone f ->
          Right (os1,
                 ForExpanded var f body,
                 XSFor "arguments fully expanded")
        | (_ as in_progress) ->
          Right(os1,
                ForExpArgs var in_progress body,
                XSExpand (XSFor "argument expansion step") step)
      end
  (* Special case, no items exit status is zero *)
  | ForExpanded _var [] _body -> Right (set_param "?" (symbolic_string_of_string "0") s0, Done, XSFor "no items exit code is 0")
  | ForExpanded var (i::f) body ->
      let s1 = enter_loop s0 in
      Right (set_param var i s1, ForRunning var f body body, XSFor ("starting for loop with " ^ var ^ " = " ^ (string_of_symbolic_string i)))
  | ForRunning var f body cur ->
      match step_eval s0 cur with
      | Left e -> Left e
      | Right (s1, Break 1, step) -> Right (exit_loop s1, Done, XSNested (XSFor "breaking loop") step)
      | Right (s1, Break n, step) -> Right (exit_loop s1, Break (n-1), XSNested (XSFor "breaking to outer loop") step)
      | Right (s1, Continue 1, step) ->
          match f with
          | [] -> Right (exit_loop s1, Done, XSNested (XSFor "continued at last iteration") step)
          | (i::f') -> Right (set_param var i s1, ForRunning var f' body body, XSNested (XSFor ("continuing to next iteration with " ^ var ^ " = " ^ string_of_symbolic_string i)) step)
          end
      | Right (s1, Continue n, step) -> Right (s1, Continue (n-1), XSNested (XSFor "continuing to outer loop") step)
      | Right (s1, Done, step) ->
          match f with
          | [] -> Right (exit_loop s1, Done, XSNested (XSFor "finished last iteration") step)
          | (i::f') -> Right (set_param var i s1, ForRunning var f' body body, XSNested (XSFor ("starting next iteration with " ^ var ^ " = " ^ string_of_symbolic_string i)) step)
          end
      | Right (s1, cur', step) -> Right (s1, ForRunning var f body cur', XSNested (XSFor "") step)
      end
  | Case ws cases -> Right (s0, CaseExpArg (ExpStart ws) cases, XSCase "begin arg expansion")
  | CaseExpArg exp_state cases ->
      let (os1, st1, step) = step_expansion (s0, exp_state) in
      match st1 with
        | ExpError _ ->
           Left (os1,
                 XSCase "error in argument expansion")
        | ExpDone [f] ->
              Right (os1,
                     CaseMatch f cases,
                     XSCase "argument fully expanded")
        | ExpDone _ -> Left (s0, XSCase "case match element did not expand to a single field")
        | (_ as in_progress) ->
          Right(os1,
                CaseExpArg in_progress cases,
                XSExpand (XSCase "argument expansion step") step)
      end
  | CaseMatch f cases ->
      match cases with
        | [] -> Right (s0, Done ,XSCase "no match in case statement")
        | (pat, cmd)::cases' -> Right (s0, CaseCheckMatch f (ExpStart pat) cmd cases', XSCase "checking pattern match")
      end
  | CaseCheckMatch f pat cmd cases ->
      let (os1, st1, step) = step_expansion (s0, pat) in
      match st1 with
        | ExpError _ ->
           Left (os1,
                 XSCase "error in case pattern expansion")
        | ExpDone [pat'] ->
          (* TODO 2018-02-09 use proper locale and verify substring mode works correctly *)
          match match_prefix lc_ambient Shortest pat' f with
          | NoMatch -> Right (os1, CaseMatch f cases, XSCase "case did not match, trying the next")
          | Match _ -> Right (os1, cmd, XSCase "case matched, evaluating cmd")
          | Symbolic -> Left (os1, XSCase "TODO, this could match")
          end
        | ExpDone _ -> Left (os1, XSCase "case match pattern did not expand to a single field")
        | (_ as in_progress) ->
          Right(os1,
                CaseCheckMatch f in_progress cmd cases,
                XSExpand (XSCase "pattern expansion step") step)
      end
  | Defun name body -> 
     if is_special_builtin name
     then Left (s0, XSDefun ("invalid function name " ^ name ^ " (shadows special built-in)"))
     else Right (defun name body s0,Done,XSDefun ("defined " ^ name))
  (* This should never come up when called from trace_evaluation or elsewhere *)
  | Call old_loop_nest old_positional_params f orig c ->
     match step_eval s0 c with
     | Left e -> Left e
     | Right (s1, Done, step) ->
        Right (set_function_params old_loop_nest old_positional_params s1, Done, XSStack "f (natural return)" step)
     | Right (s1, Return, step) ->
        Right (set_function_params old_loop_nest old_positional_params s1, Done, XSStack "f (explicit return)" step)
     | Right (s1, Exit, step) ->
        Right (set_function_params old_loop_nest old_positional_params s1, Exit, XSStack "f (exit)" step)
     (* TODO 2018-03-02 what do we do if there's a break or continue in a call? 
        
        break/continue don't seem to ever be lexically enclosed in a loop, so behavior is unspecified.
        bash supports "non local break", dash doesn't.
      *)
     | Right (s1, c', step) ->
        Right (s1, Call old_loop_nest old_positional_params f orig c', XSStack f step)
     end
  | Break _n -> Right (s0, Done, XSSimple "break bottomed out")
  | Continue _n -> Right (s0, Done, XSSimple "continue bottomed out")
  | Return -> Right (s0, Done, XSSimple "")
  | Wait _n -> Left (s0, XSSimple "TODO 2018-03-02 not implemented")
  | Exit -> 
     (* TODO 2018-03-02 handle traps *)
     Right (s0, Done, XSSimple "exited")
  | Done -> Right (s0, Done, XSSimple "")
  end

(**********************************************************************)   
(* PROPERTIES *********************************************************)   
(**********************************************************************)   

lemma normal_expands_to_string : forall s0 x qm. exists s. expand_param s0 qm x Normal = [S s]

(**********************************************************************)   
(* TRACING ************************************************************)   
(**********************************************************************)   
(* TODO 2018-01-26 limit the amount of trace generated (for while, etc) *)
(* These functions are for testing and the expansion tool. *)

val run_trace_expansion : ty_os_state * expansion_state -> list (ty_os_state * expansion_state * expansion_step)
let rec run_trace_expansion (os0,st0) =
  match st0 with
  | ExpError _ -> []
  | ExpDone _ -> []
  | _ -> 
     let (os1,st1,step) = step_expansion (os0,st0) in
     (os1,st1,step)::run_trace_expansion (os1,st1)
  end

val trace_expansion : ty_os_state -> words -> list (ty_os_state * expansion_state * expansion_step)
let trace_expansion os0 w0 = 
  (os0,ExpStart w0, ESStep "")::run_trace_expansion (os0, ExpStart w0)

(* function for testing final expansion results (used in
   test_expansion.ml)

   this function is a little unfaithful to the expansion semantics
   because we're not keeping track of whether the result was a message
   printed to stderr or the actual result of expansion
 *)
val full_expansion : ty_os_state -> words -> ty_os_state * fields
let full_expansion s0 w0 =
  let (s1,f1,_) = last (trace_expansion s0 w0) in
  match f1 with
  | ExpError f -> (s1, f)
  | ExpDone f -> (s1, f)
  | _ -> (s1, [symbolic_string_of_string "!!! broken invariant"])
  end

val run_trace_evaluation : ty_os_state -> stmt -> list (ty_os_state * stmt * evaluation_step)
let rec run_trace_evaluation os0 stmt0 =
  match stmt0 with
  | Done -> []
  | _ ->
      match step_eval os0 stmt0 with
      | Right (os1, stmt1, step) -> (os1, stmt1, step)::run_trace_evaluation os1 stmt1
      | Left (os1, step) -> [(os1, Done, step)]
      end
  end

val trace_evaluation : ty_os_state -> stmt -> list (ty_os_state * stmt * evaluation_step)
let trace_evaluation os0 stmt0 = (os0,stmt0,XSStep "")::run_trace_evaluation os0 stmt0

val trace_evaluation_multi : ty_os_state -> list stmt -> list (ty_os_state * stmt * evaluation_step)
let rec trace_evaluation_multi os0 stmts =
  match stmts with
  | [] -> []
  | (stmt::stmts') -> 
     let trace = trace_evaluation os0 stmt in
     let (os1,_,_) = last trace in
     trace ++ trace_evaluation_multi os1 stmts'
  end
