open import Fsh

open import Arith
open import Pattern
open import Path
open import Command

import Debug

(**********************************************************************)   
(* SHARED DECLARATIONS FOR EXPANSION AND EVALUATION *******************)   
(**********************************************************************)   

type string_mode =
    UserString
  | GeneratedString

type quoting_mode =
    Unquoted
  | Quoted

type redir_exp_result 'a =
    REDone of 'a * expanded_redir
  | REError of fields
  | REStep of expansion_step * 'a * expanding_redir

val expand_control : forall 'a. OS 'a => 
                     'a -> quoting_mode -> control ->
                     either (expansion_step * 'a * expanded_words) 
                            (expansion_step * 'a * expanded_words * words) 
val expand_words : forall 'a. OS 'a => 
                   'a -> quoting_mode -> string_mode -> (expanded_words * words) ->
                   either (expansion_step * 'a * expanded_words) 
                          (expansion_step * 'a * expanded_words * words) 
val step_expansion : forall 'a. OS 'a =>
                     'a * expansion_state -> 
                     expansion_step * 'a * expansion_state 
val step_redir : forall 'a. OS 'a => 'a -> expanding_redir -> redir_exp_result 'a
val step_redir_state : forall 'a. OS 'a => 'a -> redir_state -> 
                       'a * string * maybe (redir_state * maybe expansion_step)
val do_redirs : forall 'a. OS 'a =>
                     'a -> list expanded_redir -> either string ('a * saved_fds)
val step_assign : forall 'a. OS 'a => 
                  'a -> list (string * expansion_state) ->
                  either ('a * list (string * fields)) (* Done state *)
                         (evaluation_step * 'a * list (string * expansion_state)) 
val step_eval : forall 'a. OS 'a =>
                'a -> stmt -> 
                either (evaluation_step * 'a) (* error case *)
                       (evaluation_step * 'a * stmt) (* success *)

val full_evaluation : forall 'a. OS 'a => 'a -> stmt -> 'a
val eval : forall 'a. OS 'a => 'a -> stmt -> nat

(**********************************************************************)   
(* LATE STAGE EXPANSION ***********************************************)   
(**********************************************************************)
(* These functions are kept out of the recursive knot of
   expansion/evaluation, just to keep the file simple. Unfortunately,
   that means they show up first, out of logical order. Sorry! *)
   
(*
 * Stage 2 Expansion: Field Splitting
 *)

val is_ws : char -> bool
val collect_non_ifs : list char -> list char -> (list char) * (list char)
(*val collect_ifs_whitespace : list char -> list char -> list char*)
val split_expstring : list char -> list char -> intermediate_fields
val split_word : list char -> (intermediate_fields * expanded_words) -> (intermediate_fields * expanded_words)
val split_fields : forall 'a. OS 'a => 'a -> expanded_words -> intermediate_fields
val clean_fields : intermediate_fields -> intermediate_fields
val field_splitting : forall 'a. OS 'a => 'a -> expanded_words -> intermediate_fields  
  
let is_ws c = elem c (toCharList " \n\t")
           
let rec collect_non_ifs ifs ls =
  match ls with
  | [] -> ([], [])
  | (c::cs) ->
      if elem c ifs
      then ([], c::cs)
      else let (f, remaining) = collect_non_ifs ifs cs in
           (c::f, remaining)
  end

let rec split_expstring ifs clst =
   match clst with
   | [] -> []
   | c::cs ->
       if elem c ifs
       then let fs = if is_ws c then WFS else FS 
            in fs::split_expstring ifs cs
       else let (cc, cs1) = collect_non_ifs ifs cs in 
            (Field (symbolic_string_of_char_list (c::cc)))::(split_expstring ifs cs1)
  end

let rec split_word ifs p =
  match p with
  | (f, []) -> (f, [])
  | (f, UsrF::wrds) -> split_word ifs (f ++ [FS], wrds)
  | (f, ExpS(s)::wrds) ->
      let new_fields = split_expstring ifs (toCharList s) in
      split_word ifs (f ++ new_fields, wrds)
  | (f, UsrS(s)::wrds) -> split_word ifs (f ++ [Field (symbolic_string_of_string s)], wrds)
  | (f, DQuo(ss)::wrds) -> split_word ifs (f ++ [QField ss], wrds)
  | (f, EWSym sym::wrds) -> split_word ifs (f ++ [Field [Sym sym]], wrds)
  end

let split_fields s0 exp_words =
  let ifs = lookup_param s0 "IFS" in
  let (f, _) = match ifs with
    | Nothing -> split_word (toCharList " \n\t") ([], exp_words)
    | Just fs -> 
       match try_concrete fs with
       | Nothing -> 
          (* TODO 2018-08-29 unsoundly usinsg default IFS. symbolic IFS is basically impossible. should record this unsoundness. *)
          split_word (toCharList " \n\t") ([], exp_words)
       | Just "" -> ([Field (concat_expanded exp_words)], [])
       | Just s -> split_word (toCharList s) ([], exp_words)
       end
  end in f

let rec combine_fields f =
  match f with
  | [] -> []
  | [WFS] -> [] (* Remove trailing field separators *)
  | (WFS::WFS::rst) -> combine_fields (WFS::rst) (* Combine adjacent whitespace separators *)
  | (WFS::FS::rst) -> combine_fields (FS::rst)
  | (FS::WFS::rst) -> combine_fields (FS::rst)
  | (Field(s1)::Field(s2)::rst) -> combine_fields (Field(s1 ++ s2)::rst)
  | (WFS::rst) -> FS::(combine_fields rst)
  | (f::rst) -> f::(combine_fields rst)
  end

let rec clean_fields f =
  match f with
  | (WFS::rst) -> clean_fields rst
  | _ -> combine_fields f
  end

let field_splitting s0 w = clean_fields (split_fields s0 w)

(*
 * Stage 3 Expansion: Pathname expansion
 *)

val insert_field_separators : list string -> intermediate_fields
let rec insert_field_separators fs =
  match fs with
  | [] -> []
  | [f] -> [Field (symbolic_string_of_string f)]
  | f::fs' -> Field (symbolic_string_of_string f)::FS::insert_field_separators fs'
  end

val pathname_expansion : forall 'a. OS 'a => 'a -> intermediate_fields -> intermediate_fields

(* Parameter expansion only happens on unquoted fields *)
let rec pathname_expansion s0 f =
  match f with
  | [] -> []
  | (Field(s)::rst) -> 
     let matches = 
       match try_concrete s with
       | Just pat -> match_path s0 pat
       | Nothing -> [] (* slightly inaccurate: we're not modeling symbolic pathname expansions *)
       end 
     in
     let expansions = 
       if null matches 
       then [Field s] 
       else insert_field_separators matches 
     in
     expansions ++ pathname_expansion s0 rst
  | (f::rst) -> f::(pathname_expansion s0 rst)
  end

(*
 * Stage 4 Expansion: Quote Removal
 *)

val remove_quotes : intermediate_fields -> intermediate_fields
val to_fields : intermediate_fields -> fields
val finalize_fields : intermediate_fields -> fields
val quote_removal : intermediate_fields -> fields

let rec remove_quotes f =
  match f with
  | [] -> []
  | (QField(s)::rst) -> Field(s)::(remove_quotes rst)
  | (f::rst) -> f::(remove_quotes rst)
  end

let rec to_fields f =
  match f with
  | []           -> []
  | FS::FS::rst  -> (symbolic_string_of_string "")::(to_fields rst)
  | Field fs::rst -> 
     fs::(to_fields rst)
  | FS::rst      -> to_fields rst
  (* TODO 2017-12-01 Preferably we need an AST that doesn't have WFS or QField's at this point, or lem failure *)
  | WFS::_       -> [symbolic_string_of_string "broken invariant"]
  | QField _::_  -> [symbolic_string_of_string "broken invariant"]
  end

let rec finalize_fields f =
  match f with
  | (FS::rst) -> symbolic_string_of_string ""::finalize_fields rst
  | _ -> to_fields f
  end

let quote_removal f =
  let no_quotes = combine_fields (remove_quotes f) in
  finalize_fields no_quotes

let rec do_redirs os0 ers =
  match ers with
  | [] -> Right (os0, Map.empty)
  | (er::ers') ->
     match redirect os0 er with
     | Left err -> Left err
     | Right (os1,saved) -> 
        match do_redirs os1 ers' with
        | Left err -> Left err
        | Right (os2,saved') -> Right (os2, Map.(union) saved saved')
        end
     end
  end

(**********************************************************************)   
(* EXPANSION **********************************************************)   
(**********************************************************************)   
   
(*
 * Stage 1 Expansion: Word expansion
 *)

val expand_param : forall 'a. OS 'a => 'a -> quoting_mode -> string -> format -> words
(* Runs expansion all the way, for testing purposes only *)
val control_code_expansion : forall 'a. OS 'a => 'a -> quoting_mode -> words -> ('a * expanded_words)

let match_substring (lc:locale) (side:substring_side) (mode:substring_mode) (pat:expanded_words) (str:fields) : symbolic_string =
  let sympat : symbolic_string = (concat_expanded pat) in
  let symstr : symbolic_string = symbolic_string_of_fields str in
  try_match_prefix lc side mode sympat symstr

(* TODO 2017-12-01
 * In an N____ case, when null_string fs is Nothing, the
 * string is entirely symbolic so we need
 * to represent the symbolic result of "it could be either
 * true or false, we don't know". This means we need to branch
 * and allow for both cases to progress.
 *)
let expand_param s0 _q str f =
  let value = lookup_param s0 str in
  match (value, f) with
  (* NORMAL *)
  | (Nothing, Normal)     -> [S ""] (* null *)
  | (Just fs, Normal)     -> words_of_symbolic_string fs
  (* DEFAULT *)
  | (Nothing, Default w)  -> w
  | (Just fs, Default _)  -> words_of_symbolic_string fs
  | (Nothing, NDefault w) -> w
  | (Just fs, NDefault w) ->
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> w
     | Just false -> words_of_symbolic_string fs
     end
  (* ASSIGN *)
  | (Nothing, Assign w)  -> [K (LAssign str [] w)]
  | (Just fs, Assign _)  -> words_of_symbolic_string fs       
  | (Nothing, NAssign w) -> [K (LAssign str [] w)]
  | (Just fs, NAssign w) -> 
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> [K (LAssign str [] w)]
     | Just false -> words_of_symbolic_string fs
     end
  (* ERROR *)
  | (Nothing, Error w)  -> [K (LError str [] w)]
  | (Just fs, Error _)  -> words_of_symbolic_string fs
  | (Nothing, NError w) -> [K (LError str [] w)]
  | (Just fs, NError w) -> 
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> [K (LError str [] w)]
     | Just false -> words_of_symbolic_string fs
     end
  (* LENGTH *)
  | (Nothing, Length) -> [S "0"]
  | (Just fs, Length) ->
     match try_concrete fs with
     | Nothing -> (* TODO This should be the length of the symbolic result of fs *) [S "0"]
     | Just strs -> [S (show (stringLength strs))]
     end
  (* ALT *)
  | (Nothing, Alt _)  -> [S ""]
  | (Just _, Alt w)  -> w
  | (Nothing, NAlt _) -> [S ""]
  | (Just fs, NAlt w) ->
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> [S ""]
     | Just false -> w
     end
  (* SUBTRINGS (prefix/suffix) *)
  | (Nothing, Substring _ _ _) -> [S ""]
  | (Just fs, Substring s m w) -> [K (LMatch [fs] s m [] w)]
  end

let rec expand_control s0 q k =
    match k with
    | Tilde ->
       let (msg, dir) = match expand_param s0 Unquoted "HOME" Normal with
         (* if HOME is unset, results are unspecified---we return "~" 
            dash:
              $ unset HOME
              $ echo ~
              ~
              $ HOME=""
              $ echo ~
              ~
              $ HOME="/Users/mgree"
              $ echo ~
              /Users/mgree

            bash:
              $ unset HOME
              $ echo ~
              /Users/mgree
              $ HOME=""
              $ echo ~
              
              $ HOME="/Users/mgree"
              $ echo ~
              /Users/mgree            

            lol
          *)
         | [S ""] -> ("defaulting to dash behavior for unset HOME (unspec per 2.6.1)", [S "~"])
         | dir -> ("", dir)
         end in
       Right (ESTilde msg, s0, [], dir)
    | TildeUser usr -> 
       match getpwnam s0 usr with
       | Nothing -> Right (ESTilde "defaulting to dash behavior for failed getpwnam (unspec per 2.6.1)", s0, [], [S ("~" ^ usr)]) (* unspec per 2.6.1, but we follow dash *)
       | Just path -> Right (ESTilde "", s0, [], [S path])
       end
    | Param s f -> expand_words s0 q GeneratedString ([], expand_param s0 q s f)
    | LAssign s f [] ->
       match set_param s (concat_expanded f) s0 with
       | Left err -> Left (ESParam "bad or readonly variable", s0, ExpS err::f)
       | Right s1 -> Right (ESParam "finished assignment", s1, f, [])
       end
    | LAssign s f w ->
       match expand_words s0 q GeneratedString ([], w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESParam "assignment") step, s1, [], [K (LAssign s (f ++ f1) w1)])
       | Left err -> Left err
       end
    | LMatch str side mode f [] -> Right (ESParam "finished match", s0, [], words_of_symbolic_string (match_substring (get_shell_state s0).locale side mode f str))
    | LMatch s side mode f w ->
       match expand_words s0 q GeneratedString ([], w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESParam "match") step, s1, [], [K (LMatch s side mode (f ++ f1) w1)])
       | Left err -> Left err
       end
    | LError str f [] -> Left (ESParam "raising requested error", s0, ExpS (str ^ ": ")::f) (* dash seems to print erroring variable name; TODO should we also have linno? *)
    | LError str f w ->
       match expand_words s0 q GeneratedString ([], w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESParam "error") step, s1, [], [K (LError str (f ++ f1) w1)])
       | Left err -> Left err
       end
    | Backtick c ->
       (* create a pipe *)
       let (s1, fd_read, fd_write) = pipe s0 in
       let cmd = 
         pushredir 
           (* set up redirects [skipping expansion] *)
           (with_redirs c [ERDup ToFD true (* close orig *) fd_write (Just STDOUT)])
           (* make sure to close the pipe when we're done *)
           (Map.singleton fd_write Close)
       in
       let (s2, pid) = fork_and_subshell eval s1 cmd in
       Right (ESCommand "initializing subshell", 
              s2, 
              [], 
              [K (LBacktick c pid fd_read)])
    | LBacktick corig pid fd_read ->
       match waitpid step_eval s0 pid with
       | (s1, Nothing) -> 
          Left (ESEval (ESCommand "") 
                  (XSWait ("couldn't step process with pid " ^ stringFromNat pid)), 
                 write_stderr ("wait: pid " ^ stringFromNat pid ^ " is not a child of this shell") s1, 
                 [])
       | (s1, Just (Left step)) ->
          Right (ESEval (ESCommand ("process with pid " ^ stringFromNat pid ^ " stepped"))
                         step,
                 s1,
                 [],
                 [K (LBacktick corig pid fd_read)])
       | (s1, Just (Right _code)) ->
          (* TODO 2018-08-29 do we need to look at the exit code? *)
          match read_fd s1 fd_read with
          | Nothing -> 
             Left (ESCommand "broken pipe",
                   s1,
                   [])
          | Just (s2, s) ->
             let s3 = close_fd s2 fd_read in
             let s_trimmed = trimr_newlines s in
             Right (ESCommand "command exited successfully",
                    s3, 
                    [ExpS s_trimmed], 
                    [])
          end
       end            
    | Arith f [] ->
        match arith64 s0 (concat_expanded f) with
        | Right (s1, result) -> Right (ESArith "computed arithmetic result", s1, expanded_words_of_fields result, [])
        | Left e -> Left (ESArith "arithmetic error", s0, [ExpS e])
        end
    | Arith f w ->
       match expand_words s0 q GeneratedString ([],w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESArith "before arithmetic parsing") step, s1, [], [K (Arith (f ++ f1) w1)])
       | Left err -> Left err
        end
   | Quote f [] ->
      Right (ESQuote "finished quote expansion", s0, [DQuo (concat_expanded f)], [])
   | Quote f w -> 
       match expand_words s0 Quoted GeneratedString ([],w) with
       | Right (step, s1, f1, w1) -> Right (step, s1, [], [K (Quote (f ++ f1) w1)])
       | Left err -> Left err
       end
  end

and expand_words s0 q sm (f,w) =
  match w with
    | [] -> Right (ESStep "done", s0, f, w)
    | (F::ws) -> Right (ESStep "user field separator", s0, f ++ [UsrF], ws)
    | (S(s)::ws) ->
       let f1 = match (q, sm) with
         | (Quoted, _) -> [DQuo (symbolic_string_of_string s)]
         | (Unquoted, UserString) -> [UsrS s]
         | (Unquoted, GeneratedString) -> [ExpS s]
       end in
        Right (ESStep "plain string", s0, f ++ f1, ws)
    | (K(k)::ws) ->
       match expand_control s0 q k with
       | Right (step, s1, f1, w1) -> Right (step, s1, f++f1, (w1 ++ ws))
       | Left err -> Left err
       end
    | (ESym(c)::ws) -> Right (ESStep "skipping symbolic result", s0, f ++ [EWSym c], ws)
  end

and control_code_expansion s0 q w =
  match expand_words s0 q UserString ([],w) with
  | Right (_step, s1, f1, w1) ->
     match w1 with
     | [] -> (s1, f1)
     | _ -> let (s2, f2) = control_code_expansion s1 q w1 in
            (s2, (f1 ++ f2))
     end
  | Left (_step, s1, err1) -> (s1, err1)
  end

(**********************************************************************)
(* EXPANSION TRANSITIONS **********************************************)
(**********************************************************************)

and step_expansion (os0,st) =
  match st with
  | ExpStart w0 -> 
     match expand_words os0 Unquoted UserString ([],w0) with
     | Right (step, os1, f1, w1) -> (step, os1, ExpExpand f1 w1)
     | Left (step, os1, f1) -> (step, os1, ExpError (fields_of_expanded_words f1))
     end
  | ExpExpand f0 w0 -> 
     match expand_words os0 Unquoted UserString (f0,w0) with
     | Right (step, os1, f1, w1) ->
        match w1 with
        | [] -> (step, os1, ExpSplit f1)
        | _ ->  (step, os1, ExpExpand f1 w1)
        end
     | Left (step, os1, f1) -> (step, os1, ExpError (fields_of_expanded_words f1))
     end
  | ExpSplit f0 -> (ESSplit "", os0, ExpPath (field_splitting os0 f0))
  | ExpPath ifs0 -> (ESPath "", os0, ExpQuote (pathname_expansion os0 ifs0))
  | ExpQuote ifs0 -> (ESQuote "", os0, ExpDone (quote_removal ifs0))
  (* the following cases should never occur in calls from trace_expansion: *)
  | ExpError _ -> (ESStep "done in error state", os0, st)
  | ExpDone _ -> (ESStep "done in success state", os0, st)
  end

(**********************************************************************)   
(* EVALUATION *********************************************************)   
(**********************************************************************)   
   
(* Steps an expanding_redir along *)
and step_redir os0 er =
  let exp_state = get_expanding_redir_state er in
  let (step, os1, st1) = step_expansion (os0, exp_state) in
  match st1 with
   | ExpError err -> REError err
   | ExpDone f -> REDone os1 (expand_redir er f)
   | ExpPath ifs ->
      (* "Pathname expansion shall not be performed on the word [that
         is the target of redirection] by a non-interactive shell; an
         interactive shell may perform it, but shall do so only when
         the expansion would result in one word."

        "If no part of word is quoted, all lines of the here-document
         shall be expanded for parameter expansion, command
         substitution, and arithmetic expansion."

         i.e., skipping pathname expansion. the dash parser should
         take care of a lot of this. 
       *)
      let (msg,es') = 
        if is_interactive os1 && not (is_heredoc er)
        then 
          let expanded = pathname_expansion os1 ifs in
          if length expanded = 1
          then ("performed pathname expansion in interactive shell",
                ExpQuote expanded)
          else ("skipped pathname expansion in interactive shell [produced " ^ 
                (stringFromNat (length expanded)) ^ " words]",
                ExpQuote ifs)
        else ("skipped pathname expansion", ExpQuote ifs)
      in
      REStep (ESPath msg) os1 (set_expanding_redir_state es' er)
   | _ -> REStep step os1 (set_expanding_redir_state st1 er)
   end

and step_redir_state os0 redir_state =
  match redir_state with
  | (_ers, Nothing, []) -> (os0, "done expanding redirs", Just (redir_state, Nothing))
  | (ers, Nothing, r::redirs) ->
     let (msg, ers, exp_state) =
       match r with
       | RFile ty src w -> ("expanding file redirect", ers, Just (XRFile ty src (ExpStart w)))
       | RDup ty src tgt -> ("trivially expanded dup", ers ++ [ERDup ty false (* don't close orig *) src tgt], Nothing)
       | RHeredoc XHere src w -> 
          ("expanding unquoted heredoc", ers, Just (XRHeredoc XHere src (ExpStart w)))
       | RHeredoc Here src w -> 
          ("not expanding quoted heredoc", 
           ers ++ [ERHeredoc Here src [symbolic_string_of_string (string_of_words w)]], 
           Nothing)
       end in
     (os0, msg, Just ((ers, exp_state, redirs), Nothing))
  | (ers, Just er, redirs) ->
     match step_redir os0 er with
     | REError err ->
        let msg = string_of_symbolic_string (symbolic_string_of_fields err) in
        (os0,
         msg,
         Nothing)
     | REDone os1 er' ->
        (os1,
         "expanded redirect",
         Just ((ers ++ [er'], Nothing, redirs), Nothing))
     | REStep step os1 er' ->
        (os1,
         "redirection expansion step",
         Just ((ers, Just er', redirs), Just step))
     end
  end

(* Steps the first, non-complete expansion_state and returns.
 * If it reached the base case, they are all complete, so
 *   we return the Left type to continue on the arg expansion. *)
and step_assign s0 assigns =
  match assigns with
  | [] -> Left (s0, [])
  | ((x, ExpError f) as error)::assigns' ->
    match step_assign s0 assigns' with
    | Right (step, s1, processed) -> Right (step, s1, error::processed)
    | Left (s1, completed) -> Left (s1, (x, f)::completed)
    end
  | ((x, ExpDone f) as finished)::assigns' ->
    match step_assign s0 assigns' with
    | Right (step, s1, processed) -> Right (step, s1, finished::processed)
    | Left (s1, completed) -> Left (s1, (x, f)::completed)
    end
  | (x, exp_state)::assigns' ->
    let (step, s1, next_state) = step_expansion (s0, exp_state) in
    Right (XSExpand (XSSimple x) step, s1, (x, next_state)::assigns')
  end

and step_eval s0 stmt =
  (* 
     extremely subtle behavior with errors in expansion:
       an expansion error is NOT a field
       expansion errors cancel the current command with a failing exit status

     $ count() { echo $# ; }
     $ count ${x?one two three}                            # never runs count
     /Users/mgree/fsh/dash/src/dash: 2: x: one two three
     $ count $(echo ${x?one two three})                    # subshell fails, but count will run!
     /Users/mgree/fsh/dash/src/dash: 2: x: one two three
     0
     $ count $(echo ${x?one two three} four)
     /Users/mgree/fsh/dash/src/dash: 3: x: one two three
     0
     $ count $(echo ${x?one two three}) four
     /Users/mgree/fsh/dash/src/dash: 4: x: one two three
     1
     $ count $(${x? one two three}) four
     /Users/mgree/fsh/dash/src/dash: 5: x:  one two three
  *)
  match stmt with
  (* COMMAND ******************************************************************)
  | Command assigns ws redirs ->
     Right (XSSimple "begin expansion",
            s0,
            CommandExpAssign
              (map (fun (x, w) -> (x, ExpStart w)) assigns)
              ws
              redirs)
  (* COMMAND: SPECIAL CASE: plain assignment, no command **********************)
  (* in this case, we WANT the visibility between each assignment, so don't bother
     with the step_assigns rigamarole below *)
  | CommandExpAssign ((x,exp_state0)::assigns) [] redirs ->
     match step_expansion (s0, exp_state0)  with
     | (_step, s1, ExpDone f) -> 
        match set_param x (symbolic_string_of_fields f) s1 with
        | Left err -> Left (XSSimple err, write_stderr (err ^ "\n") s1)
        | Right s2 ->
           Right (XSSimple ("assign " ^ x),
                  s2, 
                  CommandExpAssign assigns [] redirs)
        end
     | (step, s1, ExpError f) -> 
        Right (XSExpand (XSSimple ("error in " ^ x ^ ": " ^ string_of_fields f)) step,
               s1, 
               CommandExpAssign assigns [] redirs)
     | (step, s1, exp_state1) -> 
        Right (XSExpand (XSSimple "") step,
               s1, 
               CommandExpAssign ((x,exp_state1)::assigns) [] redirs)
     end
  | CommandExpAssign [] [] redirs ->
     (* keep on expanding, since we have to actually expand the redirects no matter what *)
     Right (XSSimple "assignments complete", s0, CommandExpRedirs [] [] ([], Nothing, redirs))

  (* GENERAL CASE: command with possible assignments, which no longer go in the general environment *)
  | CommandExpAssign assigns ws redirs ->
     match step_assign s0 assigns with
     (* Perform an expansion step in an assignment *)
     | Right (exp_step, s1, assigns') ->
        Right (exp_step,
               s1,
               CommandExpAssign assigns' ws redirs)
     (* Done, move on to expanding arguments *)
     | Left (s1, fields) ->
        Right (XSSimple "assignments fully expanded",
               s1,
               CommandExpArgs fields (ExpStart ws) redirs)
    end
  | CommandExpArgs assigns exp_state redirs ->
      let (step, s1, st1) = step_expansion (s0, exp_state) in
      match st1 with
        | ExpError err ->
           let msg = string_of_symbolic_string (symbolic_string_of_fields err) in
           Right (XSSimple "error in argument expansion",
                  fail_with msg s1,
                  (* TODO 2018-09-05 implement table 2.8.1: non-interactive shells may exit *)
                  Done)
        | ExpDone f ->
           let msg = 
             show (length f) ^ " " ^ if length f = 1 then "argument" else "arguments" ^ 
             " fully expanded (including command)"
           in
           Right (XSExpand (XSSimple msg) step, 
                  s1, 
                  CommandExpRedirs assigns f ([], Nothing, redirs))
        | _ ->
           Right(XSExpand (XSSimple "argument expansion step") step,
                 s1,
                 CommandExpArgs assigns st1 redirs)
      end
  (* COMMAND: Redirect expansion **********************************************)
  (* expansion is done, try to run command *)
  | CommandExpRedirs assigns (prog::args) (ers, Nothing, []) ->
     (* load exported variables, perform assignments *)
     let sh = get_shell_state s0 in
     let exported = 
       Map_extra.mapMaybe 
         (fun x v -> if Set.member x sh.export then Just v else Nothing)
         sh.env
     in
     let env = 
       foldr (fun (x,f) env' -> 
           Map.insert x (symbolic_string_of_fields f) env') 
         exported assigns
     in
     (* "If the command name is a special built-in utility, variable
        assignments shall affect the current execution environment."

        Unless the set -a option is on (see set), it is unspecified:

        Whether or not the variables gain the export attribute during
        the execution of the special built-in utility

        Whether or not export attributes gained as a result of the
        variable assignments persist after the completion of the
        special built-in utility

        If the command name is a function that is not a standard
        utility implemented as a function, variable assignments shall
        affect the current execution environment during the execution
        of the function. It is unspecified:

        Whether or not the variable assignments persist after the
        completion of the function

        Whether or not the variables gain the export attribute during
        the execution of the function

        Whether or not export attributes gained as a result of the
        variable assignments persist after the completion of the
        function (if variable assignments persist after the completion
        of the function)

        If any of the variable assignments attempt to assign a value
        to a variable for which the readonly attribute is set in the
        current shell environment (regardless of whether the
        assignment is made in that environment), a variable assignment
        error shall occur. See Consequences of Shell Errors for the
        consequences of these errors.

        *)
     let s1 = 
       match try_concrete prog with
       | Just prog_name -> if is_special_builtin prog_name
                           then set_shell_state <| sh with env = Map.(union) env sh.env |> s0
                           else s0
       | Nothing -> s0 
       end in
     match do_redirs s1 ers with
     | Left msg -> 
        Right (XSRedir "error in redirection", 
               fail_with msg s1, 
               (* TODO 2018-09-05 implement table 2.8.1: non-interactive shells may exit *)
               Done)
     | Right (s2, saved_fds) ->
       (* run command *)
       match run_command s2 prog args env with
       | Right (s3,stmt') -> 
          Right (XSSimple ("ran " ^ string_of_symbolic_string prog), 
                 s3, 
                 pushredir stmt' saved_fds)
       | Left (s3,msg) -> 
          Right (XSSimple "couldn't run command", 
                 fail_with msg s3, 
                 pushredir Done saved_fds)
       end
     end
  (* expansion is done, but there's no command *)
  | CommandExpRedirs _assigns [] (ers, Nothing, []) ->
     (* we've already done whatever assignments above, in the special
        case.  it remains to set up redirects for side effects/file
        creation

        e.g., unset x y ; x=5 >${y=3} will set x to 5, y to 3, and
        create an empty file named 3 *)
     (* "If there is no command name, any redirections shall be
        performed in a subshell environment; it is unspecified whether
        this subshell environment is the same one as that used for a
        command substitution within the command. (To affect the
        current execution environment, see the exec special built-in.)
        If any of the redirections performed in the current shell
        execution environment fail, the command shall immediately fail
        with an exit status greater than zero, and the shell shall
        write an error message indicating the failure. See
        Consequences of Shell Errors for the consequences of these
        failures on interactive and non-interactive shells."  *)
     (* So... we're cheating on this a little. Rather than
        subshelling, we do the redirs and then record a pushredir. *)
     match do_redirs s0 ers with
     | Left msg -> 
        (* dash doesn't set the variables if the redirect failed *)
        Right (XSRedir "error in redirection", 
               fail_with msg s0, 
               Done)
     | Right (s1, saved_fds) ->
        Right (XSSimple "ran empty command", 
               s1, 
               pushredir Done saved_fds)
     end
   (* expand redirs *)
   | CommandExpRedirs assigns args redir_state ->
      match step_redir_state s0 redir_state with
      | (s1, msg, Nothing) ->
         Right (XSSimple "error in redirect expansion", 
                fail_with msg s1, 
                Done)
      | (s1, msg, Just (redir_state', mstep)) ->
         let step =
           match mstep with
           | Just estep -> XSExpand (XSSimple msg) estep
           | Nothing -> XSSimple msg
           end in
         Right (step, s1, CommandExpRedirs assigns args redir_state')
      end

  (* PIPE *********************************************************************)
  | Pipe bg stmts ->
     let (s1, last_pid) = run_pipe eval s0 stmts in
     let (s2, c) =
       if bg
       then (set_last_pid last_pid s1, Done)
       else (s1, Wait last_pid) 
     in
     Right (XSPipe "started pipe",
            s2,
            c)

  (* REDIR ********************************************************************)
  | Redir stmt' (ers, Nothing, []) ->
     match do_redirs s0 ers with
     | Left msg -> 
        Right (XSRedir "error in redirection", 
               fail_with msg s0, 
               Done)
     | Right (s1, saved_fds) ->
        Right (XSRedir "running redirected command", 
               s1, 
               pushredir stmt' saved_fds)
     end
  (* redirection steps *)
  | Redir stmt' redir_state ->
     match step_redir_state s0 redir_state with
     | (s1, msg, Nothing) ->
        Right (XSRedir "error in redirect expansion", 
               fail_with msg s1, 
               Done)
     | (s1, msg, Just (redir_state', mstep)) ->
        let step =
          match mstep with
          | Just estep -> XSExpand (XSRedir msg) estep
          | Nothing -> XSRedir msg
          end in
        Right (step, s1, Redir stmt' redir_state')
     end

  (* BACKGROUND ***************************************************************)
  | Background stmt' ((_, Nothing, []) as redir_state) ->
     (* defer to Redir to load redirs *)
     let (s1,pid) = fork_and_subshell eval s0 (Redir stmt' redir_state) in
     let s2 = set_last_pid pid s1 in
     Right (XSBackground ("started background process with pid " ^ (stringFromNat pid)), 
            s2, 
            Done)
  (* expand redirs *)
  | Background stmt' redir_state ->
     match step_redir_state s0 redir_state with
     | (s1, msg, Nothing) ->
        Right (XSBackground "error in redirect expansion", 
               fail_with msg s1, 
               Done)
     | (s1, msg, Just (redir_state', mstep)) ->
        let step =
          match mstep with
          | Just estep -> XSExpand (XSBackground msg) estep
          | Nothing -> XSBackground msg
          end in
        Right (step, s1, Background stmt' redir_state')
     end
 
  (* SUBSHELL *****************************************************************)
  | Subshell stmt' ((_, Nothing, []) as redir_state) ->
     let (s1,pid) = fork_and_subshell eval s0 (Redir stmt' redir_state) in
     Right (XSSubshell ("started subshell with pid " ^ stringFromNat pid), 
            s1, 
            Wait pid)
  | Subshell stmt' redir_state ->
     match step_redir_state s0 redir_state with
     | (s1, msg, Nothing) ->
        Right (XSSubshell "error in redirect expansion", 
               fail_with msg s1, 
               Done)
     | (s1, msg, Just (redir_state', mstep)) ->
        let step =
          match mstep with
          | Just estep -> XSExpand (XSSubshell msg) estep
          | Nothing -> XSSubshell msg
          end in
        Right (step, s1, Subshell stmt' redir_state')
     end

  (* AND **********************************************************************)
  | And l r ->
      match step_eval s0 l with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (step, s1, Exit)
      | Right (step, s1, Return) -> Right (step, s1, Return)
      | Right (step, s1, Break n) -> Right (step, s1, Break n)
      | Right (step, s1, Continue n) -> Right (step, s1, Continue n)
      | Right (_step, s1, Done) ->
          match get_last_exit_code s1 with
          | Just 0 -> Right (XSAnd "exit code was 0, continuing", s1, r)
          | Just _ -> Right (XSAnd "exit code was non-zero, short-circuiting", s1, Done)
          | Nothing -> Left (XSAnd "unset or symbolic exit code", s1)
          end
      | Right (step, s1, l') -> Right (XSNested (XSAnd "") step, s1, And l' r)
      end

  (* OR ***********************************************************************)
  | Or l r ->
      match step_eval s0 l with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (step, s1, Exit)
      | Right (step, s1, Return) -> Right (step, s1, Return)
      | Right (step, s1, Break n) -> Right (step, s1, Break n)
      | Right (step, s1, Continue n) -> Right (step, s1, Continue n)
      | Right (_step, s1, Done) ->
          match get_last_exit_code s1 with
          | Just 0 -> Right (XSOr "exit code was 0, short-circuiting", s1, Done)
          | Just _ -> Right (XSOr "exit code was non-zero, continuing", s1, r)
          | Nothing -> Left (XSOr "unset or symbolic exit code", s1)
          end
      | Right (step, s1, l') -> Right (XSNested (XSOr "") step, s1, Or l' r)
      end

  (* NOT **********************************************************************)
  | Not stmt' ->
      match step_eval s0 stmt' with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (step, s1, Exit)
      | Right (step, s1, Return) -> Right (step, s1, Return)
      | Right (step, s1, Break n) -> Right (step, s1, Break n)
      | Right (step, s1, Continue n) -> Right (step, s1, Continue n)
      | Right (_step, s1, Done) ->
          match get_last_exit_code s1 with
          | Just 0 -> 
             Right (XSNot "0 -> 1", exit_with 1 s1, Done)
          | Just _ -> 
             Right ((XSNot "_ -> 0"), exit_with 0 s1, Done)
          | Nothing -> Left (XSNot "unset or symbolic exit code", s1)
          end
      | Right (step, s1, stmt'') -> Right (XSNested (XSNot "") step, s1, Not stmt'')
      end

  (* SEMI *********************************************************************)
  | Semi l r ->
      match step_eval s0 l with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (step, s1, Exit)
      | Right (step, s1, Return) -> Right (step, s1, Return)
      | Right (step, s1, Break n) -> Right (step, s1, Break n)
      | Right (step, s1, Continue n) -> Right (step, s1, Continue n)
      | Right (step, s1, Done) -> Right (XSNested (XSSemi "done with LHS") step, s1, r)
      | Right (step, s1, l') -> Right (XSNested (XSSemi "") step, s1, Semi l' r)
      end

  (* IF ***********************************************************************)
  | If c t e ->
      match step_eval s0 c with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (step, s1, Exit)
      | Right (step, s1, Return) -> Right (step, s1, Return)
      | Right (step, s1, Break n) -> Right (step, s1, Break n)
      | Right (step, s1, Continue n) -> Right (step, s1, Continue n)
      | Right (_step, s1, Done) ->
          match get_last_exit_code s1 with
          | Just 0 -> Right (XSIf "exit code was 0, taking the true branch", s1, t)
          | Just _ -> Right (XSIf "exit code was non-zero, taking the false branch", s1, e)
          | Nothing -> Left (XSIf "unset or symbolic exit code", s1)
          end
      | Right (step, s1, c') -> Right (XSNested (XSIf "") step, s1, If c' t e)
      end

  (* WHILE ********************************************************************)
  | While c body -> 
     Right (XSWhile "start to evaluate the condtion", 
            enter_loop s0, 
            WhileCond c c body)
  | WhileCond c cur body ->
      match step_eval s0 cur with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (XSNested (XSWhile "exiting") step, s1, Exit)                                      
      | Right (step, s1, Return) -> Right (XSNested (XSWhile "returning") step, s1, Return)
      | Right (step, s1, Break 1) -> Right (XSNested (XSWhile "breaking") step, exit_loop s1, Done)
      | Right (step, s1, Break n) -> Right (XSNested (XSWhile "breaking to outer loop") step, exit_loop s1, Break (n-1))
      | Right (step, s1, Continue 1) -> Right (XSNested (XSWhile "continuing loop") step, s1, WhileCond c c body)
      | Right (step, s1, Continue n) -> Right (XSNested (XSWhile "continuing to outer loop") step, exit_loop s1, Continue (n-1))
      | Right (_step, s1, Done) ->
          match get_last_exit_code s1 with
          | Just 0 -> Right (XSWhile "exit code was 0, running the loop body", s1, WhileRunning c body body)
          | Just _ -> Right (XSWhile "exit code was non-zero, taking the false branch", exit_loop s1, Done)
          | Nothing -> Left (XSWhile "unset or symbolic exit code", s1)
          end
      | Right (step, s1, cur') -> Right (XSNested (XSWhile "") step, s1, WhileCond c cur' body)
      end
  | WhileRunning c body cur ->
      match step_eval s0 cur with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (XSNested (XSWhile "exiting") step, s1, Exit)
      | Right (step, s1, Return) -> Right (XSNested (XSWhile "returning") step, s1, Return) 
      | Right (step, s1, Break 1) -> Right (XSNested (XSWhile "breaking loop") step, exit_loop s1, Done)
      | Right (step, s1, Break n) -> Right (XSNested (XSWhile "breaking to outer loop") step, exit_loop s1, Break (n-1))
      | Right (step, s1, Continue 1) -> Right (XSNested (XSWhile "continuing loop") step, s1, WhileCond c c body)
      | Right (step, s1, Continue n) -> Right (XSNested (XSWhile "continuing to outer loop") step, exit_loop s1, Continue (n-1))
      | Right (step, s1, Done) -> Right (XSNested (XSWhile "finished iteration of while loop; retesting condition") step, s1, WhileCond c c body)
      | Right (step, s1, cur') -> Right (XSNested (XSWhile "") step, s1, WhileRunning c body cur')
      end

  (* FOR **********************************************************************)
  | For var ws body -> Right (XSFor "begin arg expansion", s0, ForExpArgs var (ExpStart ws) body)
  | ForExpArgs var exp_state body ->
      let (step, os1, st1) = step_expansion (s0, exp_state) in
      match st1 with
        | ExpError err ->
           let msg = string_of_symbolic_string (symbolic_string_of_fields err) in
           Right (XSFor "error in argument expansion",
                  fail_with msg os1,
                  Done)
        | ExpDone f ->
           Right (XSFor "arguments fully expanded",
                  os1,
                  ForExpanded var f body)
        | (_ as in_progress) ->
           Right (XSExpand (XSFor "argument expansion step") step,
                  os1,
                  ForExpArgs var in_progress body)
      end
  (* FOR: Special case, no items exit status is zero **************************)
  | ForExpanded _var [] _body ->
     Right (XSFor "no items, exit code is 0", 
            exit_with 0 s0, 
            Done)
  | ForExpanded var (i::f) body ->
     match set_param var i s0 with
     | Left err -> Left (XSFor err, s0)
     | Right s1 ->
        let s2 = enter_loop s1 in
        Right 
          (XSFor ("starting for loop with " ^ var ^ " = " ^ (string_of_symbolic_string i)),
           s2, 
           ForRunning var f body body)
     end
  | ForRunning var f body cur ->
      match step_eval s0 cur with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (XSNested (XSFor "exiting") step, s1, Exit)
      | Right (step, s1, Return) -> Right (XSNested (XSFor "returning") step, s1, Return)
      | Right (step, s1, Break 1) -> Right (XSNested (XSFor "breaking loop") step, exit_loop s1, Done)
      | Right (step, s1, Break n) -> Right (XSNested (XSFor "breaking to outer loop") step, exit_loop s1, Break (n-1))
      | Right (step, s1, Continue 1) ->
          match f with
          | [] -> Right (XSNested (XSFor "continued at last iteration") step, exit_loop s1, Done)
          | (i::f') -> Right (XSNested (XSFor ("continuing to next iteration with " ^ var ^ " = " ^ string_of_symbolic_string i)) step,
                              (* if the var name was good the first time, it's still good *)
                              internal_set_param var i s1,
                              ForRunning var f' body body)
          end
      | Right (step, s1, Continue n) -> Right (XSNested (XSFor "continuing to outer loop") step, s1, Continue (n-1))
      | Right (step, s1, Done) ->
          match f with
          | [] -> Right (XSNested (XSFor "finished last iteration") step, exit_loop s1, Done)
          | (i::f') -> Right (XSNested (XSFor ("starting next iteration with " ^ var ^ " = " ^ string_of_symbolic_string i)) step,
                              internal_set_param var i s1,
                              ForRunning var f' body body)
          end
      | Right (step, s1, cur') -> Right (XSNested (XSFor "") step, s1, ForRunning var f body cur')
      end

  (* CASE *********************************************************************)
  | Case ws cases -> Right (XSCase "begin arg expansion", s0, CaseExpArg (ExpStart ws) cases)
  | CaseExpArg exp_state cases ->
      let (step, os1, st1) = step_expansion (s0, exp_state) in
      match st1 with
        | ExpError err ->
           let msg = string_of_symbolic_string (symbolic_string_of_fields err) in
           Right (XSCase "error in argument expansion",
                  fail_with msg os1,
                  Done)
        | ExpDone [f] ->
           Right (XSCase "argument fully expanded", os1, CaseMatch f cases)
        | ExpDone _ ->
           Left (XSCase "case match element did not expand to a single field", s0)
        | (_ as in_progress) ->
           Right(XSExpand (XSCase "argument expansion step") step,
                 os1,
                 CaseExpArg in_progress cases)
      end
  | CaseMatch f cases ->
      match cases with
        | [] -> Right (XSCase "no match in case statement", s0, Done)
        | ([], _cmd)::cases' ->
           Right (XSCase "exhausted patterns, checking next case",
                  s0,
                  CaseMatch f cases')
        | (pat::pats', cmd)::cases' ->
           Right (XSCase "checking pattern match",
                  s0,
                  CaseCheckMatch f (ExpStart pat) cmd ((pats',cmd)::cases'))
      end
  | CaseCheckMatch f pat cmd cases ->
      let (step, os1, st1) = step_expansion (s0, pat) in
      match st1 with
        | ExpError err ->
           let msg = string_of_symbolic_string (symbolic_string_of_fields err) in
           Right (XSCase "error in argument expansion",
                  fail_with msg os1,
                  Done)
        | ExpDone [pat'] ->
          (* TODO 2018-08-29 use proper locale *)
          match match_prefix lc_ambient Exact pat' f with
          | NoMatch -> Right (XSCase "case did not match, trying the next",
                              os1, CaseMatch f cases)
          | Match _ -> Right (XSCase "case matched, evaluating cmd",
                              os1, cmd)
          | Symbolic -> Left (XSCase "case on symbolic value, gave up", os1)
          end
        | ExpDone _ -> Left (XSCase "case match pattern did not expand to a single field", os1)
        | (_ as in_progress) ->
           Right(XSExpand (XSCase "pattern expansion step") step,
                 os1,
                 CaseCheckMatch f in_progress cmd cases)
      end

  (* DEFUN ********************************************************************)
  | Defun name body -> 
     if is_special_builtin name
     then Left (XSDefun ("invalid function name " ^ name ^ " (shadows special built-in)"), s0)
     else Right (XSDefun ("defined " ^ name), defun name body s0, Done)

  (* CALL *********************************************************************)
  | Call old_loop_nest old_positional_params f orig c ->
     match step_eval s0 c with
     | Left e -> Left e
     | Right (step, s1, Done) ->
        Right (XSStack (f ^ ": implicit return") step,
               set_function_params old_loop_nest old_positional_params s1,
               Done)
     | Right (step, s1, Return) ->
        Right (XSStack (f ^ ": explicit return") step,
               set_function_params old_loop_nest old_positional_params s1,
               Done)
     | Right (step, s1, Exit) ->
        Right (XSStack (f ^ ": exit") step,
               set_function_params old_loop_nest old_positional_params s1,
               Exit)
     (* what do we do if there's a break or continue in a call? 
        
        break/continue don't seem to ever be lexically enclosed in a loop, so behavior is unspecified.
        bash supports "non local break", dash doesn't:

          $ brk() { break 5; echo post; }        
          $ while true; do brk; done 

        dash diverges, printing post
        bash breaks immediately, no printing

        following dash is tricky: 
        wherever there's a break, you have look at loop_nest.
        when i refactor step_eval to treat terminating control differently, we'll be made.
        for now, we'll follow bash.
      *)
     | Right (step, s1, Break n) ->
        Right (XSStack (f ^ ": break [unspecified behavior]") step,
               set_function_params old_loop_nest old_positional_params s1,
               Break n)
     | Right (step, s1, Continue n) ->
        Right (XSStack (f ^ ": continue [unspecified behavior]") step,
               set_function_params old_loop_nest old_positional_params s1,
               Continue n)
     | Right (step, s1, c') ->
        Right (XSStack f step,
               s1,
               Call old_loop_nest old_positional_params f orig c')
     end

  (* WAIT *********************************************************************)
  | Wait n -> 
     match waitpid step_eval s0 n with
     | (s1, Nothing) -> 
        Right (XSWait ("couldn't step process with pid " ^ stringFromNat n), 
               write_stderr ("wait: pid " ^ stringFromNat n ^ " is not a child of this shell") s1, 
               Done)
     | (s1, Just (Left step)) ->
        Right (XSNested (XSWait ("process with pid " ^ stringFromNat n ^ " stepped")) 
                        step,
               s1,
               Wait n)
     | (s1, Just (Right code)) ->
        Right (XSWait ("process with pid " ^ stringFromNat n ^ " completed"),
               exit_with code s1,
               Done)
     end            

  (* PUSHREDIR ****************************************************************)
  | Pushredir c saved_fds ->
     if is_terminating_control c
     then Right (XSRedir "popping redirects", 
                 restore_fds s0 saved_fds, 
                 c)
     else match step_eval s0 c with
          | Left e -> Left e
          | Right (step, s1, c') -> 
             Right (XSNested (XSRedir "") step, 
                    s1, 
                    Pushredir c' saved_fds)
          end

  (* BREAK/CONTINUE/RETURN/EXIT/DONE ******************************************)
  | Break _n -> Right (XSSimple "break bottomed out", s0, Done)
  | Continue _n -> Right (XSSimple "continue bottomed out", s0, Done)
  | Return -> Right (XSSimple "return bottomed out", s0, Done)
  | Exit -> 
     (* TODO 2018-03-02 handle traps *)
     Right (XSSimple "exited", s0, Done)
  | Done -> Right (XSSimple "", s0, Done)
  end

(* Evaluation **********************************************************)

and full_evaluation os0 stmt0 =
  match stmt0 with
  | Done -> os0
  | _ -> match step_eval os0 stmt0 with
         | Right (_step, os1, stmt1) -> full_evaluation os1 stmt1
         | Left (_step, os1) -> os1
         end
  end

and eval os0 stmt0 =
  let os1 = full_evaluation os0 stmt0 in
  match get_last_exit_code os1 with
  | Nothing -> 255 (* symbolic or missing exit code *)
  | Just n -> n
  end

(**********************************************************************)   
(* TRACING ************************************************************)   
(**********************************************************************)   
(* These functions are for testing and the expansion tool. *)

(* Expansion **********************************************************)
   
val run_trace_expansion : nat -> symbolic_os_state * expansion_state -> list (expansion_step * symbolic_os_state * expansion_state)
let rec run_trace_expansion gas (os0,st0) =
  if gas <= 0
  then [(ESStep "out of gas",os0,st0)]
  else match st0 with
  | ExpError _ -> []
  | ExpDone _ -> []
  | _ -> 
     let (step,os1,st1) = step_expansion (os0,st0) in
     (step,os1,st1)::run_trace_expansion (gas-1) (os1,st1)
  end
  
val trace_expansion : nat -> symbolic_os_state -> words -> list (expansion_step * symbolic_os_state * expansion_state)
let trace_expansion gas os0 w0 = 
  (ESStep "",os0,ExpStart w0)::run_trace_expansion gas (os0, ExpStart w0)

(* unbounded functions for testing final expansion results (used in
   test_expansion.ml)

   this function is a little unfaithful to the expansion semantics
   because we're not keeping track of whether the result was a message
   printed to stderr or the actual result of expansion
 *)
val run_trace_expansion_unbounded : symbolic_os_state * expansion_state -> list (expansion_step * symbolic_os_state * expansion_state)
let rec run_trace_expansion_unbounded (os0,st0) =
  match st0 with
  | ExpError _ -> []
  | ExpDone _ -> []
  | _ -> 
     let (step,os1,st1) = step_expansion (os0,st0) in
     (step,os1,st1)::run_trace_expansion_unbounded (os1,st1)
  end

val trace_expansion_unbounded : symbolic_os_state -> words -> list (expansion_step * symbolic_os_state * expansion_state)
let trace_expansion_unbounded os0 w0 = 
  (ESStep "",os0,ExpStart w0)::run_trace_expansion_unbounded (os0, ExpStart w0)

val full_expansion : symbolic_os_state -> words -> symbolic_os_state * fields
let full_expansion s0 w0 =
  let (_,s1,f1) = last (trace_expansion_unbounded s0 w0) in
  match f1 with
  | ExpError f -> (s1, f)
  | ExpDone f -> (s1, f)
  | _ -> (s1, [symbolic_string_of_string "!!! broken invariant"])
  end
   
val run_trace_evaluation : nat -> symbolic_os_state -> stmt -> list (evaluation_step * symbolic_os_state * stmt)
let rec run_trace_evaluation gas os0 stmt0 =
  if gas <= 0
  then [(XSStep "out of gas",os0,stmt0)]
  else match stmt0 with
  | Done -> []
  | _ ->
      match step_eval os0 stmt0 with
      | Right (step, os1, stmt1) -> (step, os1, stmt1)::run_trace_evaluation (gas-1) os1 stmt1
      | Left (step, os1) -> [(step, os1, Done)]
      end
  end

val trace_evaluation : nat -> symbolic_os_state -> stmt -> list (evaluation_step * symbolic_os_state * stmt)
let trace_evaluation gas os0 stmt0 = (XSStep "",os0,stmt0)::run_trace_evaluation gas os0 stmt0

(* TODO 2018-03-30 cleverer use of gas/limit number of commands *)
val trace_evaluation_multi : nat -> symbolic_os_state -> list stmt -> list (evaluation_step * symbolic_os_state * stmt)
let rec trace_evaluation_multi gas os0 stmts =
  match stmts with
  | [] -> []
  | (stmt::stmts') -> 
     let trace = trace_evaluation gas os0 stmt in
     let (_,os1,_) = last trace in
     trace ++ trace_evaluation_multi (gas-1) os1 stmts'
end
  
val full_evaluation_multi : symbolic_os_state -> list stmt -> symbolic_os_state
let rec full_evaluation_multi os0 stmts =
  match stmts with
  | [] -> os0
  | (stmt::stmts') -> full_evaluation_multi (full_evaluation os0 stmt) stmts'
  end

(* convenience function for shell *)
val real_eval : real_os_state -> stmt -> real_os_state
let real_eval os c = full_evaluation os c

(**********************************************************************)   
(* PROPERTIES *********************************************************)   
(**********************************************************************)   

lemma normal_expands_to_string : forall s0 x qm. exists s. expand_param s0 qm x Normal = [S s]
