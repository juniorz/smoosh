open import Fsh

open import Arith
open import Pattern
open import Path
open import Command

import Debug

(**********************************************************************)   
(* SHARED DECLARATIONS FOR EXPANSION AND EVALUATION *******************)   
(**********************************************************************)   

type string_mode =
    UserString
  | GeneratedString

type quoting_mode =
    Unquoted
  | Quoted

type redir_exp_result 'a =
    REDone of 'a * expanded_redir
  | REError of fields
  | REStep of expansion_step * 'a * expanding_redir

val expand_control : forall 'a. OS 'a => 
                     'a -> quoting_mode -> control ->
                     either (expansion_step * 'a * expanded_words) 
                            (expansion_step * 'a * expanded_words * words) 
val expand_words : forall 'a. OS 'a => 
                   'a -> quoting_mode -> string_mode -> (expanded_words * words) ->
                   either (expansion_step * 'a * expanded_words) 
                          (expansion_step * 'a * expanded_words * words) 
val step_expansion : forall 'a. OS 'a =>
                     'a * expansion_state -> 
                     expansion_step * 'a * expansion_state 
val step_redir : forall 'a. OS 'a =>
                     'a -> expanding_redir -> 
                     redir_exp_result 'a
val step_assign : forall 'a. OS 'a => 
                  'a -> list (string * expansion_state) ->
                  either ('a * list (string * fields)) (* Done state *)
                         (evaluation_step * 'a * list (string * expansion_state)) 

val step_eval : forall 'a. OS 'a =>
                'a -> stmt -> 
                either (evaluation_step * 'a) (* error case *)
                       (evaluation_step * 'a * stmt) (* success *)

val full_evaluation : forall 'a. OS 'a => 'a -> stmt -> 'a
val eval : forall 'a. OS 'a => 'a -> stmt -> nat

(**********************************************************************)   
(* LATE STAGE EXPANSION ***********************************************)   
(**********************************************************************)
(* These functions are kept out of the recursive knot of
   expansion/evaluation, just to keep the file simple. Unfortunately,
   that means they show up first, out of logical order. Sorry! *)
   
(*
 * Stage 2 Expansion: Field Splitting
 *)

val is_ws : char -> bool
val collect_non_ifs : list char -> list char -> (list char) * (list char)
(*val collect_ifs_whitespace : list char -> list char -> list char*)
val split_expstring : list char -> list char -> intermediate_fields
val split_word : list char -> (intermediate_fields * expanded_words) -> (intermediate_fields * expanded_words)
val split_fields : forall 'a. OS 'a => 'a -> expanded_words -> intermediate_fields
val clean_fields : intermediate_fields -> intermediate_fields
val field_splitting : forall 'a. OS 'a => 'a -> expanded_words -> intermediate_fields  
  
let is_ws c = elem c (toCharList " \n\t")
           
let rec collect_non_ifs ifs ls =
  match ls with
  | [] -> ([], [])
  | (c::cs) ->
      if elem c ifs
      then ([], c::cs)
      else let (f, remaining) = collect_non_ifs ifs cs in
           (c::f, remaining)
  end

let rec split_expstring ifs clst =
   match clst with
   | [] -> []
   | c::cs ->
       if elem c ifs
       then let fs = if is_ws c then WFS else FS 
            in fs::split_expstring ifs cs
       else let (cc, cs1) = collect_non_ifs ifs cs in 
            (Field (symbolic_string_of_char_list (c::cc)))::(split_expstring ifs cs1)
  end

let rec split_word ifs p =
  match p with
  | (f, []) -> (f, [])
  | (f, UsrF::wrds) -> split_word ifs (f ++ [FS], wrds)
  | (f, ExpS(s)::wrds) ->
      let new_fields = split_expstring ifs (toCharList s) in
      split_word ifs (f ++ new_fields, wrds)
  | (f, UsrS(s)::wrds) -> split_word ifs (f ++ [Field (symbolic_string_of_string s)], wrds)
  | (f, DQuo(ss)::wrds) -> split_word ifs (f ++ [QField ss], wrds)
  | (f, EWSym sym::wrds) -> split_word ifs (f ++ [Field [Sym sym]], wrds)
  end

let split_fields s0 exp_words =
  let ifs = lookup_param s0 "IFS" in
  let (f, _) = match ifs with
    | Nothing -> split_word (toCharList " \n\t") ([], exp_words)
    | Just fs -> 
       match try_concrete fs with
       | Nothing -> (* TODO symbolic, a symbolic IFS makes it nearly-impossible to model field splitting *)
          split_word (toCharList " \n\t") ([], exp_words)
       | Just "" -> ([Field (concat_expanded exp_words)], [])
       | Just s -> split_word (toCharList s) ([], exp_words)
       end
  end in f

let rec combine_fields f =
  match f with
  | [] -> []
  | [WFS] -> [] (* Remove trailing field separators *)
  | (WFS::WFS::rst) -> combine_fields (WFS::rst) (* Combine adjacent whitespace separators *)
  | (WFS::FS::rst) -> combine_fields (FS::rst)
  | (FS::WFS::rst) -> combine_fields (FS::rst)
  | (Field(s1)::Field(s2)::rst) -> combine_fields (Field(s1 ++ s2)::rst)
  | (WFS::rst) -> FS::(combine_fields rst)
  | (f::rst) -> f::(combine_fields rst)
  end

let rec clean_fields f =
  match f with
  | (WFS::rst) -> clean_fields rst
  | _ -> combine_fields f
  end

let field_splitting s0 w = clean_fields (split_fields s0 w)

(*
 * Stage 3 Expansion: Pathname expansion
 *)

val insert_field_separators : list string -> intermediate_fields
let rec insert_field_separators fs =
  match fs with
  | [] -> []
  | [f] -> [Field (symbolic_string_of_string f)]
  | f::fs' -> Field (symbolic_string_of_string f)::FS::insert_field_separators fs'
  end

val pathname_expansion : forall 'a. OS 'a => 'a -> intermediate_fields -> intermediate_fields

(* Parameter expansion only happens on unquoted fields *)
let rec pathname_expansion s0 f =
  match f with
  | [] -> []
  | (Field(s)::rst) -> 
     let matches = 
       match try_concrete s with
       | Just pat -> match_path s0 pat
       | Nothing -> [] (* slightly inaccurate: we're not modeling symbolic pathname expansions *)
       end 
     in
     let expansions = 
       if null matches 
       then [Field s] 
       else insert_field_separators matches 
     in
     expansions ++ pathname_expansion s0 rst
  | (f::rst) -> f::(pathname_expansion s0 rst)
  end

(*
 * Stage 4 Expansion: Quote Removal
 *)

val remove_quotes : intermediate_fields -> intermediate_fields
val to_fields : intermediate_fields -> fields
val finalize_fields : intermediate_fields -> fields
val quote_removal : intermediate_fields -> fields

let rec remove_quotes f =
  match f with
  | [] -> []
  | (QField(s)::rst) -> Field(s)::(remove_quotes rst)
  | (f::rst) -> f::(remove_quotes rst)
  end

let rec to_fields f =
  match f with
  | []           -> []
  | FS::FS::rst  -> (symbolic_string_of_string "")::(to_fields rst)
  | Field fs::rst -> 
     fs::(to_fields rst)
  | FS::rst      -> to_fields rst
  (* TODO 2017-12-01 Preferably we need an AST that doesn't have WFS or QField's at this point, or lem failure *)
  | WFS::_       -> [symbolic_string_of_string "broken invariant"]
  | QField _::_  -> [symbolic_string_of_string "broken invariant"]
  end

let rec finalize_fields f =
  match f with
  | (FS::rst) -> symbolic_string_of_string ""::finalize_fields rst
  | _ -> to_fields f
  end

let quote_removal f =
  let no_quotes = combine_fields (remove_quotes f) in
  finalize_fields no_quotes

(**********************************************************************)   
(* EXPANSION **********************************************************)   
(**********************************************************************)   
   
(*
 * Stage 1 Expansion: Word expansion
 *)

val expand_param : forall 'a. OS 'a => 'a -> quoting_mode -> string -> format -> words
(* Runs expansion all the way, for testing purposes only *)
val control_code_expansion : forall 'a. OS 'a => 'a -> quoting_mode -> words -> ('a * expanded_words)

let match_substring (lc:locale) (side:substring_side) (mode:substring_mode) (pat:expanded_words) (str:fields) : symbolic_string =
  let sympat : symbolic_string = (concat_expanded pat) in
  let symstr : symbolic_string = symbolic_string_of_fields str in
  try_match_prefix lc side mode sympat symstr

(* TODO 2017-12-01
 * In an N____ case, when null_string fs is Nothing, the
 * string is entirely symbolic so we need
 * to represent the symbolic result of "it could be either
 * true or false, we don't know". This means we need to branch
 * and allow for both cases to progress.
 *)
let expand_param s0 _q str f =
  let value = lookup_param s0 str in
  match (value, f) with
  (* NORMAL *)
  | (Nothing, Normal)     -> [S ""] (* null *)
  | (Just fs, Normal)     -> words_of_symbolic_string fs
  (* DEFAULT *)
  | (Nothing, Default w)  -> w
  | (Just fs, Default _)  -> words_of_symbolic_string fs
  | (Nothing, NDefault w) -> w
  | (Just fs, NDefault w) ->
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> w
     | Just false -> words_of_symbolic_string fs
     end
  (* ASSIGN *)
  | (Nothing, Assign w)  -> [K (LAssign str [] w)]
  | (Just fs, Assign _)  -> words_of_symbolic_string fs       
  | (Nothing, NAssign w) -> [K (LAssign str [] w)]
  | (Just fs, NAssign w) -> 
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> [K (LAssign str [] w)]
     | Just false -> words_of_symbolic_string fs
     end
  (* ERROR *)
  | (Nothing, Error w)  -> [K (LError str [] w)]
  | (Just fs, Error _)  -> words_of_symbolic_string fs
  | (Nothing, NError w) -> [K (LError str [] w)]
  | (Just fs, NError w) -> 
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> [K (LError str [] w)]
     | Just false -> words_of_symbolic_string fs
     end
  (* LENGTH *)
  | (Nothing, Length) -> [S "0"]
  | (Just fs, Length) ->
     match try_concrete fs with
     | Nothing -> (* TODO This should be the length of the symbolic result of fs *) [S "0"]
     | Just strs -> [S (show (stringLength strs))]
     end
  (* ALT *)
  | (Nothing, Alt _)  -> [S ""]
  | (Just _, Alt w)  -> w
  | (Nothing, NAlt _) -> [S ""]
  | (Just fs, NAlt w) ->
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> [S ""]
     | Just false -> w
     end
  (* SUBTRINGS (prefix/suffix) *)
  | (Nothing, Substring _ _ _) -> [S ""]
  | (Just fs, Substring s m w) -> [K (LMatch [fs] s m [] w)]
  end

let rec expand_control s0 q k =
    match k with
    | Tilde ->
       let (msg, dir) = match expand_param s0 Unquoted "HOME" Normal with
         (* if HOME is unset, results are unspecified---we return "~" 
            dash:
              $ unset HOME
              $ echo ~
              ~
              $ HOME=""
              $ echo ~
              ~
              $ HOME="/Users/mgree"
              $ echo ~
              /Users/mgree

            bash:
              $ unset HOME
              $ echo ~
              /Users/mgree
              $ HOME=""
              $ echo ~
              
              $ HOME="/Users/mgree"
              $ echo ~
              /Users/mgree            

            lol
          *)
         | [S ""] -> ("defaulting to dash behavior for unset HOME (unspec per 2.6.1)", [S "~"])
         | dir -> ("", dir)
         end in
       Right (ESTilde msg, s0, [], dir)
    | TildeUser usr -> 
       match getpwnam s0 usr with
       | Nothing -> Right (ESTilde "defaulting to dash behavior for failed getpwnam (unspec per 2.6.1)", s0, [], [S ("~" ^ usr)]) (* unspec per 2.6.1, but we follow dash *)
       | Just path -> Right (ESTilde "", s0, [], [S path])
       end
    | Param s f -> expand_words s0 q GeneratedString ([], expand_param s0 q s f)
    | LAssign s f [] ->
        let s1 = set_param s (concat_expanded f) s0 in
        Right (ESParam "finished assignment", s1, f, [])
    | LAssign s f w ->
       match expand_words s0 q GeneratedString ([], w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESParam "assignment") step, s1, [], [K (LAssign s (f ++ f1) w1)])
       | Left err -> Left err
       end
    | LMatch str side mode f [] -> Right (ESParam "finished match", s0, [], words_of_symbolic_string (match_substring (get_shell_state s0).locale side mode f str))
    | LMatch s side mode f w ->
       match expand_words s0 q GeneratedString ([], w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESParam "match") step, s1, [], [K (LMatch s side mode (f ++ f1) w1)])
       | Left err -> Left err
       end
    | LError str f [] -> Left (ESParam "raising requested error", s0, ExpS (str ^ ": ")::f) (* dash seems to print erroring variable name; TODO should we also have linno? *)
    | LError str f w ->
       match expand_words s0 q GeneratedString ([], w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESParam "error") step, s1, [], [K (LError str (f ++ f1) w1)])
       | Left err -> Left err
       end
    | Backtick c ->
       Right (ESCommand "initializing subshell", s0, [], [K (LBacktick (get_shell_state s0) c c)]) (* TODO should set up pipes *)
    | LBacktick subsh corig c0 ->
       match step_eval (set_shell_state subsh s0) c0 with
       (* When a subshell errors, it should evaluate to the null string and print its error message. *)
       | Left (step, s1) -> Right (ESEval (ESCommand "command exited with error") step, set_shell_state (get_shell_state s0) s1, [], [])
       (* The shell shall expand the command substitution by executing
          command in a subshell environment (see Shell Execution
          Environment) and replacing the command substitution (the text
          of command plus the enclosing "$()" or backquotes) with the
          standard output of the command, removing sequences of one or
          more <newline>s at the end of the substitution POSIX 2.6.3 
 
          TODO 2017-12-22 read result from pipe, trim newlines
        *) 
       | Right (step, s1, Done) -> Right (ESEval (ESCommand "command exited successfully; returning symbolic result") step, set_shell_state (get_shell_state s0) s1, [EWSym (SymCommand corig)], [])
       | Right (step, s1, c1) -> Right (ESEval (ESCommand "") step, set_shell_state (get_shell_state s0) s1, [], [K (LBacktick (get_shell_state s1) corig c1)])
       end
    | Arith f [] ->
        match arith64 s0 (concat_expanded f) with
        | Right (s1, result) -> Right (ESArith "computed arithmetic result", s1, expanded_words_of_fields result, [])
        | Left e -> Left (ESArith "arithmetic error", s0, [ExpS e])
        end
    | Arith f w ->
       match expand_words s0 q GeneratedString ([],w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESArith "before arithmetic parsing") step, s1, [], [K (Arith (f ++ f1) w1)])
       | Left err -> Left err
        end
   | Quote f [] ->
      Right (ESQuote "finished quote expansion", s0, [DQuo (concat_expanded f)], [])
   | Quote f w -> 
       match expand_words s0 Quoted GeneratedString ([],w) with
       | Right (step, s1, f1, w1) -> Right (step, s1, [], [K (Quote (f ++ f1) w1)])
       | Left err -> Left err
       end
  end

and expand_words s0 q sm (f,w) =
  match w with
    | [] -> Right (ESStep "done", s0, f, w)
    | (F::ws) -> Right (ESStep "user field separator", s0, f ++ [UsrF], ws)
    | (S(s)::ws) ->
       let f1 = match (q, sm) with
         | (Quoted, _) -> [DQuo (symbolic_string_of_string s)]
         | (Unquoted, UserString) -> [UsrS s]
         | (Unquoted, GeneratedString) -> [ExpS s]
       end in
        Right (ESStep "plain string", s0, f ++ f1, ws)
    | (K(k)::ws) ->
       match expand_control s0 q k with
       | Right (step, s1, f1, w1) -> Right (step, s1, f++f1, (w1 ++ ws))
       | Left err -> Left err
       end
    | (ESym(c)::ws) -> Right (ESStep "skipping symbolic result", s0, f ++ [EWSym c], ws)
  end

and control_code_expansion s0 q w =
  match expand_words s0 q UserString ([],w) with
  | Right (_step, s1, f1, w1) ->
     match w1 with
     | [] -> (s1, f1)
     | _ -> let (s2, f2) = control_code_expansion s1 q w1 in
            (s2, (f1 ++ f2))
     end
  | Left (_step, s1, err1) -> (s1, err1)
  end

(**********************************************************************)
(* EXPANSION TRANSITIONS **********************************************)
(**********************************************************************)

and step_expansion (os0,st) =
  match st with
  | ExpStart w0 -> 
     match expand_words os0 Unquoted UserString ([],w0) with
     | Right (step, os1, f1, w1) -> (step, os1, ExpExpand f1 w1)
     | Left (step, os1, f1) -> (step, os1, ExpError (fields_of_expanded_words f1))
     end
  | ExpExpand f0 w0 -> 
     match expand_words os0 Unquoted UserString (f0,w0) with
     | Right (step, os1, f1, w1) ->
        match w1 with
        | [] -> (step, os1, ExpSplit f1)
        | _ ->  (step, os1, ExpExpand f1 w1)
        end
     | Left (step, os1, f1) -> (step, os1, ExpError (fields_of_expanded_words f1))
     end
  | ExpSplit f0 -> (ESSplit "", os0, ExpPath (field_splitting os0 f0))
  | ExpPath ifs0 -> (ESPath "", os0, ExpQuote (pathname_expansion os0 ifs0))
  | ExpQuote ifs0 -> (ESQuote "", os0, ExpDone (quote_removal ifs0))
  (* the following cases should never occur in calls from trace_expansion: *)
  | ExpError _ -> (ESStep "done in error state", os0, st)
  | ExpDone _ -> (ESStep "done in success state", os0, st)
  end

(**********************************************************************)   
(* EVALUATION *********************************************************)   
(**********************************************************************)   
   
(* Steps an expanding_redir along *)
and step_redir os0 er =
  let exp_state = get_expanding_redir_state er in
  let (step, os1, st1) = step_expansion (os0, exp_state) in
  match st1 with
   | ExpError err -> REError err
   | ExpDone f -> REDone os1 (expand_redir er f)
   | ExpPath ifs ->
      (* "Pathname expansion shall not be performed on the word [that
         is the target of redirection] by a non-interactive shell; an
         interactive shell may perform it, but shall do so only when
         the expansion would result in one word."

        "If no part of word is quoted, all lines of the here-document
         shall be expanded for parameter expansion, command
         substitution, and arithmetic expansion."

         i.e., skipping pathname expansion. the dash parser should
         take care of a lot of this. 
       *)
      let (msg,es') = 
        if is_interactive os1 && not (is_heredoc er)
        then 
          let expanded = pathname_expansion os1 ifs in
          if length expanded = 1
          then ("performed pathname expansion in interactive shell",
                ExpQuote expanded)
          else ("skipped pathname expansion in interactive shell [produced " ^ 
                (stringFromNat (length expanded)) ^ " words]",
                ExpQuote ifs)
        else ("skipped pathname expansion", ExpQuote ifs)
      in
      REStep (ESPath msg) os1 (set_expanding_redir_state es' er)
   | _ -> REStep step os1 (set_expanding_redir_state st1 er)
   end

(* Steps the first, non-complete expansion_state and returns.
 * If it reached the base case, they are all complete, so
 *   we return the Left type to continue on the arg expansion. *)
and step_assign s0 assigns =
  match assigns with
  | [] -> Left (s0, [])
  | ((x, ExpError f) as error)::assigns' ->
    match step_assign s0 assigns' with
    | Right (step, s1, processed) -> Right (step, s1, error::processed)
    | Left (s1, completed) -> Left (s1, (x, f)::completed)
    end
  | ((x, ExpDone f) as finished)::assigns' ->
    match step_assign s0 assigns' with
    | Right (step, s1, processed) -> Right (step, s1, finished::processed)
    | Left (s1, completed) -> Left (s1, (x, f)::completed)
    end
  | (x, exp_state)::assigns' ->
    let (step, s1, next_state) = step_expansion (s0, exp_state) in
    Right (XSExpand (XSSimple x) step, s1, (x, next_state)::assigns')
  end

and step_eval s0 stmt =
  (* 
     extremely subtle behavior with errors in expansion:
       an expansion error is NOT a field
       expansion errors cancel the current command with a failing exit status

     $ count() { echo $# ; }
     $ count ${x?one two three}                            # never runs count
     /Users/mgree/fsh/dash/src/dash: 2: x: one two three
     $ count $(echo ${x?one two three})                    # subshell fails, but count will run!
     /Users/mgree/fsh/dash/src/dash: 2: x: one two three
     0
     $ count $(echo ${x?one two three} four)
     /Users/mgree/fsh/dash/src/dash: 3: x: one two three
     0
     $ count $(echo ${x?one two three}) four
     /Users/mgree/fsh/dash/src/dash: 4: x: one two three
     1
     $ count $(${x? one two three}) four
     /Users/mgree/fsh/dash/src/dash: 5: x:  one two three
  *)
  match stmt with
  (* 
When a given simple command is required to be executed (that is, when any conditional construct such as an AND-OR list or a case statement has not bypassed the simple command), the following expansions, assignments, and redirections shall all be performed from the beginning of the command text to the end:

The words that are recognized as variable assignments or redirections according to Shell Grammar Rules are saved for processing in steps 3 and 4.

The words that are not variable assignments or redirections shall be expanded. If any fields remain following their expansion, the first field shall be considered the command name and remaining fields are the arguments for the command.

Redirections shall be performed as described in Redirection.

Each variable assignment shall be expanded for tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal prior to assigning the value.

In the preceding list, the order of steps 3 and 4 may be reversed if no command name results from step 2 or if the command name matches the name of a special built-in utility; see Special Built-In Utilities.

Variable assignments shall be performed as follows:

If no command name results, variable assignments shall affect the current execution environment.

If the command name is not a special built-in utility or function, the variable assignments shall be exported for the execution environment of the command and shall not affect the current execution environment except as a side-effect of the expansions performed in step 4. In this case it is unspecified:

Whether or not the assignments are visible for subsequent expansions in step 4

Whether variable assignments made as side-effects of these expansions are visible for subsequent expansions in step 4, or in the current shell execution environment, or both

If the command name is a standard utility implemented as a function (see XBD Utility), the effect of variable assignments shall be as if the utility was not implemented as a function.

If the command name is a special built-in utility, variable assignments shall affect the current execution environment. Unless the set -a option is on (see set), it is unspecified:

Whether or not the variables gain the export attribute during the execution of the special built-in utility

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the special built-in utility

If the command name is a function that is not a standard utility implemented as a function, variable assignments shall affect the current execution environment during the execution of the function. It is unspecified:

Whether or not the variable assignments persist after the completion of the function

Whether or not the variables gain the export attribute during the execution of the function

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the function (if variable assignments persist after the completion of the function)

If any of the variable assignments attempt to assign a value to a variable for which the readonly attribute is set in the current shell environment (regardless of whether the assignment is made in that environment), a variable assignment error shall occur. See Consequences of Shell Errors for the consequences of these errors.

If there is no command name, any redirections shall be performed in a subshell environment; it is unspecified whether this subshell environment is the same one as that used for a command substitution within the command. (To affect the current execution environment, see the exec special built-in.) If any of the redirections performed in the current shell execution environment fail, the command shall immediately fail with an exit status greater than zero, and the shell shall write an error message indicating the failure. See Consequences of Shell Errors for the consequences of these failures on interactive and non-interactive shells.

If there is a command name, execution shall continue as described in Command Search and Execution [run_command]. If there is no command name, but the command contained a command substitution, the command shall complete with the exit status of the last command substitution performed. Otherwise, the command shall complete with a zero exit status.

TODO 2018-01-28 special builtins vs. simple builtins

but:

  y=${x=5} cmd
  - side-effects of expansion happen in CURRENT env, even if in an assignment for a command
  - cmd sees y (but not x, because x isn't set for export)
  - env sees x (but not y, less surprisingly)

  export x
  y=${x=5} cmd
  - side effects of expansion happen in CURRENT env
  - cmd sees x and y
  - env sees x

  y=${x=5}
  - side effects of expansion happen in CURRENT env
  - env sees x and y (just an assignment)

so: how do we implement it?
  it seems consistent to do all of the expansions in the CURRENT environment, regardless of the kind of command
    but don't set it in the environment yet
  each assignment sees the previous ones
    set manually each time... or manually use a local environment?

  decide at the end whether or not to publish to the current environment

*)
  | Command assigns ws redirs ->
     Right (XSSimple "begin expansion",
            s0,
            CommandExpAssign
              (map (fun (x, w) -> (x, ExpStart w)) assigns)
              ws
              redirs)

  (* SPECIAL CASE: plain assignment, no command *)
  | CommandExpAssign ((x,exp_state0)::assigns) [] redirs ->
     match step_expansion (s0, exp_state0)  with
     | (_step, s1, ExpDone f) -> Right (XSSimple ("assign " ^ x),
                                        set_param x (symbolic_string_of_fields f) s1, CommandExpAssign assigns [] redirs)
     | (step, s1, ExpError f) -> Right (XSExpand (XSSimple ("error in " ^ x ^ ": " ^ string_of_fields f)) step,
                                        s1, CommandExpAssign assigns [] redirs)
     | (step, s1, exp_state1) -> Right (XSExpand (XSSimple "") step,
                                        s1, CommandExpAssign ((x,exp_state1)::assigns) [] redirs)
     end
  | CommandExpAssign [] [] redirs ->
     (* keep on expanding, since we have to actually expand the redirects no matter what *)
     Right (XSSimple "assignments complete", s0, CommandExpRedirs [] [] [] Nothing redirs)

  (* GENERAL CASE: command with possible assignments, which no longer go in the general environment *)
  | CommandExpAssign assigns ws redirs ->
     match step_assign s0 assigns with
     (* Perform an expansion step in an assignment *)
     | Right (exp_step, s1, assigns') ->
        Right (exp_step,
               s1,
               CommandExpAssign assigns' ws redirs)
     (* Done, move on to expanding arguments *)
     | Left (s1, fields) ->
        Right (XSSimple "assignments fully expanded",
               s1,
               CommandExpArgs fields (ExpStart ws) redirs)
    end
  | CommandExpArgs assigns exp_state redirs ->
      let (step, s1, st1) = step_expansion (s0, exp_state) in
      match st1 with
        | ExpError err ->
           let msg = string_of_symbolic_string (symbolic_string_of_fields err) in
           Right (XSSimple "error in argument expansion",
                  exit_with 1 (write_stderr msg s1),
                  Done)
        | ExpDone f ->
           let msg = 
             show (length f) ^ " " ^ if length f = 1 then "argument" else "arguments" ^ 
             " fully expanded (including command)"
           in
           Right (XSExpand (XSSimple msg) step, 
                  s1, 
                  CommandExpRedirs assigns f [] Nothing redirs)
        | _ ->
           Right(XSExpand (XSSimple "argument expansion step") step,
                 s1,
                 CommandExpArgs assigns st1 redirs)
      end
  (* redirect expansion *)
  | CommandExpRedirs assigns args ers Nothing [] ->
     Right (XSSimple "done expanding redirects",
            s0,
            CommandExpanded assigns args ers)
  | CommandExpRedirs assigns args ers Nothing (r::redirs) ->
     let (msg, ers, exp_state) =
       match r with
       | RFile ty src w -> ("expanding file redirect", ers, Just (XRFile ty src (ExpStart w)))
       | RDup ty src tgt -> ("trivially expanded dup", ers ++ [ERDup ty src tgt], Nothing)
       | RHeredoc XHere src w -> 
          ("expanding unquoted heredoc", ers, Just (XRHeredoc XHere src (ExpStart w)))
       | RHeredoc Here src w -> 
          ("not expanding quoted heredoc", 
           ers ++ [ERHeredoc Here src [symbolic_string_of_string (string_of_words w)]], 
           Nothing)
       end
     in
     Right (XSSimple msg,
            s0,
            CommandExpRedirs assigns args ers exp_state redirs)
  | CommandExpRedirs assigns args ers (Just er) redirs ->
     match step_redir s0 er with
     | REError err ->
        let msg = string_of_symbolic_string (symbolic_string_of_fields err) in
        Right (XSSimple "error in redirect expansion",
               exit_with 1 (write_stderr msg s0),
               Done)
     | REDone os1 er' ->
        Right (XSSimple "expanded redirect",
               os1,
               CommandExpRedirs assigns args (ers ++ [er']) Nothing redirs)
     | REStep step os1 er' ->
        Right (XSExpand (XSSimple "redirection expansion step") step,
               os1,
               CommandExpRedirs assigns args ers (Just er') redirs)
     end
  (* expansion is done, try to run command *)
  | CommandExpanded assigns (prog::args) _redirs ->
     (* perform assignments *)
     let sh = get_shell_state s0 in
     let env = 
       foldr (fun (x,f) env' -> 
           Map.insert x (symbolic_string_of_fields f) env') 
         sh.env assigns
     in
     (* "If the command name is a special built-in utility, variable
        assignments shall affect the current execution environment."
        *)
     let s1 = 
       match try_concrete prog with
       | Just prog_name -> if is_special_builtin prog_name
                           then set_shell_state <| sh with env = env |> s0
                           else s0
       | Nothing -> s0 
       end in
     (* TODO 2018-02-09 setup redirects *)
     (* run command *)
     match run_command s1 prog args env with
     | Right (s2,stmt') -> 
        Right (XSSimple ("ran " ^ string_of_symbolic_string prog), 
               s2, 
               stmt')
     | Left (s2,msg) -> 
        Right (XSSimple "couldn't run command", 
               exit_with 1 (write_stderr msg s2), 
               Done)
     end
  | CommandExpanded _assigns [] _redirs ->
     (* TODO 2018-02-09 setup redirects for side effects/file creation

        e.g., unset x y ; x=5 >${y=3}
              will set x to 5, y to 3, and create an empty file named 3
      *)
     Right (XSSimple "ran empty command", s0, Done)
  | Pipe bg _stmts ->
     (* from dash/src/eval.c:
/*
 * Evaluate a pipeline.  All the processes in the pipeline are children
 * of the process creating the pipeline.  (This differs from some versions
 * of the shell, which make the last process in a pipeline the parent
 * of all the rest.)
 */

STATIC int
evalpipe(union node *n, int flags)
{
	struct job *jp;
	struct nodelist *lp;
	int pipelen;
	int prevfd;
	int pip[2];
	int status = 0;

	TRACE(("evalpipe(0x%lx) called\n", (long)n));
	pipelen = 0;
	for (lp = n->npipe.cmdlist ; lp ; lp = lp->next)
		pipelen++;
	flags |= EV_EXIT;
	INTOFF;
	jp = makejob(n, pipelen);
	prevfd = -1;
	for (lp = n->npipe.cmdlist ; lp ; lp = lp->next) {
		prehash(lp->n);
		pip[1] = -1;
		if (lp->next) {
			if (pipe(pip) < 0) {
				close(prevfd);
				sh_error("Pipe call failed");
			}
		}
		if (forkshell(jp, lp->n, n->npipe.backgnd) == 0) {
			INTON;
			if (pip[1] >= 0) {
				close(pip[0]);
			}
			if (prevfd > 0) {
			dup2(prevfd, 0);
				close(prevfd);
			}
			if (pip[1] > 1) {
				dup2(pip[1], 1);
				close(pip[1]);
			}
			evaltreenr(lp->n, flags);
			/* never returns */
		}
		if (prevfd >= 0)
			close(prevfd);
		prevfd = pip[0];
		close(pip[1]);
	}
	if (n->npipe.backgnd == 0) {
		status = waitforjob(jp);
		TRACE(("evalpipe:  job done exit status %d\n", status));
	}
	INTON;

	return status;
}
      *)
     (* TODO 2018-02-09 spawn each process with fds set appropriately 

        builds fds1 ... fdsn such that:

        stmt1   STDOUT |-> fifo1    in fds1
        stmt2   STDOUT |-> fifo2    in fds2
        ...
        stmtn-1 STDOUT |-> fifon-1  in fdsn-1
        stmtn uses ambient          in fdsn

        stmt1 uses ambient          in fds1
        stmt2   STDIN  |-> fifo1    in fds2
        stmt3   STDIN  |-> fifo2    in fds3
        ...
        stmtn   STDIN  |-> fifon-1  in fdsn

        then spawn each subshell appropriately
      *)     
     let last_pid = 0 in (* TODO 2018-03-02 use actual spawned pid *)
     Right (XSPipe "started pipe",s0,if bg then Done else Wait last_pid)
  | Redir _stmt' _redirs ->
     (* TODO 2018-03-12 Pathname expansion shall not be performed on
        the word [that is the target of redirection] by a
        non-interactive shell; an interactive shell may perform it,
        but shall do so only when the expansion would result in one
        word.         
     *)    
     Left (XSRedir "TODO", s0)
  | Background stmt' _redirs -> 
     (* TODO 2018-08-15 set up redirs *)
     let (s1,pid) = fork_and_subshell eval s0 stmt' in
     let s2 = set_last_pid pid s1 in
     Right (XSBackground ("started background process with pid " ^ (stringFromNat pid)), 
            s2, 
            Done)
  | Subshell stmt' _redirs ->
     (* TODO 2018-08-15 set up redirs *)
     let (s1,pid) = fork_and_subshell eval s0 stmt' in
     Right (XSSubshell ("started subshell with pid " ^ stringFromNat pid), 
            s1, 
            Wait pid)
  | And l r ->
      match step_eval s0 l with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (step, s1, Exit)
      | Right (step, s1, Return) -> Right (step, s1, Return)
      | Right (step, s1, Break n) -> Right (step, s1, Break n)
      | Right (step, s1, Continue n) -> Right (step, s1, Continue n)
      | Right (_step, s1, Done) ->
          match get_last_exit_code s1 with
          | Just 0 -> Right (XSAnd "exit code was 0, continuing", s1, r)
          | Just _ -> Right (XSAnd "exit code was non-zero, short-circuiting", s1, Done)
          | Nothing -> Left (XSAnd "unset or symbolic exit code", s1)
          end
      | Right (step, s1, l') -> Right (XSNested (XSAnd "") step, s1, And l' r)
      end
  | Or l r ->
      match step_eval s0 l with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (step, s1, Exit)
      | Right (step, s1, Return) -> Right (step, s1, Return)
      | Right (step, s1, Break n) -> Right (step, s1, Break n)
      | Right (step, s1, Continue n) -> Right (step, s1, Continue n)
      | Right (_step, s1, Done) ->
          match get_last_exit_code s1 with
          | Just 0 -> Right (XSOr "exit code was 0, short-circuiting", s1, Done)
          | Just _ -> Right (XSOr "exit code was non-zero, continuing", s1, r)
          | Nothing -> Left (XSOr "unset or symbolic exit code", s1)
          end
      | Right (step, s1, l') -> Right (XSNested (XSOr "") step, s1, Or l' r)
      end
  | Not stmt' ->
      match step_eval s0 stmt' with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (step, s1, Exit)
      | Right (step, s1, Return) -> Right (step, s1, Return)
      | Right (step, s1, Break n) -> Right (step, s1, Break n)
      | Right (step, s1, Continue n) -> Right (step, s1, Continue n)
      | Right (_step, s1, Done) ->
          match get_last_exit_code s1 with
          | Just 0 -> 
             Right (XSNot "0 -> 1", set_param "?" (symbolic_string_of_string "1") s1, Done)
          | Just _ -> 
             Right ((XSNot "_ -> 0"), set_param "?" (symbolic_string_of_string "0") s1, Done)
          | Nothing -> Left (XSNot "unset or symbolic exit code", s1)
          end
      | Right (step, s1, stmt'') -> Right (XSNested (XSNot "") step, s1, Not stmt'')
      end
  | Semi l r ->
      match step_eval s0 l with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (step, s1, Exit)
      | Right (step, s1, Return) -> Right (step, s1, Return)
      | Right (step, s1, Break n) -> Right (step, s1, Break n)
      | Right (step, s1, Continue n) -> Right (step, s1, Continue n)
      | Right (step, s1, Done) -> Right (XSNested (XSSemi "done with LHS") step, s1, r)
      | Right (step, s1, l') -> Right (XSNested (XSSemi "") step, s1, Semi l' r)
      end
  | If c t e ->
      match step_eval s0 c with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (step, s1, Exit)
      | Right (step, s1, Return) -> Right (step, s1, Return)
      | Right (step, s1, Break n) -> Right (step, s1, Break n)
      | Right (step, s1, Continue n) -> Right (step, s1, Continue n)
      | Right (_step, s1, Done) ->
          match get_last_exit_code s1 with
          | Just 0 -> Right (XSIf "exit code was 0, taking the true branch", s1, t)
          | Just _ -> Right (XSIf "exit code was non-zero, taking the false branch", s1, e)
          | Nothing -> Left (XSIf "unset or symbolic exit code", s1)
          end
      | Right (step, s1, c') -> Right (XSNested (XSIf "") step, s1, If c' t e)
      end
  | While c body -> Right (XSWhile "start to evaluate the condtion", enter_loop s0, WhileCond c c body)
  | WhileCond c cur body ->
      match step_eval s0 cur with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (XSNested (XSWhile "exiting") step, s1, Exit)                                      
      | Right (step, s1, Return) -> Right (XSNested (XSWhile "returning") step, s1, Return)
      | Right (step, s1, Break 1) -> Right (XSNested (XSWhile "breaking") step, exit_loop s1, Done)
      | Right (step, s1, Break n) -> Right (XSNested (XSWhile "breaking to outer loop") step, exit_loop s1, Break (n-1))
      | Right (step, s1, Continue 1) -> Right (XSNested (XSWhile "continuing loop") step, s1, WhileCond c c body)
      | Right (step, s1, Continue n) -> Right (XSNested (XSWhile "continuing to outer loop") step, exit_loop s1, Continue (n-1))
      | Right (_step, s1, Done) ->
          match get_last_exit_code s1 with
          | Just 0 -> Right (XSWhile "exit code was 0, running the loop body", s1, WhileRunning c body body)
          | Just _ -> Right (XSWhile "exit code was non-zero, taking the false branch", exit_loop s1, Done)
          | Nothing -> Left (XSWhile "unset or symbolic exit code", s1)
          end
      | Right (step, s1, cur') -> Right (XSNested (XSWhile "") step, s1, WhileCond c cur' body)
      end
  | WhileRunning c body cur ->
      match step_eval s0 cur with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (XSNested (XSWhile "exiting") step, s1, Exit)
      | Right (step, s1, Return) -> Right (XSNested (XSWhile "returning") step, s1, Return) 
      | Right (step, s1, Break 1) -> Right (XSNested (XSWhile "breaking loop") step, exit_loop s1, Done)
      | Right (step, s1, Break n) -> Right (XSNested (XSWhile "breaking to outer loop") step, exit_loop s1, Break (n-1))
      | Right (step, s1, Continue 1) -> Right (XSNested (XSWhile "continuing loop") step, s1, WhileCond c c body)
      | Right (step, s1, Continue n) -> Right (XSNested (XSWhile "continuing to outer loop") step, exit_loop s1, Continue (n-1))
      | Right (step, s1, Done) -> Right (XSNested (XSWhile "finished iteration of while loop; retesting condition") step, s1, WhileCond c c body)
      | Right (step, s1, cur') -> Right (XSNested (XSWhile "") step, s1, WhileRunning c body cur')
      end
  | For var ws body -> Right (XSFor "begin arg expansion", s0, ForExpArgs var (ExpStart ws) body)
  | ForExpArgs var exp_state body ->
      let (step, os1, st1) = step_expansion (s0, exp_state) in
      match st1 with
        | ExpError err ->
           let msg = string_of_symbolic_string (symbolic_string_of_fields err) in
           Right (XSFor "error in argument expansion",
                  exit_with 1 (write_stderr msg os1),
                  Done)
        | ExpDone f ->
           Right (XSFor "arguments fully expanded",
                  os1,
                  ForExpanded var f body)
        | (_ as in_progress) ->
           Right (XSExpand (XSFor "argument expansion step") step,
                  os1,
                  ForExpArgs var in_progress body)
      end
  (* Special case, no items exit status is zero *)
  | ForExpanded _var [] _body -> Right (XSFor "no items, exit code is 0", set_param "?" (symbolic_string_of_string "0") s0, Done)
  | ForExpanded var (i::f) body ->
      let s1 = enter_loop s0 in
      Right (XSFor ("starting for loop with " ^ var ^ " = " ^ (string_of_symbolic_string i)), set_param var i s1, ForRunning var f body body)
  | ForRunning var f body cur ->
      match step_eval s0 cur with
      | Left e -> Left e
      | Right (step, s1, Exit) -> Right (XSNested (XSFor "exiting") step, s1, Exit)
      | Right (step, s1, Return) -> Right (XSNested (XSFor "returning") step, s1, Return)
      | Right (step, s1, Break 1) -> Right (XSNested (XSFor "breaking loop") step, exit_loop s1, Done)
      | Right (step, s1, Break n) -> Right (XSNested (XSFor "breaking to outer loop") step, exit_loop s1, Break (n-1))
      | Right (step, s1, Continue 1) ->
          match f with
          | [] -> Right (XSNested (XSFor "continued at last iteration") step, exit_loop s1, Done)
          | (i::f') -> Right (XSNested (XSFor ("continuing to next iteration with " ^ var ^ " = " ^ string_of_symbolic_string i)) step,
                              set_param var i s1,
                              ForRunning var f' body body)
          end
      | Right (step, s1, Continue n) -> Right (XSNested (XSFor "continuing to outer loop") step, s1, Continue (n-1))
      | Right (step, s1, Done) ->
          match f with
          | [] -> Right (XSNested (XSFor "finished last iteration") step, exit_loop s1, Done)
          | (i::f') -> Right (XSNested (XSFor ("starting next iteration with " ^ var ^ " = " ^ string_of_symbolic_string i)) step,
                              set_param var i s1,
                              ForRunning var f' body body)
          end
      | Right (step, s1, cur') -> Right (XSNested (XSFor "") step, s1, ForRunning var f body cur')
      end
  | Case ws cases -> Right (XSCase "begin arg expansion", s0, CaseExpArg (ExpStart ws) cases)
  | CaseExpArg exp_state cases ->
      let (step, os1, st1) = step_expansion (s0, exp_state) in
      match st1 with
        | ExpError err ->
           let msg = string_of_symbolic_string (symbolic_string_of_fields err) in
           Right (XSCase "error in argument expansion",
                  exit_with 1 (write_stderr msg os1),
                  Done)
        | ExpDone [f] ->
           Right (XSCase "argument fully expanded", os1, CaseMatch f cases)
        | ExpDone _ ->
           Left (XSCase "case match element did not expand to a single field", s0)
        | (_ as in_progress) ->
           Right(XSExpand (XSCase "argument expansion step") step,
                 os1,
                 CaseExpArg in_progress cases)
      end
  | CaseMatch f cases ->
      match cases with
        | [] -> Right (XSCase "no match in case statement", s0, Done)
        | ([], _cmd)::cases' ->
           Right (XSCase "exhausted patterns, checking next case",
                  s0,
                  CaseMatch f cases')
        | (pat::pats', cmd)::cases' ->
           Right (XSCase "checking pattern match",
                  s0,
                  CaseCheckMatch f (ExpStart pat) cmd ((pats',cmd)::cases'))
      end
  | CaseCheckMatch f pat cmd cases ->
      let (step, os1, st1) = step_expansion (s0, pat) in
      match st1 with
        | ExpError err ->
           let msg = string_of_symbolic_string (symbolic_string_of_fields err) in
           Right (XSCase "error in argument expansion",
                  exit_with 1 (write_stderr msg os1),
                  Done)
        | ExpDone [pat'] ->
          (* TODO 2018-02-09 use proper locale and verify substring mode works correctly *)
          match match_prefix lc_ambient Exact pat' f with
          | NoMatch -> Right (XSCase "case did not match, trying the next",
                              os1, CaseMatch f cases)
          | Match _ -> Right (XSCase "case matched, evaluating cmd",
                              os1, cmd)
          | Symbolic -> Left (XSCase "TODO symbolic value, could match", os1)
          end
        | ExpDone _ -> Left (XSCase "case match pattern did not expand to a single field", os1)
        | (_ as in_progress) ->
           Right(XSExpand (XSCase "pattern expansion step") step,
                 os1,
                 CaseCheckMatch f in_progress cmd cases)
      end
  | Defun name body -> 
     if is_special_builtin name
     then Left (XSDefun ("invalid function name " ^ name ^ " (shadows special built-in)"), s0)
     else Right (XSDefun ("defined " ^ name), defun name body s0, Done)
  | Call old_loop_nest old_positional_params f orig c ->
     match step_eval s0 c with
     | Left e -> Left e
     | Right (step, s1, Done) ->
        Right (XSStack (f ^ ": implicit return") step,
               set_function_params old_loop_nest old_positional_params s1,
               Done)
     | Right (step, s1, Return) ->
        Right (XSStack (f ^ ": explicit return") step,
               set_function_params old_loop_nest old_positional_params s1,
               Done)
     | Right (step, s1, Exit) ->
        Right (XSStack (f ^ ": exit") step,
               set_function_params old_loop_nest old_positional_params s1,
               Exit)
     (* TODO 2018-03-02 what do we do if there's a break or continue in a call? 
        
        break/continue don't seem to ever be lexically enclosed in a loop, so behavior is unspecified.
        bash supports "non local break", dash doesn't.
      *)
     | Right (step, s1, c') ->
        Right (XSStack f step,
               s1,
               Call old_loop_nest old_positional_params f orig c')
     end
  | Break _n -> Right (XSSimple "break bottomed out", s0, Done)
  | Continue _n -> Right (XSSimple "continue bottomed out", s0, Done)
  | Return -> Right (XSSimple "return bottomed out", s0, Done)
  | Wait n -> 
     match waitpid step_eval s0 n with
     | (s1, Nothing) -> 
        Right (XSWait ("couldn't step process with pid " ^ stringFromNat n), 
               write_stderr ("wait: pid " ^ stringFromNat n ^ " is not a child of this shell") s1, 
               Done)
     | (s1, Just (Left step)) ->
        Right (XSNested (XSWait ("process with pid " ^ stringFromNat n ^ " stepped")) 
                        step,
               s1,
               Wait n)
     | (s1, Just (Right code)) ->
        Right (XSWait ("process with pid " ^ stringFromNat n ^ " completed"),
               exit_with code s1,
               Done)
     end               
  | Exit -> 
     (* TODO 2018-03-02 handle traps *)
     Right (XSSimple "exited", s0, Done)
  | Done -> Right (XSSimple "", s0, Done)
  end

(* Evaluation **********************************************************)

and full_evaluation os0 stmt0 =
  match stmt0 with
  | Done -> os0
  | _ -> match step_eval os0 stmt0 with
         | Right (_step, os1, stmt1) -> full_evaluation os1 stmt1
         | Left (_step, os1) -> os1
         end
  end

and eval os0 stmt0 =
  let os1 = full_evaluation os0 stmt0 in
  match get_last_exit_code os1 with
  | Nothing -> 255 (* symbolic or missing exit code *)
  | Just n -> n
  end

(**********************************************************************)   
(* TRACING ************************************************************)   
(**********************************************************************)   
(* TODO 2018-01-26 limit the amount of trace generated (for while, etc) *)
(* These functions are for testing and the expansion tool. *)

(* Expansion **********************************************************)
   
val run_trace_expansion : nat -> symbolic_os_state * expansion_state -> list (expansion_step * symbolic_os_state * expansion_state)
let rec run_trace_expansion gas (os0,st0) =
  if gas <= 0
  then [(ESStep "out of gas",os0,st0)]
  else match st0 with
  | ExpError _ -> []
  | ExpDone _ -> []
  | _ -> 
     let (step,os1,st1) = step_expansion (os0,st0) in
     (step,os1,st1)::run_trace_expansion (gas-1) (os1,st1)
  end
  
val trace_expansion : nat -> symbolic_os_state -> words -> list (expansion_step * symbolic_os_state * expansion_state)
let trace_expansion gas os0 w0 = 
  (ESStep "",os0,ExpStart w0)::run_trace_expansion gas (os0, ExpStart w0)

(* unbounded functions for testing final expansion results (used in
   test_expansion.ml)

   this function is a little unfaithful to the expansion semantics
   because we're not keeping track of whether the result was a message
   printed to stderr or the actual result of expansion
 *)
val run_trace_expansion_unbounded : symbolic_os_state * expansion_state -> list (expansion_step * symbolic_os_state * expansion_state)
let rec run_trace_expansion_unbounded (os0,st0) =
  match st0 with
  | ExpError _ -> []
  | ExpDone _ -> []
  | _ -> 
     let (step,os1,st1) = step_expansion (os0,st0) in
     (step,os1,st1)::run_trace_expansion_unbounded (os1,st1)
  end

val trace_expansion_unbounded : symbolic_os_state -> words -> list (expansion_step * symbolic_os_state * expansion_state)
let trace_expansion_unbounded os0 w0 = 
  (ESStep "",os0,ExpStart w0)::run_trace_expansion_unbounded (os0, ExpStart w0)

val full_expansion : symbolic_os_state -> words -> symbolic_os_state * fields
let full_expansion s0 w0 =
  let (_,s1,f1) = last (trace_expansion_unbounded s0 w0) in
  match f1 with
  | ExpError f -> (s1, f)
  | ExpDone f -> (s1, f)
  | _ -> (s1, [symbolic_string_of_string "!!! broken invariant"])
  end
   
val run_trace_evaluation : nat -> symbolic_os_state -> stmt -> list (evaluation_step * symbolic_os_state * stmt)
let rec run_trace_evaluation gas os0 stmt0 =
  if gas <= 0
  then [(XSStep "out of gas",os0,stmt0)]
  else match stmt0 with
  | Done -> []
  | _ ->
      match step_eval os0 stmt0 with
      | Right (step, os1, stmt1) -> (step, os1, stmt1)::run_trace_evaluation (gas-1) os1 stmt1
      | Left (step, os1) -> [(step, os1, Done)]
      end
  end

val trace_evaluation : nat -> symbolic_os_state -> stmt -> list (evaluation_step * symbolic_os_state * stmt)
let trace_evaluation gas os0 stmt0 = (XSStep "",os0,stmt0)::run_trace_evaluation gas os0 stmt0

(* TODO 2018-03-30 cleverer use of gas/limit number of commands *)
val trace_evaluation_multi : nat -> symbolic_os_state -> list stmt -> list (evaluation_step * symbolic_os_state * stmt)
let rec trace_evaluation_multi gas os0 stmts =
  match stmts with
  | [] -> []
  | (stmt::stmts') -> 
     let trace = trace_evaluation gas os0 stmt in
     let (_,os1,_) = last trace in
     trace ++ trace_evaluation_multi (gas-1) os1 stmts'
end
  
val full_evaluation_multi : symbolic_os_state -> list stmt -> symbolic_os_state
let rec full_evaluation_multi os0 stmts =
  match stmts with
  | [] -> os0
  | (stmt::stmts') -> full_evaluation_multi (full_evaluation os0 stmt) stmts'
  end

(* convenience function for shell *)
val real_eval : real_os_state -> stmt -> real_os_state
let real_eval os c = full_evaluation os c

(**********************************************************************)   
(* PROPERTIES *********************************************************)   
(**********************************************************************)   

lemma normal_expands_to_string : forall s0 x qm. exists s. expand_param s0 qm x Normal = [S s]
