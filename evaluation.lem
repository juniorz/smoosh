open import Fsh

open import Path
open import Pattern
open import Expansion

val step_assign : ty_os_state -> list (string * expansion_state) ->
                  either (ty_os_state * list (string * fields)) (* Done state *)
                         (ty_os_state * list (string * expansion_state) * evaluation_step) (* In progress *)
(* Steps the first, non-complete expansion_state and returns.
 * If it reached the base case, they are all complete, so
 *   we return the Left type to continue on the arg expansion. *)
let rec step_assign s0 assigns =
  match assigns with
  | [] -> Left (s0, [])
  | ((x, ExpError f) as error)::assigns' ->
    match step_assign s0 assigns' with
    | Right (s1, processed, step) -> Right (s1, error::processed, step)
    | Left (s1, completed) -> Left (s1, (x, f)::completed)
    end
  | ((x, ExpDone f) as finished)::assigns' ->
    match step_assign s0 assigns' with
    | Right (s1, processed, step) -> Right (s1, finished::processed, step)
    | Left (s1, completed) -> Left (s1, (x, f)::completed)
    end
  | (x, exp_state)::assigns' ->
    let (s1, next_state, step) = step_expansion (s0, exp_state) in
    Right (s1, (x, next_state)::assigns', XSExpand (XSSimple x) step)
  end

(* TODO 2017-12-12 move evaluation_step to end of tuple *)
val step_eval : ty_os_state -> stmt -> 
                either (evaluation_step * ty_os_state) (* error case *)
                       (evaluation_step * ty_os_state * stmt) (* success *)
let rec step_eval s0 stmt =
  match stmt with
  | Command assigns ws redirs ->
     (* TODO 2017-12-08 not quite right *)
     Right (XSSimple "begin expansion",
            s0,
            CommandExpAssign
              (map (fun (x, w) -> (x, ExpStart w)) assigns)
              ws
              redirs)
  | CommandExpAssign assigns ws redirs ->
     (* TODO 2017-12-01
        evaluate each of ws step by step 

        need to _carefully_ keep track of expansion status and splitting, etc.

        check on the assigns... if not all in fields, work there
      *)
     match step_assign s0 assigns with
     (* Perform an expansion step in an assignment *)
     | Right (s1, assigns', exp_step) ->
         Right (exp_step,
                s1,
                CommandExpAssign assigns' ws redirs)
     (* Done, move on to expanding arguments *)
     | Left (s1, fields) ->
         Right (XSSimple "assignments fully expanded",
                s1,
                CommandExpArgs fields (ExpStart ws) redirs)
     end
  | CommandExpArgs assigns exp_state redirs ->
      let (os1, st1, step) = step_expansion (s0, exp_state) in
      match st1 with
        | ExpError _ ->
            Left (XSSimple "error in argument expansion",
                  os1)
        | ExpDone f ->
          Right (XSSimple "arguments fully expanded",
                   os1,
                   CommandExpanded assigns f redirs)
        | (_ as in_progress) ->
          Right(XSExpand (XSSimple "argument expansion step") step,
                   os1,
                   CommandExpArgs assigns in_progress redirs)
      end
     (* assigns are done, check on args 

extremely subtle behavior with errors in expansion:
  an expansion error is NOT a field

$ count() { echo $# ; }
$ count $(echo ${x?one two three})
/Users/mgree/fsh/dash/src/dash: 2: x: one two three
0
$ count $(echo ${x?one two three} four)
/Users/mgree/fsh/dash/src/dash: 3: x: one two three
0
$ count $(echo ${x?one two three}) four
/Users/mgree/fsh/dash/src/dash: 4: x: one two three
1
$ count $(${x? one two three}) four
/Users/mgree/fsh/dash/src/dash: 5: x:  one two three
      *)
  | CommandExpanded _assigns _ws _redirs ->
     (* TODO
          EVERYTHING is expanded, 
            perform assignments
            setup redirect
            run command
      *)
     Left (XSSimple "TODO", s0)
  | Pipe _bg _stmts -> Left (XSPipe "TODO", s0)
  | Redir _stmt' _redirs -> Left (XSRedir "TODO", s0)
  | Background _stmt' _redirs -> Left (XSBackground "TODO", s0)
  | Subshell _stmt' _redirs -> Left (XSSubshell "TODO", s0)
  | And _l _r -> Left (XSAnd "TODO", s0)
  | Or _l _r -> Left (XSOr "TODO", s0)
  | Not _stmt' -> Left (XSNot "TODO", s0)
  | Semi _l _r -> Left (XSSemi "TODO", s0)
  | If _c _t _e -> Left (XSIf "TODO", s0)
  | While _cond _body -> Left (XSWhile "TODO", s0)
  | For _var _ws _body -> Left (XSFor "TODO", s0)
  | Case _ws _cases -> Left (XSCase "TODO", s0)
  | Defun _name _body -> Left (XSDefun "TODO", s0)
  (* This should never come up when called from trace_evaluation or elsewhere *)
  | Done -> Right(XSSimple "", s0, Done)
  end

val trace_evaluation : ty_os_state -> stmt -> list (ty_os_state * stmt * evaluation_step)
let rec trace_evaluation os0 stmt0 =
  match stmt0 with
  | Done -> []
  | _ ->
      match step_eval os0 stmt0 with
      | Right (step, os1, stmt1) -> (os1, stmt1, step)::trace_evaluation os1 stmt1
      | Left (step, os1) -> [(os1, Done, step)]
      end
  end
