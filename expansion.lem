open import Fsh

open import Arith
open import Pattern

type string_mode =
    UserString
  | GeneratedString

type quoting_mode =
    Unquoted
  | Quoted

  (* Left is what has been parsed, right is unparsed *)
type expansion_state = words * words

(*
 * Stage 1 Expansion: Word expansion
 *)

val expand_param : ty_os_state -> quoting_mode -> string -> format -> words
val expand_control : ty_os_state -> quoting_mode -> control -> either (ty_os_state * expanded_words) (ty_os_state * expanded_words * words)
val expand_words : ty_os_state -> quoting_mode -> string_mode -> (expanded_words * words) -> either (ty_os_state * expanded_words) (ty_os_state * expanded_words * words)
val control_code_expansion : ty_os_state -> quoting_mode -> words -> (ty_os_state * expanded_words)

val concat_expanded : expanded_words -> symbolic_string
let rec concat_expanded w =
  match w with
  | [] -> stringToSymbolicString ""
  | UsrF::ws -> stringToSymbolicString " " ++ concat_expanded ws
  | ExpS s::ws -> stringToSymbolicString s ++ concat_expanded ws
  | DQuo s::ws -> stringToSymbolicString s ++ concat_expanded ws
  | EWSym c::ws -> c ++ concat_expanded ws
  | UsrS _::_ -> stringToSymbolicString "TODO: broken invariant"
  end

let match_substring (side:substring_side) (mode:substring_mode) (pat:expanded_words) (str:fields) : symbolic_string =
  let sympat : symbolic_string = (concat_expanded pat) in
  let symstr : symbolic_string = toSymbolicCharList str in
  match side with
  | Prefix -> try_match_prefix Locale.lc_ambient mode sympat symstr (* TODO way to select/update locale *)
  | Suffix -> match try_match_prefix Locale.lc_ambient mode (reverse sympat) (reverse symstr) with(* TODO same *)
              | [SymPat m pat s] -> [SymPat m (reverse pat) (reverse s)]
              | ss               -> reverse ss
              end
  end

let expand_param s0 _q str f =
  let value = lookup_param s0 str in
  match (value, f) with
  (* NORMAL *)
  | (Nothing, Normal)     -> [S ""] (* null *)
  | (Just fs, Normal)     -> words_of_symbolic_string fs
  (* DEFAULT *)
  | (Nothing, Default w)  -> w
  | (Just fs, Default _)  -> words_of_symbolic_string fs
  | (Nothing, NDefault w) -> w
  | (Just fs, NDefault w) ->
     match null_string fs with
     | Nothing -> (* TODO symbolic result *) words_of_symbolic_string fs
     | Just true -> w
     | Just false -> words_of_symbolic_string fs
     end
  (* ASSIGN *)
  | (Nothing, Assign w)  -> [K (LAssign str [] w)]
  | (Just fs, Assign _)  -> words_of_symbolic_string fs       
  | (Nothing, NAssign w) -> [K (LAssign str [] w)]
  | (Just fs, NAssign w) -> 
     match null_string fs with
     | Nothing -> (* TODO symbolic result *) words_of_symbolic_string fs
     | Just true -> [K (LAssign str [] w)]
     | Just false -> words_of_symbolic_string fs
     end
  (* ERROR *)
  | (Nothing, Error w)  -> [K (LError str [] w)]
  | (Just fs, Error _)  -> words_of_symbolic_string fs
  | (Nothing, NError w) -> [K (LError str [] w)]
  | (Just fs, NError w) -> 
     match null_string fs with
     | Nothing -> (* TODO symbolic result *) words_of_symbolic_string fs
     | Just true -> [K (LError str [] w)]
     | Just false -> words_of_symbolic_string fs
     end
  (* LENGTH *)
  | (Nothing, Length) -> [S "0"]
  | (Just fs, Length) ->
     match try_concrete fs with
     | Nothing -> (* TODO symbolic result *) [S "0"]
     | Just strs -> [S (show (stringLength strs))]
     end
  (* ALT *)
  | (Nothing, Alt _)  -> [S ""]
  | (Just fs, Alt w)  -> w
  | (Nothing, NAlt _) -> [S ""]
  | (Just fs, NAlt w) ->
     match null_string fs with
     | Nothing -> (* TODO symbolic result *) words_of_symbolic_string fs
     | Just true -> [S ""]
     | Just false -> w
     end
  (* SUBTRINGS (prefix/suffix) *)
  | (Nothing, Substring _ _ _) -> [S ""]
  | (Just fs, Substring s m w) -> [K (LMatch [fs] s m [] w)]
  end

let rec expand_control s0 q k =
    match k with
    | Tilde ->
       let dir = match expand_param s0 Unquoted "HOME" Normal with
         (* if HOME is unset, results are unspecified---we return "~" 
            dash:
              $ unset HOME
              $ echo ~
              ~
              $ HOME=""
              $ echo ~
              ~
              $ HOME="/Users/mgree"
              $ echo ~
              /Users/mgree

            bash:
              $ unset HOME
              $ echo ~
              /Users/mgree
              $ HOME=""
              $ echo ~
              
              $ HOME="/Users/mgree"
              $ echo ~
              /Users/mgree            

            lol
          *)
         | [S ""] -> [S "~"] 
         | dir -> dir
         end in
       Right (s0, [], dir)
    | TildeUser usr -> 
       match get_pwdir s0 usr with
       | Nothing -> Right (s0, [], [S ("~" ^ usr)]) (* unspec per 2.6.1, but we follow dash *)
       | Just path -> Right (s0, [], [S path])
       end
    | Param s f -> expand_words s0 q GeneratedString ([], expand_param s0 q s f)
    | LAssign s f [] ->
        let s1 = <| s0 with shell_env = Map.insert s (concat_expanded f) s0.shell_env |> in
        Right (s1, f, [])
    | LAssign s f w ->
       match expand_words s0 q GeneratedString ([], w) with
       | Right (s1, f1, w1) -> Right (s1, [], [K (LAssign s (f ++ f1) w1)])
       | Left err -> Left err
       end
    | LMatch str side mode f [] -> Right (s0, [], words_of_symbolic_string (match_substring side mode f str))
    | LMatch s side mode f w ->
       match expand_words s0 q GeneratedString ([], w) with
       | Right (s1, f1, w1) -> Right (s1, [], [K (LMatch s side mode (f ++ f1) w1)])
       | Left err -> Left err
       end
    | LError str f [] -> Left (s0, ExpS (str ^ ": ")::f) (* dash seems to print erroring variable name; TODO should we also have linno? *)
    | LError str f w -> 
       match expand_words s0 q GeneratedString ([], w) with
       | Right (s1, f1, w1) -> Right (s1, [], [K (LError str (f ++ f1) w1)])
       | Left err -> Left err
       end
    | Backtick c -> Right (s0, [], [ESym [SymCommand c]]) (* TODO this should create a new bash process, setup pipes *)
    | Arith f [] ->
        match arith64 s0 (concat_expanded f) with
        | Right (s1, result) -> Right (s1, expanded_words_of_fields result, [])
        | Left e -> Left (s0, [ExpS e])
        end
    | Arith f w -> 
       match expand_words s0 q GeneratedString ([],w) with
       | Right (s1, f1, w1) -> Right (s1, [], [K (Arith (f ++ f1) w1)])
       | Left err -> Left err
       end
    | Quote w -> 
       match expand_words s0 Quoted GeneratedString ([],w) with
       | Right (s1, f1, []) -> Right (s1, f1, [])
       | Right (s1, f1, w1) -> Right (s1, f1, [K (Quote w1)])
       | Left err -> Left err
       end
  end

and expand_words s0 q sm (f,w) =
  match w with
    | [] -> Right (s0, f, w)
    | (F::ws) -> Right (s0, f ++ [UsrF], ws)
    | (S(s)::ws) ->
        let f1 = match (q, sm) with
        | (Quoted, _) -> [DQuo s]
        | (Unquoted, UserString) -> [UsrS s]
        | (Unquoted, GeneratedString) -> [ExpS s]
        end in
        Right (s0, f ++ f1, ws)
    | (DQ(s)::ws) -> Right (s0, f ++ [DQuo s], ws)
    | (K(k)::ws) -> 
       match expand_control s0 q k with
       | Right (s1,f1,w1) -> Right (s1, f++f1, (w1 ++ ws))
       | Left err -> Left err
       end
    | (ESym(c)::ws) -> Right (s0, f ++ [EWSym c], ws)
  end

and control_code_expansion s0 q w =
  match expand_words s0 q UserString ([],w) with
  | Right (s1, f1, w1) ->
     match w1 with
     | [] -> (s1, f1)
     | _ -> let (s2, f2) = control_code_expansion s1 q w1 in
            (s2, (f1 ++ f2))
     end
  | Left (s1, err1) -> (s1, err1)
  end

lemma normal_expands_to_string : forall s0 x qm. exists s. expand_param s0 qm x Normal = [S s]

(*
 * Stage 2 Expansion: Field Splitting
 *)

type tmp_field =
    WFS
  | FS
  | Field of symbolic_string
  | QField of symbolic_string

type intermediate_fields = list tmp_field

val is_ws : char -> bool
val collect_non_ifs : list char -> list char -> (list char) * (list char)
(*val collect_ifs_whitespace : list char -> list char -> list char*)
val split_string : list char -> list char -> intermediate_fields
val split_word : list char -> (intermediate_fields * expanded_words) -> (intermediate_fields * expanded_words)
val split_fields : ty_os_state -> expanded_words -> intermediate_fields
val clean_fields : intermediate_fields -> intermediate_fields
val field_splitting: ty_os_state -> expanded_words -> intermediate_fields

let is_ws c = elem c (toCharList " \n\t")

let rec collect_non_ifs ifs ls =
  match ls with
  | [] -> ([], [])
  | (c::cs) ->
      if elem c ifs
      then ([], c::cs)
      else let (f, remaining) = collect_non_ifs ifs cs in
           (c::f, remaining)
  end

let rec split_string ifs clst =
   match clst with
   | [] -> []
   | c::cs ->
       if elem c ifs
       then let fs = if is_ws c then WFS else FS 
            in fs::split_string ifs cs
       else let (cc, cs1) = collect_non_ifs ifs cs in 
            (Field (charListToSymbolicString (c::cc)))::(split_string ifs cs1)
  end

let rec split_word ifs p =
  match p with
  | (f, []) -> (f, [])
  | (f, UsrF::wrds) -> split_word ifs (f ++ [FS], wrds)
  | (f, ExpS(s)::wrds) ->
      let new_fields = split_string ifs (toCharList s) in
      split_word ifs (f ++ new_fields, wrds)
  | (f, UsrS(s)::wrds) -> split_word ifs (f ++ [Field (stringToSymbolicString s)], wrds)
  | (f, DQuo(s)::wrds) -> split_word ifs (f ++ [QField (stringToSymbolicString s)], wrds)
  | (f, EWSym(c)::wrds) -> split_word ifs (f ++ [Field c], wrds)
  end

let split_fields s0 exp_words =
  let ifs = lookup_param s0 "IFS" in
  let (f, _) = match ifs with
    | Nothing -> split_word (toCharList " \n\t") ([], exp_words)
    | Just fs -> 
       match try_concrete fs with
       | Nothing -> (* TODO symbolic, we're fucked *) 
          split_word (toCharList " \n\t") ([], exp_words)
       | Just "" -> ([Field (concat_expanded exp_words)], [])
       | Just s -> split_word (toCharList s) ([], exp_words)
       end
  end in f

let rec combine_fields f =
  match f with
  | [] -> []
  | [WFS] -> [] (* Remove trailing field separators *)
  | (WFS::WFS::rst) -> combine_fields (WFS::rst) (* Combine adjacent whitespace separators *)
  | (WFS::FS::rst) -> combine_fields (FS::rst)
  | (FS::WFS::rst) -> combine_fields (FS::rst)
  | (Field(s1)::Field(s2)::rst) -> combine_fields (Field(s1 ++ s2)::rst)
  | (WFS::rst) -> FS::(combine_fields rst)
  | (f::rst) -> f::(combine_fields rst)
  end

let rec clean_fields f =
  match f with
  | (WFS::rst) -> clean_fields rst
  | _ -> combine_fields f
  end

let field_splitting s0 w = clean_fields (split_fields s0 w)

(*
 * Stage 3 Expansion: Pathname expansion
 *)

val pathname_expansion : ty_os_state -> intermediate_fields -> intermediate_fields

(* Parameter expansion only happens on unquoted fields *)
let rec pathname_expansion s0 f =
  match f with
  | [] -> []
  | (Field(s)::rst) -> ([Field s]) ++ (pathname_expansion s0 rst)
  | (f::rst) -> f::(pathname_expansion s0 rst)
  end

(*
 * Stage 4 Expansion: Quote Removal
 *)

val remove_quotes : intermediate_fields -> intermediate_fields
val to_fields : intermediate_fields -> fields
val finalize_fields : intermediate_fields -> fields
val quote_removal : ty_os_state -> intermediate_fields -> fields

let rec remove_quotes f =
  match f with
  | [] -> []
  | (QField(s)::rst) -> Field(s)::(remove_quotes rst)
  | (f::rst) -> f::(remove_quotes rst)
  end

let rec to_fields f =
  match f with
  | []           -> []
  | FS::FS::rst  -> (stringToSymbolicString "")::(to_fields rst)
  | Field fs::rst -> 
     fs::(to_fields rst)
  | FS::rst      -> to_fields rst
  | WFS::_       -> [stringToSymbolicString "TODO: broken invariant"]
  | QField _::_  -> [stringToSymbolicString "TODO: broken invariant"]
  end

let rec finalize_fields f =
  match f with
  | (FS::rst) -> stringToSymbolicString ""::finalize_fields rst
  | _ -> to_fields f
  end

let quote_removal _s0 f =
  let no_quotes = combine_fields (remove_quotes f) in
  finalize_fields no_quotes

(*
 * Run a full expansion on the given words
 *)

val full_expansion : ty_os_state -> words -> ty_os_state * fields
let full_expansion s0 w_in =
  let (s1, f1_out) = control_code_expansion s0 Unquoted w_in in
  let f2_out = field_splitting s1 f1_out in
  let f3_out = pathname_expansion s1 f2_out in
  let f4_out = quote_removal s1 f3_out in
  (s1, f4_out)

