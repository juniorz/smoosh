open import Pervasives_extra

(*
Strings will be whatever lem uses for string
??? What character set does lem use for strings? Does it matter?
*)

type fields = list string

type quoting_mode =
    Unquoted
  | Quoted

type format =
    Normal
  | Default of words
  | NDefault of words
  | Assign of words
  | NAssign of words
  | Error of words
  | NError of words
  | Alt of words
  | NAlt of words
  | Length
  | ShortestPrefix of words
  | LongestPrefix of words
  | ShortestSuffix of words
  | LongestSuffix of words

(* Treating parameters niavely led to a problem when evaluating
 * ${x=${x=foo}bar${x=baz}} incorrectly when x was unset
 *)
and control =
    Tilde
  | TildeUser of string
  | Param of string * format
  | LAssign of string * (maybe string) * words
  | Backtick of words
  | Arith of words
  | Quote of words
  (* Is this needed anymore? *)
  (*| Nested of quoting_mode * words*)

(* instance (Eq control)
  let (=) x y = match (x,y) with
    | (Tilde, Tilde) = true
    | (TildeUser s1, TildeUser s2) = s1 = s2
    | (Param (s1,f1), Param (s2,f2) = (s2,f2)
    | (LAssign (s1,ms1,w1), LAssign (s2,ms2,w2)) = s1 = s2 && ms1 = ms2 && w1 = w2
    | (L
  let (<>) x y = not (list_arrayEq x y)
end *)

and entry =
    S of string
  | DQ of string
  | K of control
  | F

and words = list entry

  (* Left is what has been parsed, right is unparsed *)
and expansion_state = words * words

val string_of_words : words -> string
val string_of_entry : entry -> string

let rec string_of_words w = List.foldr (^) "" (List.map string_of_entry w)
and string_of_entry e =
  match e with
  | S str -> "S(" ^ str ^ ")"
  | DQ string -> "\"" ^ string ^ "\""
  | K _ -> "<<CTRL>>"
  | F -> "<<FS>>"
  end

(*-------------------------------*)
(* Process ids                   *)
(*-------------------------------*)

type ty_pid = Pid of nat (*o with sexp o*) (* coverage:sexp *)
let ty_pid_compare (Pid n0) (Pid n1) = compare n0 n1
instance ( SetType ty_pid )
  let setElemCompare = ty_pid_compare
end

instance (Eq ty_pid)
  let (=) = unsafe_structural_equality
  let (<>) = unsafe_structural_inequality
end

val dest_PID : ty_pid -> nat
let dest_PID x = (match x with Pid n -> n end) (* coverage:unused *)

(* From t_fs_spec.lem_cppo line 1187 *)
type ty_os_state = <|
    shell_env: Map.map string string
  |>

(* The result is nothing if the parameter is unset, and the empty string null. *)
val lookup_param :
  ty_os_state ->
  string ->
  maybe string
let lookup_param s0 str = Map.lookup str s0.shell_env

val fully_expanded : words -> bool
let rec fully_expanded w =
  match w with
    | [] -> true
    | ((K _)::_) -> false
    | ((_)::ws) -> fully_expanded ws
  end

(* TODO: use proper IFS separateor for F *)
val expanded_tostring : words -> maybe string

val split_str : list char -> words * list char -> words * list char
val split_list : list char -> words -> words
val split_fields : ty_os_state -> words -> words

(* TODO : Add prefix/suffix.
 * TODO: Length can throw error when -u is set.
 * TODO: Error properly
 *)
val expand_param : ty_os_state -> quoting_mode -> string -> format -> words
val expand_control : ty_os_state -> quoting_mode -> control -> ty_os_state * words
val expand_words : ty_os_state -> quoting_mode -> words -> ty_os_state * words
val fully_expand_words : ty_os_state -> quoting_mode -> words -> ty_os_state * words

let rec split_str ifs p = match p with
  | (parsed, []) -> (parsed, [])
  | (S(s)::parsed, c::cs) -> if elem c ifs then split_str ifs (F::S(s)::parsed, cs) else split_str ifs (S(s ^ (toString [c]))::parsed, cs)
  | (parsed, c::cs) -> split_str ifs (S(toString [c])::parsed, cs)
  end

let rec split_list ifs w = match ifs with
  | [] -> w
  | _ -> match w with
    | [] -> []
    | (S(s)::ws) -> let (parsed,_) = split_str ifs ([],toCharList s) in
                    (reverse parsed) ++ (split_list ifs ws)
    | (DQ(s)::ws) -> DQ(s)::(split_list ifs ws)
    | (F::ws) -> F::(split_list ifs ws)
    | (K(k)::ws) -> K(k)::(split_list ifs ws) (* This case should never happen *)
    end
  end

let split_fields s0 w =
  let ifs = lookup_param s0 "IFS" in
  match ifs with
    | Nothing -> split_list (toCharList " \n\t") w
    | Just "" -> w
    | Just s -> split_list (toCharList s) w
  end

let rec expanded_tostring w =
  match w with
    | [] -> Just ""
    | (S(s)::ws) -> Maybe.map (fun str -> stringAppend s str) (expanded_tostring ws)
    | (DQ(s)::ws) -> Maybe.map (fun str -> stringAppend s str) (expanded_tostring ws)
    | (F::ws) -> Maybe.map (fun str -> stringAppend " " str) (expanded_tostring ws)
    | (K(_)::_) -> Nothing
end

let rec expand_param s0 q str f =
  (let value = lookup_param s0 str in
  (match value with
    | Nothing -> (match f with
      | Default w  -> w
      | NDefault w  -> w
      | Assign w -> [K (LAssign str Nothing w)]
      | NAssign w  -> [K (LAssign str Nothing w)]
      | Error _    -> [S "error"] (* This should error *)
      | NError _    -> [S "error"] (* This should error *)
      | Length     -> [S ("0")]
      | _          -> [S ("")] (* null *)
      end)
    | Just "" -> (match f with
      | NDefault w -> w
      | Alt w      -> w
      | NError _    -> [S "error"] (* This should error *)
      | Length     -> [S ("0")]
      | _          -> [S ("")] (* null *)
      end)
    | Just v -> (match f with
      | Alt w  -> w
      | NAlt w -> w
      | Length -> [S (show (stringLength v))]
      | _      -> [S (v)]
      end)
  end))

and expand_control s0 q k =
(*
 * TODO: TildeUser
 * TODO: Backtick
 * TODO: Evaluate Arith
 * TODO: Nested
 *)
  match k with
    | Tilde -> (s0, expand_param s0 Unquoted "HOME" Normal)
    | TildeUser usr -> (s0, [S "error"]) (* This should call system *)
    | Param s f -> (s0, expand_param s0 q s f)
    | LAssign s Nothing w -> let (s1, w1) = (expand_words s0 q w) in
        if fully_expanded w1
          then (s1, [K (LAssign s (expanded_tostring w1) w1)])
          else (s1, [K (LAssign s Nothing w1)])
    | LAssign s (Just str) w ->
        let s1 = <| s0 with shell_env = Map.insert s str s0.shell_env |> in
            (s1, split_fields s1 w)
    | Backtick w -> (s0, [S "error"]) (* This should create a new bash env *)
    | Arith w -> let (s1, w1) = (expand_words s0 q w) in
        (s1, [K (Arith w1)])
    (* At end, turn into DQ of string? *)
    | Quote w -> let (s1, w1) = expand_words s0 Quoted w in
        (s1, [K (Quote (w1))])
    (*| Nested (q, st) -> [K (Nested (q, expand_words *)
  end

and expand_words s0 q w =
  match w with
    | [] -> (s0, w)
    | (F::ws) -> let (s1, w1) = (expand_words s0 q ws) in
          (s1, F::w1)
    | (S(s)::ws) -> let (s1, w1) = (expand_words s0 q ws) in
          (s1, S(s)::w1)
    | (DQ(s)::ws) -> let (s1, w1) = (expand_words s0 q ws) in
          (s1, DQ(s)::w1)
    | (K(k)::ws) -> let (s1, w1) = expand_control s0 q k in
          (s1, w1 ++ ws)
  end

and fully_expand_words s0 q w =
  if fully_expanded w
  then (s0, split_fields s0 w)
  else let (s1, w1) = expand_words s0 q w in
       fully_expand_words s1 q w1

(*    let st = (fun st1 ->
        match st1 with
          | (s1,(l,[])) -> (s1,(seen++l,w1))
          | (s1,w2) -> (s1,(seen,w2))a
        end) in
    st next*)

(*
 * expansion_state would be one list
 * expand_control: sys -> q -> K of x -> w
 * entries should know if they are quoted, DQ of string (double quoted)
 *)
