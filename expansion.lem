open import Fsh

open import Arith
open import Pattern
open import Path

type string_mode =
    UserString
  | GeneratedString

type quoting_mode =
    Unquoted
  | Quoted

(*
 * Stage 1 Expansion: Word expansion
 *)

val expand_param : ty_os_state -> quoting_mode -> string -> format -> words
val expand_control : ty_os_state -> quoting_mode -> control ->
  either (expansion_step * ty_os_state * expanded_words) (expansion_step * ty_os_state * expanded_words * words)
val expand_words : ty_os_state -> quoting_mode -> string_mode -> (expanded_words * words) ->
  either (expansion_step * ty_os_state * expanded_words) (expansion_step * ty_os_state * expanded_words * words)
(* Runs expansion all the way, for testing purposes only *)
val control_code_expansion : ty_os_state -> quoting_mode -> words -> (ty_os_state * expanded_words)

let match_substring (lc:locale) (side:substring_side) (mode:substring_mode) (pat:expanded_words) (str:fields) : symbolic_string =
  let sympat : symbolic_string = (concat_expanded pat) in
  let symstr : symbolic_string = toSymbolicCharList str in
  try_match_prefix lc side mode sympat symstr

(* TODO 2017-12-01
 * In an N____ case, when null_string fs is Nothing, the
 * string is entirely symbolic so we need
 * to represent the symbolic result of "it could be either
 * true or false, we don't know". This means we need to branch
 * and allow for both cases to progress.
 *)
let expand_param s0 _q str f =
  let value = lookup_param s0 str in
  match (value, f) with
  (* NORMAL *)
  | (Nothing, Normal)     -> [S ""] (* null *)
  | (Just fs, Normal)     -> words_of_symbolic_string fs
  (* DEFAULT *)
  | (Nothing, Default w)  -> w
  | (Just fs, Default _)  -> words_of_symbolic_string fs
  | (Nothing, NDefault w) -> w
  | (Just fs, NDefault w) ->
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> w
     | Just false -> words_of_symbolic_string fs
     end
  (* ASSIGN *)
  | (Nothing, Assign w)  -> [K (LAssign str [] w)]
  | (Just fs, Assign _)  -> words_of_symbolic_string fs       
  | (Nothing, NAssign w) -> [K (LAssign str [] w)]
  | (Just fs, NAssign w) -> 
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> [K (LAssign str [] w)]
     | Just false -> words_of_symbolic_string fs
     end
  (* ERROR *)
  | (Nothing, Error w)  -> [K (LError str [] w)]
  | (Just fs, Error _)  -> words_of_symbolic_string fs
  | (Nothing, NError w) -> [K (LError str [] w)]
  | (Just fs, NError w) -> 
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> [K (LError str [] w)]
     | Just false -> words_of_symbolic_string fs
     end
  (* LENGTH *)
  | (Nothing, Length) -> [S "0"]
  | (Just fs, Length) ->
     match try_concrete fs with
     | Nothing -> (* TODO This should be the length of the symbolic result of fs *) [S "0"]
     | Just strs -> [S (show (stringLength strs))]
     end
  (* ALT *)
  | (Nothing, Alt _)  -> [S ""]
  | (Just _, Alt w)  -> w
  | (Nothing, NAlt _) -> [S ""]
  | (Just fs, NAlt w) ->
     match null_string fs with
     | Nothing -> words_of_symbolic_string fs
     | Just true -> [S ""]
     | Just false -> w
     end
  (* SUBTRINGS (prefix/suffix) *)
  | (Nothing, Substring _ _ _) -> [S ""]
  | (Just fs, Substring s m w) -> [K (LMatch [fs] s m [] w)]
  end

let rec expand_control s0 q k =
    match k with
    | Tilde ->
       let (msg, dir) = match expand_param s0 Unquoted "HOME" Normal with
         (* if HOME is unset, results are unspecified---we return "~" 
            dash:
              $ unset HOME
              $ echo ~
              ~
              $ HOME=""
              $ echo ~
              ~
              $ HOME="/Users/mgree"
              $ echo ~
              /Users/mgree

            bash:
              $ unset HOME
              $ echo ~
              /Users/mgree
              $ HOME=""
              $ echo ~
              
              $ HOME="/Users/mgree"
              $ echo ~
              /Users/mgree            

            lol
          *)
         | [S ""] -> ("defaulting to dash behavior for unset HOME (unspec per 2.6.1)", [S "~"])
         | dir -> ("", dir)
         end in
       Right (ESTilde msg, s0, [], dir)
    | TildeUser usr -> 
       match get_pwdir s0 usr with
       | Nothing -> Right (ESTilde "defaulting to dash behavior for failed getpwnam (unspec per 2.6.1)", s0, [], [S ("~" ^ usr)]) (* unspec per 2.6.1, but we follow dash *)
       | Just path -> Right (ESTilde "", s0, [], [S path])
       end
    | Param s f -> expand_words s0 q GeneratedString ([], expand_param s0 q s f)
    | LAssign s f [] ->
        let s1 = set_param s (concat_expanded f) s0 in
        Right (ESParam "finished assignment", s1, f, [])
    | LAssign s f w ->
       match expand_words s0 q GeneratedString ([], w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESParam "assignment") step, s1, [], [K (LAssign s (f ++ f1) w1)])
       | Left err -> Left err
       end
    | LMatch str side mode f [] -> Right (ESParam "finished match", s0, [], words_of_symbolic_string (match_substring s0.sh.locale side mode f str))
    | LMatch s side mode f w ->
       match expand_words s0 q GeneratedString ([], w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESParam "match") step, s1, [], [K (LMatch s side mode (f ++ f1) w1)])
       | Left err -> Left err
       end
    | LError str f [] -> Left (ESParam "raising requested error", s0, ExpS (str ^ ": ")::f) (* dash seems to print erroring variable name; TODO should we also have linno? *)
    | LError str f w ->
       match expand_words s0 q GeneratedString ([], w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESParam "error") step, s1, [], [K (LError str (f ++ f1) w1)])
       | Left err -> Left err
       end
    | Backtick c -> Right (ESCommand "treating commands symbolically", s0, [], [ESym (SymCommand c)]) (* TODO this should create a new bash process, setup pipes *)
    | Arith f [] ->
        match arith64 s0 (concat_expanded f) with
        | Right (s1, result) -> Right (ESArith "computed arithmetic result", s1, expanded_words_of_fields result, [])
        | Left e -> Left (ESArith "arithmetic error", s0, [ExpS e])
        end
    | Arith f w ->
       match expand_words s0 q GeneratedString ([],w) with
       | Right (step, s1, f1, w1) -> Right (ESNested (ESArith "before arithmetic parsing") step, s1, [], [K (Arith (f ++ f1) w1)])
       | Left err -> Left err
       end
    | Quote w -> 
       match expand_words s0 Quoted GeneratedString ([],w) with
       | Right (step, s1, f1, []) -> Right (step, s1, f1, [])
       | Right (step, s1, f1, w1) -> Right (step, s1, f1, [K (Quote w1)])
       | Left err -> Left err
       end
  end

and expand_words s0 q sm (f,w) =
  match w with
    | [] -> Right (ESStep "done", s0, f, w)
    | (F::ws) -> Right (ESStep "user field separator", s0, f ++ [UsrF], ws)
    | (S(s)::ws) ->
        let f1 = match (q, sm) with
        | (Quoted, _) -> [DQuo s]
        | (Unquoted, UserString) -> [UsrS s]
        | (Unquoted, GeneratedString) -> [ExpS s]
        end in
        Right (ESStep "plain string", s0, f ++ f1, ws)
    | (K(k)::ws) ->
       match expand_control s0 q k with
       | Right (step, s1, f1, w1) -> Right (step, s1, f++f1, (w1 ++ ws))
       | Left err -> Left err
       end
    | (ESym(c)::ws) -> Right (ESStep "skipping symbolic result", s0, f ++ [EWSym c], ws)
  end

and control_code_expansion s0 q w =
  match expand_words s0 q UserString ([],w) with
  | Right (_step, s1, f1, w1) ->
     match w1 with
     | [] -> (s1, f1)
     | _ -> let (s2, f2) = control_code_expansion s1 q w1 in
            (s2, (f1 ++ f2))
     end
  | Left (_step, s1, err1) -> (s1, err1)
  end

lemma normal_expands_to_string : forall s0 x qm. exists s. expand_param s0 qm x Normal = [S s]

(*
 * Stage 2 Expansion: Field Splitting
 *)

val is_ws : char -> bool
val collect_non_ifs : list char -> list char -> (list char) * (list char)
(*val collect_ifs_whitespace : list char -> list char -> list char*)
val split_expstring : list char -> list char -> intermediate_fields
val split_word : list char -> (intermediate_fields * expanded_words) -> (intermediate_fields * expanded_words)
val split_fields : ty_os_state -> expanded_words -> intermediate_fields
val clean_fields : intermediate_fields -> intermediate_fields
val field_splitting: ty_os_state -> expanded_words -> intermediate_fields

let is_ws c = elem c (toCharList " \n\t")

let rec collect_non_ifs ifs ls =
  match ls with
  | [] -> ([], [])
  | (c::cs) ->
      if elem c ifs
      then ([], c::cs)
      else let (f, remaining) = collect_non_ifs ifs cs in
           (c::f, remaining)
  end

let rec split_expstring ifs clst =
   match clst with
   | [] -> []
   | c::cs ->
       if elem c ifs
       then let fs = if is_ws c then WFS else FS 
            in fs::split_expstring ifs cs
       else let (cc, cs1) = collect_non_ifs ifs cs in 
            (Field (charListToSymbolicString (c::cc)))::(split_expstring ifs cs1)
  end

let rec split_word ifs p =
  match p with
  | (f, []) -> (f, [])
  | (f, UsrF::wrds) -> split_word ifs (f ++ [FS], wrds)
  | (f, ExpS(s)::wrds) ->
      let new_fields = split_expstring ifs (toCharList s) in
      split_word ifs (f ++ new_fields, wrds)
  | (f, UsrS(s)::wrds) -> split_word ifs (f ++ [Field (stringToSymbolicString s)], wrds)
  | (f, DQuo(s)::wrds) -> split_word ifs (f ++ [QField (stringToSymbolicString s)], wrds)
  | (f, EWSym sym::wrds) -> split_word ifs (f ++ [Field [Sym sym]], wrds)
  end

let split_fields s0 exp_words =
  let ifs = lookup_param s0 "IFS" in
  let (f, _) = match ifs with
    | Nothing -> split_word (toCharList " \n\t") ([], exp_words)
    | Just fs -> 
       match try_concrete fs with
       | Nothing -> (* TODO symbolic, a symbolic IFS makes it nearly-impossible to model field splitting *)
          split_word (toCharList " \n\t") ([], exp_words)
       | Just "" -> ([Field (concat_expanded exp_words)], [])
       | Just s -> split_word (toCharList s) ([], exp_words)
       end
  end in f

let rec combine_fields f =
  match f with
  | [] -> []
  | [WFS] -> [] (* Remove trailing field separators *)
  | (WFS::WFS::rst) -> combine_fields (WFS::rst) (* Combine adjacent whitespace separators *)
  | (WFS::FS::rst) -> combine_fields (FS::rst)
  | (FS::WFS::rst) -> combine_fields (FS::rst)
  | (Field(s1)::Field(s2)::rst) -> combine_fields (Field(s1 ++ s2)::rst)
  | (WFS::rst) -> FS::(combine_fields rst)
  | (f::rst) -> f::(combine_fields rst)
  end

let rec clean_fields f =
  match f with
  | (WFS::rst) -> clean_fields rst
  | _ -> combine_fields f
  end

let field_splitting s0 w = clean_fields (split_fields s0 w)

(*
 * Stage 3 Expansion: Pathname expansion
 *)

val insert_field_separators : list string -> intermediate_fields
let rec insert_field_separators fs =
  match fs with
  | [] -> []
  | [f] -> [Field (stringToSymbolicString f)]
  | f::fs' -> Field (stringToSymbolicString f)::FS::insert_field_separators fs'
  end
    
val pathname_expansion : ty_os_state -> intermediate_fields -> intermediate_fields

(* Parameter expansion only happens on unquoted fields *)
let rec pathname_expansion s0 f =
  match f with
  | [] -> []
  | (Field(s)::rst) -> 
     let matches = 
       match try_concrete s with
       | Just pat -> match_path s0 pat
       | Nothing -> [] (* slightly inaccurate: we're not modeling symbolic pathname expansions *)
       end 
     in
     let expansions = 
       if null matches 
       then [Field s] 
       else insert_field_separators matches 
     in
     expansions ++ pathname_expansion s0 rst
  | (f::rst) -> f::(pathname_expansion s0 rst)
  end

(*
 * Stage 4 Expansion: Quote Removal
 *)

val remove_quotes : intermediate_fields -> intermediate_fields
val to_fields : intermediate_fields -> fields
val finalize_fields : intermediate_fields -> fields
val quote_removal : ty_os_state -> intermediate_fields -> fields

let rec remove_quotes f =
  match f with
  | [] -> []
  | (QField(s)::rst) -> Field(s)::(remove_quotes rst)
  | (f::rst) -> f::(remove_quotes rst)
  end

let rec to_fields f =
  match f with
  | []           -> []
  | FS::FS::rst  -> (stringToSymbolicString "")::(to_fields rst)
  | Field fs::rst -> 
     fs::(to_fields rst)
  | FS::rst      -> to_fields rst
  (* TODO 2017-12-01 Preferably we need an AST that doesn't have WFS or QField's at this point, or lem failure *)
  | WFS::_       -> [stringToSymbolicString "broken invariant"]
  | QField _::_  -> [stringToSymbolicString "broken invariant"]
  end

let rec finalize_fields f =
  match f with
  | (FS::rst) -> stringToSymbolicString ""::finalize_fields rst
  | _ -> to_fields f
  end

let quote_removal _s0 f =
  let no_quotes = combine_fields (remove_quotes f) in
  finalize_fields no_quotes

(**********************************************************************)
(* EXPANSION TRANSITIONS **********************************************)
(**********************************************************************)

val step_expansion : ty_os_state * expansion_state -> ty_os_state * expansion_state * expansion_step
let step_expansion (os0,st) =
  match st with
  | ExpStart w0 -> 
     match expand_words os0 Unquoted UserString ([],w0) with
     | Right (step, os1, f1, w1) -> (os1, ExpExpand f1 w1, step)
     | Left (step, os1, f1) -> (os1, ExpError (fields_of_expanded_words f1), step)
     end
  | ExpExpand f0 w0 -> 
     match expand_words os0 Unquoted UserString (f0,w0) with
     | Right (step, os1, f1, w1) ->
        match w1 with
        | [] -> (os1, ExpSplit f1, step)
        | _ ->  (os1, ExpExpand f1 w1, step)
        end
     | Left (step, os1, f1) -> (os1, ExpError (fields_of_expanded_words f1), step)
     end
  | ExpSplit f0 -> (os0, ExpPath (field_splitting os0 f0), ESSplit "")
  | ExpPath ifs0 -> (os0, ExpQuote (pathname_expansion os0 ifs0), ESPath "")
  | ExpQuote ifs0 -> (os0, ExpDone (quote_removal os0 ifs0), ESQuote "")
  (* the following cases should never occur in calls from trace_expansion: *)
  | ExpError _ -> (os0, st, ESStep "done in error state")
  | ExpDone _ -> (os0, st, ESStep "done in success state")
  end

val trace_expansion : ty_os_state * expansion_state -> list (ty_os_state * expansion_state * expansion_step)
let rec trace_expansion (os0,st0) =
  match st0 with
  | ExpError _ -> []
  | ExpDone _ -> []
  | _ -> 
     let (os1,st1,step) = step_expansion (os0,st0) in
     (os1,st1,step)::trace_expansion (os1,st1)
  end

(* function for testing final expansion results (used in
   test_expansion.ml)

   this function is a little unfaithful to the expansion semantics
   because we're not keeping track of whether the result was a message
   printed to stderr or the actual result of expansion
 *)
val full_expansion : ty_os_state -> words -> ty_os_state * fields
let full_expansion s0 w0 =
  let (s1,f1,_) = last (trace_expansion (s0, ExpStart w0)) in
  match f1 with
  | ExpError f -> (s1, f)
  | ExpDone f -> (s1, f)
  | _ -> (s1, [stringToSymbolicString "!!! broken invariant"])
  end
