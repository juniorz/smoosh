open import Pervasives_extra

(*
Strings will be whatever lem uses for string
??? What character set does lem use for strings? Does it matter?
*)

type expanded_word =
   ExpS of string
 | ExpDQ of string

type expanded_words = list expanded_word

type fields = list string

type quoting_mode =
    Unquoted
  | Quoted

type format =
    Normal
  | Default of words
  | NDefault of words
  | Assign of words
  | NAssign of words
  | Error of words
  | NError of words
  | Alt of words
  | NAlt of words
  | Length
  | ShortestPrefix of words
  | LongestPrefix of words
  | ShortestSuffix of words
  | LongestSuffix of words

(* Treating parameters niavely led to a problem when evaluating
 * ${x=${x=foo}bar${x=baz}} incorrectly when x was unset
 *)
and control =
    Tilde
  | TildeUser of string
  | Param of string * format
  | LAssign of string * expanded_words * words
  | Backtick of words
  | Arith of words
  | Quote of words
  (* Is this needed anymore? *)
  (*| Nested of quoting_mode * words*)

and entry =
    S of string
  | DQ of string
  | K of control
  | F

and words = list entry

  (* Left is what has been parsed, right is unparsed *)
and expansion_state = words * words

val string_of_words : words -> string
val string_of_entry : entry -> string

let rec string_of_words w = List.foldr (^) "" (List.map string_of_entry w)
and string_of_entry e =
  match e with
  | S str -> "S(" ^ str ^ ")"
  | DQ string -> "\"" ^ string ^ "\""
  | K _ -> "<<CTRL>>"
  | F -> "<<FS>>"
  end

(*-------------------------------*)
(* Process ids                   *)
(*-------------------------------*)

type ty_pid = Pid of nat (*o with sexp o*) (* coverage:sexp *)
let ty_pid_compare (Pid n0) (Pid n1) = compare n0 n1
instance ( SetType ty_pid )
  let setElemCompare = ty_pid_compare
end

instance (Eq ty_pid)
  let (=) = unsafe_structural_equality
  let (<>) = unsafe_structural_inequality
end

val dest_PID : ty_pid -> nat
let dest_PID x = (match x with Pid n -> n end) (* coverage:unused *)

(* From t_fs_spec.lem_cppo line 1187 *)
type ty_os_state = <|
    shell_env: Map.map string string
  |>

(*
 * Stage 1 Expansion: Word expansion
 *
 * TODO : Add prefix/suffix.
 * TODO: Error properly
 *)

val lookup_param : ty_os_state -> string -> maybe string
val concat_expanded : expanded_words -> string

val expand_param : ty_os_state -> quoting_mode -> string -> format -> words
val expand_control : ty_os_state -> quoting_mode -> control -> (ty_os_state * expanded_words * words)
val expand_words : ty_os_state -> quoting_mode -> (expanded_words * words) -> (ty_os_state * expanded_words * words)
val stage_one_expansion : ty_os_state -> quoting_mode -> words -> (ty_os_state * expanded_words)

(* The result is nothing if the parameter is unset, and the empty string null. *)
let lookup_param s0 str = Map.lookup str s0.shell_env

let rec concat_expanded w =
  match w with
  | [] -> ""
  | (ExpS(s)::ws) -> s ^ concat_expanded ws
  | (ExpDQ(s)::ws) -> s ^ concat_expanded ws
  end

let rec expand_param s0 q str f =
  (let value = lookup_param s0 str in
  (match value with
    | Nothing -> (match f with
      | Default w  -> w
      | NDefault w  -> w
      | Assign w -> [K (LAssign str [] w)]
      | NAssign w  -> [K (LAssign str [] w)]
      | Error _    -> [S "error"] (* This should error *)
      | NError _    -> [S "error"] (* This should error *)
      | Length     -> [S ("0")]
      | _          -> [S ("")] (* null *)
      end)
    | Just "" -> (match f with
      | NDefault w -> w
      | Alt w      -> w
      | NError _    -> [S "error"] (* This should error *)
      | Length     -> [S ("0")]
      | _          -> [S ("")] (* null *)
      end)
    | Just v -> (match f with
      | Alt w  -> w
      | NAlt w -> w
      | Length -> [S (show (stringLength v))]
      | _      -> [S (v)]
      end)
  end))

and expand_control s0 q k =
(*
 * TODO: TildeUser
 * TODO: Backtick
 * TODO: Evaluate Arith
 * TODO: Nested
 *)
  match k with
    | Tilde -> (s0, [], expand_param s0 Unquoted "HOME" Normal)
    | TildeUser usr -> (s0, [], [S "error"]) (* This should call system *)
    | Param s f -> (s0, [], expand_param s0 q s f)
    | LAssign s f [] ->
        let s1 = <| s0 with shell_env = Map.insert s (concat_expanded f) s0.shell_env |> in
        (s1, f, [])
    | LAssign s f w ->
        let (s1, f1, w1) = expand_words s0 q ([], w) in
        (s1, [], [K (LAssign s (f ++ f1) w1)])
    | Backtick w -> (s0, [], [S "error"]) (* This should create a new bash env *)
    | Arith w -> let (s1, f1, w1) = expand_words s0 q ([],w) in
        (s1, [], [K (Arith w1)])
    | Quote w -> let (s1, f1, w1) = expand_words s0 Quoted ([],w) in
        match w1 with
        | [] -> (s1, f1, [])
        | _ -> (s1, f1, [K (Quote (w1))])
        end
    (*| Nested (q, st) -> [K (Nested (q, expand_words *)
  end

and expand_words s0 q (f,w) =
  match w with
    | [] -> (s0, f, w)
    | (F::ws) -> let (s1,f1,w1) = (expand_words s0 q ([],ws)) in
        (s1, f ++ f1, w1)
    | (S(s)::ws) -> if q = Quoted then (s0, f ++ [ExpDQ s], ws) else (s0, f ++ [ExpS s], ws)
    | (DQ(s)::ws) -> (s0, f ++ [ExpDQ s], ws)
    | (K(k)::ws) -> let (s1,f1,w1) = expand_control s0 q k in
        (s1, f++f1, (w1 ++ ws))
  end

and stage_one_expansion s0 q w =
  let (s1, f1, w1) = expand_words s0 q ([],w) in
  match w1 with
  | [] -> (s1, f1)
  | _ -> let (s2, f2) = stage_one_expansion s1 q w1 in
                        (s2, (f1 ++ f2))
  end

(*
 * Stage 2 Expansion: Field Splitting
 *)

type tmp_field =
    WFS
  | FS
  | Field of string
  | QField of string

type intermediate_fields = list tmp_field

val is_whitespace : char -> bool
val collect_non_ifs : list char -> list char -> (list char) * (list char)
(*val collect_ifs_whitespace : list char -> list char -> list char*)
val split_string : list char -> list char -> intermediate_fields
val split_word : list char -> (intermediate_fields * expanded_words) -> (intermediate_fields * expanded_words)
val split_fields : ty_os_state -> expanded_words -> intermediate_fields
val clean_fields : intermediate_fields -> intermediate_fields
val stage_two_expansion : ty_os_state -> expanded_words -> intermediate_fields

let is_whitespace c = elem c (toCharList " \n\t")

let rec collect_non_ifs ifs ls =
  match ls with
  | [] -> ([], [])
  | (c::cs) ->
      if elem c ifs
      then ([], c::cs)
      else let (f, remaining) = collect_non_ifs ifs cs in
           (c::f, remaining)
  end

let rec split_string ifs clst =
   match clst with
   | [] -> []
   | c::cs ->
       if elem c ifs
       then let fs = if is_whitespace c then WFS else FS in fs::split_string ifs cs
       else let (cc, cs1) = (collect_non_ifs ifs cs) in (Field (toString (c::cc)))::(split_string ifs cs1)
  end

let rec split_word ifs p =
  match p with
  | (f, []) -> (f, [])
  | (f, ExpS(s)::wrds) ->
      let new_fields = split_string ifs (toCharList s) in
      split_word ifs (f ++ new_fields, wrds)
  | (f, ExpDQ(s)::wrds) -> split_word ifs (f ++ [QField s], wrds)
  end

let split_fields s0 exp_words =
  let ifs = lookup_param s0 "IFS" in
  let (f, _) = match ifs with
    | Nothing -> split_word (toCharList " \n\t") ([], exp_words)
    | Just "" -> ([Field (concat_expanded exp_words)], [])
    | Just s -> split_word (toCharList s) ([], exp_words)
  end in f

let rec combine_fields f =
  match f with
  | [] -> []
  | [WFS] -> [] (* Remove trailing field separators *)
  | (WFS::WFS::rst) -> combine_fields (WFS::rst) (* Combine adjacent whitespace separators *)
  | (WFS::FS::rst) -> combine_fields (FS::rst)
  | (FS::WFS::rst) -> combine_fields (FS::rst)
  | (Field(s1)::Field(s2)::rst) -> combine_fields (Field(s1 ^ s2)::rst)
  | (WFS::rst) -> FS::(combine_fields rst)
  | (f::rst) -> f::(combine_fields rst)
  end

let rec clean_fields f =
  match f with
  | (WFS::rst) -> clean_fields rst
  | _ -> combine_fields f
  end

let stage_two_expansion s0 w = clean_fields (split_fields s0 w)

(*
 * Stage 3 Expansion: Pathname expansion
 *)

val pathname_expansion : ty_os_state -> string -> intermediate_fields
val stage_three_expansion : ty_os_state -> intermediate_fields -> intermediate_fields

let pathname_expansion s0 s = [Field s]

(* Parameter expansion only happens on unquoted fields *)
let rec stage_three_expansion s0 f =
  match f with
  | [] -> []
  | (Field(s)::rst) -> (pathname_expansion s0 s) ++ (stage_three_expansion s0 rst)
  | (f::rst) -> f::(stage_three_expansion s0 rst)
  end

(*
 * Stage 4 Expansion: Quote Removal
 *)

val remove_quotes : intermediate_fields -> intermediate_fields
val to_fields : intermediate_fields -> fields
val finalize_fields : intermediate_fields -> fields
val stage_four_expansion : ty_os_state -> intermediate_fields -> fields

let rec remove_quotes f =
  match f with
  | [] -> []
  | (QField(s)::rst) -> Field(s)::(remove_quotes rst)
  | (f::rst) -> f::(remove_quotes rst)
  end

let rec to_fields f =
  match f with
  | [] -> []
  | FS::FS::rst -> ""::(to_fields rst)
  | Field(s)::rst -> s::(to_fields rst)
  | FS::rst -> to_fields rst
  end

let rec finalize_fields f =
  match f with
  | (FS::rst) -> ""::(finalize_fields rst)
  | _ -> to_fields f
  end

let stage_four_expansion s0 f =
  let no_quotes = combine_fields (remove_quotes f) in
  finalize_fields no_quotes

(*
 * Run a full expansion on the given words
 *)

val full_expansion : ty_os_state -> words -> ty_os_state * fields
let full_expansion s0 w_in =
  let (s1, f1_out) = stage_one_expansion s0 Unquoted w_in in
  let f2_out = (stage_two_expansion s1 f1_out) in
  let f3_out = stage_three_expansion s1 f2_out in
  let f4_out = stage_four_expansion s1 f3_out in
  (s1, f4_out)

