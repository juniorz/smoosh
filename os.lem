open import Fsh_prelude
import Debug
                                   

(**********************************************************************)
(* FS/OS CLASS ********************************************************)
(**********************************************************************)

(* TODO 2018-08-14 file contents? will allow for use of, e.g., /etc/passwd *)           
type file 'a = File | Dir of 'a

(* Data structures for symbolic FDs *)
type fd_tgt = FD of nat | Path of path

(* Mapping of FDs numbers *)
type fds = Map.map fd fd_tgt

val path_dotdot_rev_cl : list char -> list char
let rec path_dotdot_rev_cl path =
  match path with
  | [] -> [#'/'] (* stop at the root *)
  | [#'/'] -> [#'/'] (* stop at the root *)
  | #'/'::rest -> rest
  | _::rest -> path_dotdot_rev_cl rest
  end
                            
val dotdot : path -> path
let dotdot path = toString (reverse (path_dotdot_rev_cl (reverse (toCharList path))))

class ( OS 'a )
  val get_shell_state : 'a -> ty_shell_state
  val set_shell_state : ty_shell_state -> 'a -> 'a

  (* SYSTEM CALLS *)
  val getpwnam : 'a -> string -> maybe string
  val fork_and_execve : 'a -> symbolic_string -> list symbolic_string -> env -> 'a * nat
  val fork_and_subshell : 
    (* need to be passed eval to close the recursive knot for the real OS *)
    ('a -> stmt -> nat) ->
    'a -> stmt -> 'a * nat
  val waitpid : 
    (* need to be passed step_eval to close recursive knot for the symbolic OS *)
    ('a -> stmt -> either (evaluation_step * 'a) (evaluation_step * 'a * stmt)) ->
    'a -> nat -> 'a * maybe (either evaluation_step nat)

  (* FS CALLS *)
  val chdir : 'a -> path -> 'a * maybe string
  val file_exists : 'a -> path -> bool
  val isdir : 'a -> path -> bool
  val isexec : 'a -> path -> bool
  val readdir : 'a -> path -> set (path * file unit)
  val write_fd : 'a -> fd -> string -> maybe 'a
  val read_fd : 'a -> fd -> maybe ('a * string)

  (* TODO 2018-08-24 refactor into dup2, open64, open_pipe, fork_and_write_pipe *)
  val redirect : 'a -> expanded_redir -> either string ('a * saved_fds)
  val restore_fd : 'a -> fd -> saved_fd_info -> 'a
end

val try_write_fd : forall 'a. OS 'a => fd -> string -> 'a -> 'a
let try_write_fd fd s os =
  (* TODO 2018-03-02 is this the right behavior when an fd points to a bad fifo, e.g., STDERR is closed? *)
  match write_fd os fd s with
  | Just os' -> os'
  | Nothing -> os
  end
   
val write_stdout : forall 'a. OS 'a => string -> 'a -> 'a
let write_stdout = try_write_fd STDOUT

val write_stderr : forall 'a. OS 'a => string -> 'a -> 'a
let write_stderr = try_write_fd STDERR

val first_is_slash : path -> bool
let first_is_slash path = 
  path <> "" && nth path 0 = #'/'

val last_is_slash : path -> bool
let last_is_slash path = 
  path <> "" && nth path (stringLength path - 1) = #'/'

val join_path : path -> path -> path
let join_path root ext = root ^ (if last_is_slash root then "" else "/") ^ ext

val canonicalize_split_path : forall 'a. OS 'a => 'a -> path -> list string -> maybe string
let rec canonicalize_split_path os path components =
  match components with
  | [] -> Just path
  | ""::components' -> canonicalize_split_path os path components' (* result of // *)
  | "."::components' -> canonicalize_split_path os path components'
  | ".."::components' -> 
     if isdir os path
     then canonicalize_split_path os (dotdot path) components'
     else Nothing
  | dir::components' -> canonicalize_split_path os (join_path path dir) components'
  end

val canonicalize_path : forall 'a. OS 'a => 'a -> path -> maybe path 
let canonicalize_path os path = 
  let (initial,path') =
    match (toCharList path) with
    | #'/'::#'/'::path' -> 
       ("//",toString path') (* save initial double slash---the rest will go *)
    | #'/'::path' -> ("/",toString path')
    | _ -> ("/",path)
    end
  in
  let components = split_string_on false (* not escapable *) #'/' path' in
  canonicalize_split_path os initial components

val restore_fds : forall 'a. OS 'a => 'a -> saved_fds -> 'a
let restore_fds os saved_fds =
  Map_extra.fold 
    (fun orig_fd info os' -> restore_fd os' orig_fd info)
    saved_fds 
    os

(**********************************************************************)
(* SYMBOLIC FS STATE **************************************************)
(**********************************************************************)

(* Broadly, directories map to contents, which are dir trees or files.
 * For now, fine, just using for pathname expansion.
 * TODO: Ultimately, rely on SibylFS's detailed model *)

type symbolic_fs = <|
  parent: maybe symbolic_fs;
  contents: Map.map string (file symbolic_fs)
|>

type fs = symbolic_fs (* shim *)

let symbolic_fs_dotdot fs =
  match fs.parent with
  | Nothing -> fs
  | Just fs' -> fs'
  end

let symbolic_fs_subdir fs name = 
  match Map.lookup name fs.contents with
  | Just (Dir fs) -> Just fs
  | _ -> Nothing
  end

val symbolic_fs_resolve_comps : symbolic_fs -> list string -> maybe (file symbolic_fs)
let rec symbolic_fs_resolve_comps fs comps =
  match comps with
  | [] -> Just (Dir fs)
  | ""::comps' -> symbolic_fs_resolve_comps fs comps'
  | "."::comps' -> symbolic_fs_resolve_comps fs comps'
  | ".."::comps' -> symbolic_fs_resolve_comps (symbolic_fs_dotdot fs) comps'
  | [file] -> Map.lookup file fs.contents
  | dir::comps' ->
     match symbolic_fs_subdir fs dir with
     | Just fs' -> symbolic_fs_resolve_comps fs' comps'
     | Nothing -> Nothing
     end
  end

val symbolic_fs_resolve_path : symbolic_fs -> string -> maybe (file symbolic_fs)
let symbolic_fs_resolve_path fs path =
  let comps = split_string_on false (* not escapable *) #'/' path in
  symbolic_fs_resolve_comps fs comps

val symbolic_fs_resolve_dir : symbolic_fs -> string -> maybe symbolic_fs
let symbolic_fs_resolve_dir fs path = 
  match symbolic_fs_resolve_path fs path with
  | Just (Dir fs') -> Just fs'
  | _ -> Nothing
  end

(* empty FS/OS for testing purposes *)    
let fs_empty =
  <| parent = Nothing;
     contents = Map.empty
  |>

(**********************************************************************)
(* SYMBOLIC OS STATE **************************************************)
(**********************************************************************)

(* FIFO pipes for symbolic FDs *)             
type fifo = string
          
and proc =
    Execve of symbolic_string (* command *) * list symbolic_string (* args *) * env
  | Shell of stmt * ty_shell_state * fds
  | Zombie of nat (* exit code *)

and symbolic_os_state = <|
    symbolic_passwd: Map.map string string; (* TODO relate to /etc/passwd, emulate getpwnam properly in getpwdir *)
    symbolic_sh: ty_shell_state;
    symbolic_sh_fds: fds;
    symbolic_fs_root: fs;
    symbolic_fifos: list fifo;
    symbolic_procs: list proc
  |>
    
(* INVARIANT: the second number here is referring to the indices in os_empty.fifos below *)
let fds_default : fds = Map.insert STDIN (FD 0) (Map.insert STDOUT (FD 1) (Map.insert STDERR (FD 2) Map.empty))

let os_empty : symbolic_os_state = <|
    symbolic_sh = default_shell_state;
    symbolic_sh_fds = fds_default;
    symbolic_passwd = Map.empty;
    symbolic_fs_root = fs_empty;
    symbolic_fifos = ["" (* STDIN *)
                     ;"" (* STDOUT *)
                     ;"" (* STDERR *)
                     ];
    symbolic_procs = []
 |>

(**********************************************************************)
(* SHELL/OS STATE FUNCTIONS *******************************************)
(**********************************************************************)
   
val print_shell_env : forall 'a. OS 'a => 'a -> string
let print_shell_env os = Map_extra.fold (fun k v s -> k ^ " => " ^ string_of_symbolic_string v ^ ", " ^ s) (get_shell_state os).env ""

val lookup_positional_param : forall 'a. OS 'a => nat -> 'a -> maybe symbolic_string
let lookup_positional_param num os =
  let sh = get_shell_state os in
  index sh.positional_params (num - 1)

(* The result is nothing if the parameter is unset, and the empty string null. *)
val lookup_param : forall 'a. OS 'a => 'a -> string -> maybe symbolic_string
let lookup_param os str =
  let sh = get_shell_state os in
  match (readNat (toCharList str),str) with
  | (Right num,_) -> lookup_positional_param num os
  | (Left _,"@") -> Just (symbolic_string_of_string "TODO 2018-03-02") (* positional arguments as fields *)
  | (Left _,"*") -> Just (symbolic_string_of_string "TODO 2018-03-02") (* positional arguments as a string *)
  | (Left _,"#") -> 
     let num_params = length sh.positional_params in
     Just (symbolic_string_of_string (stringFromNat (max 0 (num_params - 1)))) (* number of positional arguments excluding $0 *)
  | (Left _,"-") -> Just (symbolic_string_of_string "TODO 2018-03-02") (* current option flags *)
  | (Left _,"$") -> Just (symbolic_string_of_string "TODO 2018-03-02") (* shell pid *)
  | (Left _,_) -> Map.lookup str sh.env
  end

val lookup_concrete_param : forall 'a. OS 'a => 'a -> string -> maybe string
let lookup_concrete_param os str =
  match lookup_param os str with
  | Nothing -> Nothing
  | Just fs -> try_concrete fs
  end

val update_shell_state : forall 'a. OS 'a => (ty_shell_state -> ty_shell_state) -> 'a -> 'a
let update_shell_state update os =
  set_shell_state (update (get_shell_state os)) os
   
val defun : forall 'a. OS 'a => string -> stmt -> 'a -> 'a
let defun name body os = update_shell_state (fun sh -> <| sh with funcs = Map.insert name body sh.funcs |>) os

val lookup_function : forall 'a. OS 'a => string -> 'a -> maybe stmt
let lookup_function name os = Map.lookup name (get_shell_state os).funcs

val set_param : forall 'a. OS 'a => string -> symbolic_string -> 'a -> 'a
let set_param x v os = update_shell_state (fun sh -> <| sh with env = Map.insert x v sh.env |>) os
  
val set_function_params : forall 'a. OS 'a => nat -> fields -> 'a -> 'a
let set_function_params ln argv os =
  update_shell_state (fun sh -> <| sh with loop_nest = ln; positional_params = argv |>) os

val enter_loop : forall 'a. OS 'a => 'a -> 'a
let enter_loop os = 
  update_shell_state
    (fun sh -> <| sh with loop_nest = sh.loop_nest + 1 |>) os

val exit_loop : forall 'a. OS 'a => 'a -> 'a
let exit_loop os = 
  update_shell_state
    (fun sh -> <| sh with loop_nest = sh.loop_nest - 1 |>) os

val exit_with : forall 'a. OS 'a => nat -> 'a -> 'a
let exit_with ec os = set_param "?" (symbolic_string_of_string (stringFromNat ec)) os

val get_last_exit_code : forall 'a. OS 'a => 'a -> maybe nat
let get_last_exit_code os =
  match lookup_concrete_param os "?" with
  | Nothing -> Nothing
  | Just s -> 
     match readNat (toCharList s) with
     | Right n -> Just n
     | Left _err -> Nothing
     end
  end

val set_last_pid : forall 'a. OS 'a => nat -> 'a -> 'a
let set_last_pid pid os = set_param "!" (symbolic_string_of_string (stringFromNat pid)) os

val is_interactive : forall 'a. OS 'a => 'a -> bool
let is_interactive os =
  match lookup_concrete_param os "-" with
  | Nothing -> false
  | Just opts -> elem #'i' (toCharList opts)
  end
  
(**********************************************************************)
(* SYMBOLIC OS STATE INSTANCE *****************************************)
(**********************************************************************)

val compare_by_first : forall 'a 'b. Ord 'a => ('a * 'b) -> ('a * 'b) -> ordering
let compare_by_first (a, _) (a', _) = compare a a'

val symbolic_resolve_fd : symbolic_os_state -> fd -> maybe nat
let symbolic_resolve_fd os fd =
  match Map.lookup fd os.symbolic_sh_fds with
  | Just (FD fifo_num) -> Just fifo_num
  (* TODO 2018-03-23 is this the right behavior when fd points to a file? *)   
  (* TODO 2018-03-02 is this the right behavior when fd doesn't exist? *)
  | _ -> Nothing
  end
    
instance (OS symbolic_os_state)
   
  let get_shell_state os = os.symbolic_sh
  let set_shell_state new_sh os = <| os with symbolic_sh = new_sh |>
  let getpwnam os u = Map.lookup u os.symbolic_passwd

  let fork_and_execve os prog argv env =
    (* TODO 2018-02-09 choose valid process numbers (e.g., 0 and 1 are reserved on Linux) *)
    let proc_num = length os.symbolic_procs in
    (<| os with symbolic_procs = os.symbolic_procs ++ [Execve prog argv env] |>, 
     proc_num)

  let fork_and_subshell _eval os stmt =
    let proc_num = length os.symbolic_procs in
    (<| os with symbolic_procs = os.symbolic_procs ++ [Shell stmt os.symbolic_sh os.symbolic_sh_fds] |>, 
     proc_num)

  let waitpid step_eval os0 pid =
    match index os0.symbolic_procs pid with
    | Nothing -> (os0, Nothing)
    | Just (Execve _ _ _) -> (os0, Nothing)
    | Just (Zombie ec) -> (os0, Just (Right ec))
    | Just (Shell stmt sh' fds') ->
       let os1 = <| os0 with symbolic_sh = sh'; symbolic_sh_fds = fds' |> in
       match step_eval os1 stmt with
       | Left (_step, os2) -> (os2, Just (Right 1)) (* errored, signal with code *)
       | Right (_step, os2, Done) ->
          (* terminated! grab the code, update everything *)
          let ec = (* can't use get_last_exit_code because we're DEFINING the type class *)
            match Map.lookup "?" os2.symbolic_sh.env with
            | Nothing -> 255
            | Just ss -> 
               match try_concrete ss with
               | Nothing -> 255
               | Just s -> 
                  match readNat (toCharList s) with
                  | Right n -> n
                  | Left _err -> 255
                  end
               end
            end in
          (<| os2 with symbolic_sh = os0.symbolic_sh; 
                       symbolic_sh_fds = os0.symbolic_sh_fds;
                       symbolic_procs = update os2.symbolic_procs pid (Zombie ec) |>,
           Just (Right ec))
       | Right (step, os2, stmt') ->
          (<| os2 with symbolic_sh = os0.symbolic_sh; 
                       symbolic_sh_fds = os0.symbolic_sh_fds;
                       symbolic_procs = 
                         update os2.symbolic_procs pid 
                           (Shell stmt' os2.symbolic_sh os2.symbolic_sh_fds) |>,
           Just (Left step))
       end
    end

  let readdir os path =
    (* TODO 2018-08-21 will be buggy on non-absolute paths *)
    match symbolic_fs_resolve_dir os.symbolic_fs_root path with
    | Nothing -> Set.empty
    | Just fs -> 
       Set.map (fun (name,file) ->
           (name,
            match file with
            | File -> File
            | Dir _ -> Dir ()
            end))
         (* Only compare equality for the set based on the keys.
          * Comparing equality of a non-trivial file system will loop infinitely. *)
         (toSetBy compare_by_first fs.contents)
    end

  let chdir os path =
    match symbolic_fs_resolve_dir os.symbolic_fs_root path with
    | Nothing -> (os,Just ("no such directory: " ^ path))
    | Just _ -> (<| os with symbolic_sh = <| os.symbolic_sh with cwd = path |> |>, Nothing)
    end

  let file_exists os path =
    match symbolic_fs_resolve_path os.symbolic_fs_root path with
    | Nothing -> false
    | Just _ -> true
    end

  let isdir os path =
    match symbolic_fs_resolve_path os.symbolic_fs_root path with
    | Just (Dir _) -> true
    | Just File -> false
    | Nothing -> false
    end

  let isexec os path =
    match symbolic_fs_resolve_path os.symbolic_fs_root path with
    | Nothing -> false
    | Just _ -> true
    end

  let write_fd os fd s =
    match symbolic_resolve_fd os fd with
    | Just fifo_num ->
      match adjust_nth os.symbolic_fifos fifo_num (fun fifo_cts -> (fifo_cts ^ s, ())) with
      | Nothing -> Nothing
      | Just (new_fifos,()) -> Just <| os with symbolic_fifos = new_fifos |>
      end
    | Nothing -> Nothing
    end
  
  let read_fd os fd =
    match symbolic_resolve_fd os fd with
    | Just fifo_num ->
      match adjust_nth os.symbolic_fifos fifo_num (fun fifo_cts -> ("",fifo_cts)) with
      | Nothing -> Nothing
      | Just (new_fifos,s) -> Just (<| os with symbolic_fifos = new_fifos |>, s)
      end
    | Nothing -> Nothing
  end

  let redirect os _er = 
    (* TODO 2018-08-24 implement *)
    Left "symbolic redirect is unimplemented"

  let restore_fd os _fd _info =
    (* TODO 2018-08-24 implement *)
    os
end

val set_pwdir : string -> string -> symbolic_os_state -> symbolic_os_state
let set_pwdir u d os = <| os with symbolic_passwd = Map.insert u d (os.symbolic_passwd) |>

val mkfifo : symbolic_os_state -> symbolic_os_state * nat  
let mkfifo os =
  let fifo_num = length os.symbolic_fifos in
  (<| os with symbolic_fifos = os.symbolic_fifos ++ [""] |>, fifo_num)

val mkfifos : symbolic_os_state -> nat -> symbolic_os_state * list nat 
let rec mkfifos os0 n =
  match n with
  | 0 -> (os0, [])
  | _ -> let (os1,fifo) = mkfifo os0 in 
         let (os2,fifos) = mkfifos os1 (n-1) in
         (os2,fifo::fifos)
  end
   
(* specialized functions to avoid manual instantiation of typeclasses in OCaml *)   
val symbolic_set_param : string -> symbolic_string -> symbolic_os_state -> symbolic_os_state
let symbolic_set_param = set_param

val symbolic_print_shell_env : symbolic_os_state -> string
let symbolic_print_shell_env os = print_shell_env os

(**********************************************************************)
(* REAL OS STATE INSTANCE *********************************************)
(**********************************************************************)

type real_os_state = <| real_sh: ty_shell_state |>

let force_concrete ss =
  match try_concrete ss with
  | Just s -> s
  | Nothing -> 
     failwith ("Couldn't convert symbolic string, aborting:\n\n" ^ string_of_symbolic_string ss)
  end

(* generate an 'environ'-style string given an env *)
let environ (env : env) : list string =
  Map_extra.fold (fun x v l -> (x ^ "=" ^ force_concrete v) :: l) env []

val real_getpwnam : string -> maybe string
declare ocaml target_rep function real_getpwnam = `System.real_getpwnam`

val real_fork_and_execve : string -> list string -> list string -> nat
declare ocaml target_rep function real_fork_and_execve = `System.real_fork_and_execve`

val real_fork_and_call : forall 'a 'b. ('a -> 'b) -> 'a -> nat
declare ocaml target_rep function real_fork_and_call = `System.real_fork_and_call`

val real_waitpid : nat -> nat
declare ocaml target_rep function real_waitpid = `System.real_waitpid`

val real_chdir : path -> maybe string
declare ocaml target_rep function real_chdir = `System.real_chdir`

val real_exists : path -> bool
declare ocaml target_rep function real_exists = `System.real_exists`

val real_isdir : path -> bool
declare ocaml target_rep function real_isdir = `System.real_isdir`

val real_isexec : path -> bool
declare ocaml target_rep function real_isexec = `System.real_isexec`

val real_readdir : string -> list (string * bool)
declare ocaml target_rep function real_readdir = `System.real_readdir`

val real_write_fd : fd -> string -> bool
declare ocaml target_rep function real_write_fd = `System.real_write_fd`

val real_read_fd : fd -> maybe string
declare ocaml target_rep function real_read_fd = `System.real_read_fd`

type open_flags
declare ocaml target_rep type open_flags = `System.open_flags` 
val to_flags : open_flags
declare ocaml target_rep function to_flags = `System.to_flags`
val clobber_flags : open_flags
declare ocaml target_rep function clobber_flags = `System.clobber_flags`
val from_flags : open_flags   
declare ocaml target_rep function from_flags = `System.from_flags`
val fromto_flags : open_flags
declare ocaml target_rep function fromto_flags = `System.fromto_flags`
val append_flags : open_flags
declare ocaml target_rep function append_flags = `System.append_flags`

val flags_of_redir_type : redir_type -> open_flags
let flags_of_redir_type rt =
  match rt with
  | To -> to_flags
  | Clobber -> clobber_flags
  | From -> from_flags
  | FromTo -> fromto_flags
  | Append -> append_flags
  end

val real_open : string -> open_flags -> either string fd
declare ocaml target_rep function real_open = `System.real_open`

val real_close : fd -> unit
declare ocaml target_rep function real_close = `System.real_close`

val real_savefd : fd -> either string fd
declare ocaml target_rep function real_savefd = `System.real_savefd`

val real_dup2 : fd -> fd -> maybe string
declare ocaml target_rep function real_dup2 = `System.real_dup2`

val real_openhere : string -> either string fd
declare ocaml target_rep function real_openhere = `System.real_openhere`

let real_renumber_fd os (new_fd : fd) (wanted_fd : fd) : either string ('a * saved_fds) =
  if new_fd = wanted_fd
  then 
    (* we fished our wish! no need to dup or anything.
       just remember to clean up when you're done *)
    Right (os, Map.singleton wanted_fd Close)
    else (* need to save wanted_fd and then dup *)
      match real_savefd wanted_fd with
      | Left err -> Left err
      | Right saved_fd -> 
         match real_dup2 new_fd wanted_fd with
         | Just err -> Left err
         | Nothing -> 
            (* close the actual fd we got, now that we've
               relocated it where we want it *)
            let _ = real_close new_fd in
            Right (os, Map.singleton wanted_fd (Saved saved_fd))
         end
      end

instance (OS real_os_state)
  let get_shell_state os = os.real_sh
  let set_shell_state new_sh os = <| os with real_sh = new_sh |>

  let getpwnam _os nam = real_getpwnam nam

  let fork_and_execve os prog argv env = 
    let pid = 
      real_fork_and_execve 
        (force_concrete prog)
        (map force_concrete argv) 
        (environ env) 
        in
    (os, pid)

  let fork_and_subshell eval os stmt =
    let pid = 
      real_fork_and_call (fun (os,stmt) -> eval os stmt) (os,stmt)
      in
    (os, pid)

  let chdir os path =
    match real_chdir path with
    | Nothing -> (<| os with real_sh = <| os.real_sh with cwd = path |> |>, Nothing)
    | Just err -> (os, Just err)
    end
      
  let file_exists _os path = real_exists path
  let isdir _os path = real_isdir path
  let isexec _os path = real_isexec path

  let readdir _os path = 
    let contents = real_readdir path in
    let convert (f,is_dir) = (f,if is_dir then Dir () else File) in
    Set.fromList (map convert contents)

  let write_fd os fd s =
    if real_write_fd fd s
    then Just os
    else Nothing

  let read_fd os fd =
    match real_read_fd fd with
    | Nothing -> Nothing
    | Just s -> Just (os,s)
    end

  let waitpid _step_eval os pid =
    let code = real_waitpid pid in
    (os,Just (Right code))

  let redirect os er =
    match er with
    | ERFile ty wanted_fd [sfile] -> 
       match try_concrete sfile with
       | Nothing -> 
          Left ("couldn't open redirect to symbolic file: " ^ string_of_symbolic_string sfile)
       | Just file -> 
          let flags = flags_of_redir_type ty in
          match real_open file flags with
          | Left err -> Left err
          | Right new_fd -> real_renumber_fd os new_fd wanted_fd
          end
       end
    | ERFile _ _ fs -> Left ("expected single file field, got: " ^ string_of_fields fs)
    | ERDup _ty orig_fd wanted_fd -> 
       (* dash doesn't distinguish between the two types... because
          both resolve to the same dup2 call, since dup2 doesn't care
          about fd direction *)
       if orig_fd = wanted_fd
       then (* weird, right? I guess you could do this, might as well
               save ourselves the trouble with dup2's interface*)
         Right (os, Map.empty)
       else match real_savefd wanted_fd with
            | Left err -> Left err
            | Right saved_fd ->
               match real_dup2 orig_fd wanted_fd with
               | Just err -> Left err
               | Nothing -> Right (os, Map.singleton wanted_fd (Saved saved_fd))
               end
            end
    | ERHeredoc _ty wanted_fd fs -> 
       (* ty is irrelevant at this point---we used it to determine the
          kinds of expansion we'll go through *)
       match try_concrete_fields fs with
       | Nothing ->
          Left ("couldn't open symbolic heredoc: " ^ string_of_fields fs)
       | Just s ->
          match real_openhere s with
          | Left err -> Left err
          | Right new_fd -> real_renumber_fd os new_fd wanted_fd
          end
       end
    end
   
  let restore_fd os orig_fd info =
    let to_close = 
      match info with
      | Saved saved -> 
         match real_dup2 saved orig_fd with
         | Just _err -> saved (* TODO 2018-08-24 uh oh... signal in some way? *)
         | Nothing -> saved
         end
      | Close -> orig_fd
      end
    in
    let _ = real_close to_close in
    os    

end

val real_lookup_concrete_param : real_os_state -> string -> maybe string
let real_lookup_concrete_param = lookup_concrete_param

val real_set_param : real_os_state -> string -> string -> real_os_state
let real_set_param os x v = set_param x (symbolic_string_of_string v) os

