open import Fsh_prelude

val STDIN : nat
val STDOUT : nat
val STDERR : nat
let STDIN = 0
let STDOUT = 1
let STDERR = 2

(**********************************************************************)
(* FS/OS CLASS ********************************************************)
(**********************************************************************)

(* TODO 2018-03-12

   define OS class
     system calls (execve, etc.)
     FS functionality
       trickiness: no obvious way to embed an existential :(
       possible solution: always use strings for the fs and then resolve?

     offer _some_ symbolic stuff there, but focus on getting the syscalls going

   need to link w/OCaml FFI?
 *)

type file 'a = File | Dir of 'a
                           
class ( FS 'a )
  val fs_file_exists : 'a -> string -> bool
  val fs_is_dir : 'a -> string -> bool
  val fs_is_file : 'a -> string -> bool
  val fs_dotdot : 'a -> 'a
  val fs_subdir : 'a -> string -> maybe 'a
end

type path = string
         
class ( OS 'a )
  val get_shell_state : 'a -> ty_shell_state
  val set_shell_state : ty_shell_state -> 'a -> 'a
  val getpwnam : 'a -> string -> maybe string

  val readdir : 'a -> path -> set (path * file unit)
end

(**********************************************************************)
(* SYMBOLIC FS STATE **************************************************)
(**********************************************************************)

(* Broadly, directories map to contents, which are dir trees or files.
 * For now, fine, just using for pathname expansion.
 *
 * TODO: Ultimately, rely on SibylFS's detailed model *)
type symbolic_fs = <|
  parent: maybe symbolic_fs;
  contents: Map.map string (file symbolic_fs)
|>

type fs = symbolic_fs (* shim *)

instance (FS symbolic_fs)
  let fs_file_exists f name = 
    match Map.lookup name f.contents with
    | Nothing -> false
    | Just _ -> true
    end

  let fs_is_dir f name = 
    match Map.lookup name f.contents with
    | Just File -> false
    | Just (Dir _) -> true
    | Nothing -> false (* ??? *)
    end
  
  let fs_is_file f name = 
    match Map.lookup name f.contents with
    | Just File -> true
    | Just (Dir _) -> false
    | Nothing -> false (* ??? *)
    end

  let fs_dotdot fs =
    match fs.parent with
    | Nothing -> fs
    | Just fs' -> fs'
    end

  let fs_subdir fs name = 
    match Map.lookup name fs.contents with
    | Just (Dir fs) -> Just fs
    | _ -> Nothing
    end
end

val path_dotdot_rev_cl : list char -> list char
let rec path_dotdot_rev_cl path =
  match path with
  | [] -> [#'/'] (* stop at the root *)
  | #'/'::rest -> rest
  | _::rest -> path_dotdot_rev_cl rest
  end
                            
val path_dotdot : path -> path
let path_dotdot path = toString (reverse (path_dotdot_rev_cl (reverse (toCharList path))))
   
val resolve_path_cl : forall 'a. FS 'a => 'a -> list char -> 'a
let rec resolve_path_cl fs cs =
  (* just quit if we're done *)
  if null cs then fs else
  (* otherwise, split off a slash *)
  let (dir,slash_rest) = splitWhile (fun c -> c <> #'/') cs in
  let rest = 
    match slash_rest with
    | #'/'::rest -> rest
    | _ -> slash_rest
    end in
  (* and try to change directories *)
  match dir with
  | [] -> resolve_path_cl fs rest
  | [#'.'] -> resolve_path_cl fs rest
  | [#'.';#'.']-> resolve_path_cl (fs_dotdot fs) rest
  | _ -> 
     match fs_subdir fs (toString dir) with
     | Just fs' -> resolve_path_cl fs' rest
     | _ -> fs (* ??? *)
     end
  end

val resolve_path : forall 'a. FS 'a => 'a -> string -> 'a
let resolve_path fs path = resolve_path_cl fs (toCharList path)  

(* empty FS/OS for testing purposes *)    
let fs_empty =
  <| parent = Nothing;
     contents = Map.empty
  |>

(**********************************************************************)
(* SYMBOLIC OS STATE **************************************************)
(**********************************************************************)

(* FIFO pipes *)             
type fifo = string

and fds = Map.map fd nat (* index into global fifo list *)

and proc =
    Execve of symbolic_string (* command *) * list symbolic_string (* args *) * env * fds
  | Shell of ty_shell_state * fds
           
and symbolic_os_state = <|
    passwd: Map.map string string; (* TODO relate to /etc/passwd, emulate getpwnam properly in getpwdir TODO 2018-02-09 move to actual filesystem *)
    sh: ty_shell_state;
    sh_fds: fds;
    fs_root: fs;
    fifos: list fifo;
    procs: list proc
  |>

type ty_os_state = symbolic_os_state (* shim *)

(* INVARIANT: the second number here is referring to the indices in os_empty.fifos below *)
let fds_default : fds = Map.insert STDIN 0 (Map.insert STDOUT 1 (Map.insert STDERR 2 Map.empty))
    
let os_empty : ty_os_state = <|
    sh = default_shell_state;
    sh_fds = fds_default;
    passwd = Map.empty;
    fs_root = fs_empty;
    fifos = ["" (* STDIN *)
            ;"" (* STDOUT *)
            ;"" (* STDERR *)
            ];
    procs = []
 |>

(**********************************************************************)
(* SHELL/OS STATE FUNCTIONS *******************************************)
(**********************************************************************)
   
val print_shell_env : ty_os_state -> string
let print_shell_env st = Map_extra.fold (fun k v s -> k ^ " => " ^ string_of_symbolic_string v ^ ", " ^ s) st.sh.env ""

val lookup_positional_param : nat -> ty_os_state -> maybe symbolic_string
let lookup_positional_param num os =
  if num = 0
  then Just (symbolic_string_of_string os.sh.script_name)
  (* -1 for positional param offset (ie, $0 is stored elsewhere *)
  else index os.sh.positional_params (num - 1)

(* The result is nothing if the parameter is unset, and the empty string null. *)
val lookup_param : ty_os_state -> string -> maybe symbolic_string
let lookup_param s0 str =
  match (readNat (toCharList str),str) with
  | (Right num,_) -> lookup_positional_param num s0
  | (Left _,"@") -> Just (symbolic_string_of_string "TODO 2018-03-02") (* positional arguments as fields *)
  | (Left _,"*") -> Just (symbolic_string_of_string "TODO 2018-03-02") (* positional arguments as a string *)
  | (Left _,"#") -> Just (symbolic_string_of_string (stringFromNat (length s0.sh.positional_params))) (* number of positional arguments *)
  | (Left _,"!") -> Just (symbolic_string_of_string "TODO 2018-03-02") (* last pid *)
  | (Left _,"-") -> Just (symbolic_string_of_string "TODO 2018-03-02") (* current option flags *)
  | (Left _,"$") -> Just (symbolic_string_of_string "TODO 2018-03-02") (* shell pid *)
  | (Left _,_) -> Map.lookup str s0.sh.env
  end

val lookup_concrete_param : ty_os_state -> string -> maybe string
let lookup_concrete_param s0 str =
  match Map.lookup str s0.sh.env with
  | Nothing -> Nothing
  | Just fs -> try_concrete fs
  end

val set_param : string -> symbolic_string -> ty_os_state -> ty_os_state
let set_param x v os = <| os with sh = <| os.sh with env = Map.insert x v os.sh.env |> |>

val defun : string -> stmt -> ty_os_state -> ty_os_state
let defun name body os = <| os with sh = <| os.sh with funcs = Map.insert name body os.sh.funcs |> |>

val lookup_function : forall 'a. OS 'a => string -> 'a -> maybe stmt
let lookup_function name os = Map.lookup name (get_shell_state os).funcs

val update_shell_state : forall 'a. OS 'a => (ty_shell_state -> ty_shell_state) -> 'a -> 'a
let update_shell_state update os =
  set_shell_state (update (get_shell_state os)) os

val set_function_params : forall 'a. OS 'a => nat -> fields -> 'a -> 'a
let set_function_params ln argv os =
  update_shell_state (fun sh -> <| sh with loop_nest = ln; positional_params = argv |>) os

val get_script_name : forall 'a. OS 'a => 'a -> string
let get_script_name os = (get_shell_state os).script_name

val enter_loop : forall 'a. OS 'a => 'a -> 'a
let enter_loop os = 
  update_shell_state
    (fun sh -> <| sh with loop_nest = sh.loop_nest + 1 |>) os

val exit_loop : forall 'a. OS 'a => 'a -> 'a
let exit_loop os = 
  update_shell_state
    (fun sh -> <| sh with loop_nest = sh.loop_nest - 1 |>) os

val set_pwdir : string -> string -> ty_os_state -> ty_os_state
let set_pwdir u d os = <| os with passwd = Map.insert u d (os.passwd) |>

val mkfifo : ty_os_state -> ty_os_state * nat
let mkfifo os =
  let fifo_num = length os.fifos in
  (<| os with fifos = os.fifos ++ [""] |>, fifo_num)

val mkfifos : ty_os_state -> nat -> ty_os_state * list nat 
let rec mkfifos os0 n =
  match n with
  | 0 -> (os0, [])
  | _ -> let (os1,fifo) = mkfifo os0 in 
         let (os2,fifos) = mkfifos os1 (n-1) in
         (os2,fifo::fifos)
  end

val adjust_nth : forall 'a 'b. list 'a -> nat -> ('a -> 'a * 'b) -> maybe (list 'a * 'b)
let rec adjust_nth l n f =
  match (l,n) with
  | ([],_) -> Nothing
  | (v::l',0) -> 
     let (v',res) = f v in
     Just (v'::l',res)
  | (v::l',_) ->
     match adjust_nth l' (n-1) f with
     | Nothing -> Nothing
     | Just (l'',res) -> Just (v::l'',res)
     end
  end
  
val write_fifo : ty_os_state -> nat -> string -> maybe ty_os_state
let write_fifo os fifo_num s =
  match adjust_nth os.fifos fifo_num (fun fifo_cts -> (fifo_cts ^ s, ())) with
  | Nothing -> Nothing
  | Just (new_fifos,()) -> Just <| os with fifos = new_fifos |>
  end

val read_fifo : ty_os_state -> nat -> maybe (ty_os_state * string)
let read_fifo os fifo_num =
  match adjust_nth os.fifos fifo_num (fun fifo_cts -> ("",fifo_cts)) with
  | Nothing -> Nothing
  | Just (new_fifos,s) -> Just (<| os with fifos = new_fifos |>, s)
  end

val print_stderr : ty_os_state -> string -> ty_os_state
let print_stderr os msg = 
  (* lookup where STDERR is pointing *)
  match Map.lookup STDERR os.sh_fds with
  | Just fifo_num -> 
     match write_fifo os fifo_num msg with
     (* TODO 2018-03-02 is this the right behavior when STDERR points to a bad fifo? *)
     | Nothing -> os
     | Just os -> os
     end
  (* TODO 2018-03-02 is this the right behavior when STDERR doesn't exist? *)
  | Nothing -> os
  end

val execve : ty_os_state -> symbolic_string -> list symbolic_string -> env -> fds -> ty_os_state * nat
let execve os prog argv env fds =
  (* TODO 2018-02-09 choose valid process numbers (e.g., 0 and 1 are reserved on Linux) *)
  let proc_num = length os.procs in
  (<| os with procs = os.procs ++ [Execve prog argv env fds] |>, proc_num)

(**********************************************************************)
(* SYMBOLIC SHELL STATE ***********************************************)
(**********************************************************************)

val compare_by_first : forall 'a 'b. Ord 'a => ('a * 'b) -> ('a * 'b) -> ordering
let compare_by_first (a, _) (a', _) = compare a a'
    
instance (OS symbolic_os_state)
  let get_shell_state os = os.sh
  let set_shell_state new_sh os = <| os with sh = new_sh |>
  let getpwnam os u = Map.lookup u os.passwd
                                   
  let readdir os path =
    Set.map (fun (name,file) ->
        (name,
         match file with
         | File -> File
         | Dir _ -> Dir ()
         end))
      (* Only compare equality for the set based on the keys.
       * Comparing equality of a non-trivial file system will loop infinitely. *)
      (toSetBy compare_by_first (resolve_path os.fs_root path).contents)
end
