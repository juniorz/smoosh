(*
 * Parse and evaluate a string representing the arithmetic operation
 *)
open import Pervasives_extra

type arith_token 'a =
    TNum of 'a
  | TVar of string
  | TPlus | TMinus
  | TTimes | TDiv | TMod
  | TBitNot | TBoolNot (* Is '!' actually allowed? *)
  | TLShift | TRShift
  | TLt | TLte
  | TGt | TGte
  | TEq | TNEq
  | TBitAnd | TBitOr | TBitXOr
  | TBoolAnd | TBoolOr
  | TQuestion | TColon (* For 1 ? 17 : 18 *)
  | TVarEq
  | TVarPlusEq | TVarMinusEq
  | TVarTimesEq | TVarDivEq | TVarModEq
  | TVarLShiftEq | TVarRShiftEq
  | TVarBitAndEq | TVarBitOrEq | TVarBitXOrEq
  | TLParen | TRParen

type BinaryOperator =
    Plus
  | Minus
  | Times
  | Div
  | Mod
  | LShift
  | RShift
  | Lt
  | Lte
  | Gt
  | Gte
  | Eq
  | NEq
  | BitAnd
  | BitOr
  | BitXOr
  | BoolAnd
  | BoolOr

type arith_exp 'a =
    Num of 'a
  | Neg of arith_exp 'a
  | BitNot of arith_exp 'a
  | BoolNot of arith_exp 'a
  | Conditional of arith_exp 'a * arith_exp 'a * arith_exp 'a
  | BinOp of BinaryOperator * arith_exp 'a * arith_exp 'a

class ( Read 'a )
  val read : list char -> maybe 'a
end

instance ( Read integer )
  let read cs = Just (integerOfString (toString cs))
end

val lexer : forall 'a. Read 'a => (list char) -> list (arith_token 'a)
val span : (char -> bool) -> (list char) -> ((list char) * list char)

let is_whitespace c = elem c (toCharList " \n\t")
let is_digit c = elem c (toCharList "1234567890")
let is_alpha c = elem c (toCharList "abcdefghijklnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

let is_plus c =
  match c with
  | #'+' -> true
  | _ -> false
  end

let rec span f l =
  match l with
  | [] -> ([],[])
  | c::cs ->
      if f c
      then let (s, rst) = span f cs
           in (c::s, rst)
      else ([], c::cs)
  end

let rec lexer str =
  match str with
  | [] -> []
  | (#'^'::#'='::cs) -> TVarBitXOrEq::(lexer cs)
  | (#'|'::#'='::cs) -> TVarBitOrEq::(lexer cs)
  | (#'&'::#'='::cs) -> TVarBitAndEq::(lexer cs)
  | (#'>'::#'>'::#'='::cs) -> TVarRShiftEq::(lexer cs)
  | (#'<'::#'<'::#'='::cs) -> TVarLShiftEq::(lexer cs)
  | (#'%'::#'='::cs) -> TVarModEq::(lexer cs)
  | (#'/'::#'='::cs) -> TVarDivEq::(lexer cs)
  | (#'*'::#'='::cs) -> TVarTimesEq::(lexer cs)
  | (#'-'::#'='::cs) -> TVarMinusEq::(lexer cs)
  | (#'+'::#'='::cs) -> TVarPlusEq::(lexer cs)
  | (#'='::#'='::cs) -> TEq::(lexer cs)
  | (#'!'::#'='::cs) -> TNEq::(lexer cs)
  | (#'>'::#'>'::cs) -> TRShift::(lexer cs)
  | (#'<'::#'<'::cs) -> TLShift::(lexer cs)
  | (#'&'::#'&'::cs) -> TBoolAnd::(lexer cs)
  | (#'|'::#'|'::cs) -> TBoolOr::(lexer cs)
  | (#'='::cs) -> TVarEq::(lexer cs)
  | (#':'::cs) -> TColon::(lexer cs)
  | (#'?'::cs) -> TQuestion::(lexer cs)
  | (#'^'::cs) -> TBitXOr::(lexer cs)
  | (#'|'::cs) -> TBitOr::(lexer cs)
  | (#'&'::cs) -> TBitAnd::(lexer cs)
  | (#'>'::#'='::cs) -> TGte::(lexer cs)
  | (#'<'::#'='::cs) -> TLte::(lexer cs)
  | (#'>'::cs) -> TGt::(lexer cs)
  | (#'<'::cs) -> TLt::(lexer cs)
  | (#'!'::cs) -> TBoolNot::(lexer cs)
  | (#'~'::cs) -> TBitNot::(lexer cs)
  | (#'%'::cs) -> TMod::(lexer cs)
  | (#'/'::cs) -> TDiv::(lexer cs)
  | (#'*'::cs) -> TTimes::(lexer cs)
  | (#'-'::cs) -> TMinus::(lexer cs)
  | (#'+'::cs) -> TPlus::(lexer cs)
  | (#'('::cs) -> TLParen::(lexer cs)
  | (#')'::cs) -> TRParen::(lexer cs)
  | (c::cs) ->
      match (is_digit c, is_alpha c) with
      | (true, _) -> let (digit, rst) = span is_digit cs
                     in match read (c::digit) with
                     | Just n -> TNum n::(lexer rst)
                     | Nothing -> lexer rst (* TODO should error *)
                     end
      | (_, true) -> let (var, rst) = span is_alpha cs
                     in TVar (toString (c::var))::(lexer rst)
      | (false, false) -> if is_whitespace c then lexer cs else lexer cs (* ignores all unrecognized characters. TODO: else branch should error *)
      end
  end

val parse_assignment : forall 'a. (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))

val parse_bit_shift : forall 'a. (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))
val shift_term : forall 'a. (arith_exp 'a) -> (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))
val collect_shift : forall 'a. ((arith_exp 'a) -> (arith_exp 'a)) -> (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))

val parse_additive : forall 'a. (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))
val additive_term : forall 'a. (arith_exp 'a) -> (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))
val collect_additive : forall 'a. ((arith_exp 'a) -> (arith_exp 'a)) -> (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))

val parse_multiplicative : forall 'a. (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))
val multiplicative_term : forall 'a. (arith_exp 'a) -> (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))
val collect_multiplicative : forall 'a. ((arith_exp 'a) -> (arith_exp 'a)) -> (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))

let rec parse_assignment tkns = parse_conditional tkns

and parse_conditional tkns =
  match parse_bool_or tkns with
  | Right (term, rst) -> first_conditional_term term rst
  | Left e -> Left e
  end

and first_conditional_term boolean tkns =
  match tkns with
  | (TQuestion::rst1) ->
    match parse_conditional rst1 with
    | Right (lhs, rst2) ->
        match second_conditional_term rst2 with
        | Right (rhs, rst3) -> Right (Conditional boolean lhs rhs, rst3)
        | Left e -> Left e
        end
    | Left e -> Left e
    end
  | _ -> Right (boolean, tkns)
  end

and second_conditional_term tkns =
  match tkns with
  | (TColon::rst1) -> parse_conditional rst1
  | ts -> Left "Expected ':'"
  end

and parse_bool_or tkns =
  match parse_bool_and tkns with
  | Right (term, rst) -> bool_or_term term rst
  | Left e -> Left e
  end

and bool_or_term lhs tkns =
  match tkns with
  | (TBoolOr::rst1) ->
    match parse_bool_and rst1 with
    | Right (rhs, rst2) -> bool_or_term (BinOp BoolOr lhs rhs) rst2
    | Left e -> Left e
    end
  | _ -> Right (lhs, tkns)
  end

and parse_bool_and tkns =
  match parse_bit_or tkns with
  | Right (term, rst) -> bool_and_term term rst
  | Left e -> Left e
  end

and bool_and_term lhs tkns =
  match tkns with
  | (TBoolAnd::rst1) ->
    match parse_bit_or rst1 with
    | Right (rhs, rst2) -> bool_and_term (BinOp BoolAnd lhs rhs) rst2
    | Left e -> Left e
    end
  | _ -> Right (lhs, tkns)
  end

and parse_bit_or tkns =
  match parse_bit_xor tkns with
  | Right (term, rst) -> bit_or_term term rst
  | Left e -> Left e
  end

and bit_or_term lhs tkns =
  match tkns with
  | (TBitOr::rst1) ->
    match parse_bit_xor rst1 with
    | Right (rhs, rst2) -> bit_or_term (BinOp BitOr lhs rhs) rst2
    | Left e -> Left e
    end
  | _ -> Right (lhs, tkns)
  end

and parse_bit_xor tkns =
  match parse_bit_and tkns with
  | Right (term, rst) -> bit_xor_term term rst
  | Left e -> Left e
  end

and bit_xor_term lhs tkns =
  match tkns with
  | (TBitXOr::rst1) ->
    match parse_bit_and rst1 with
    | Right (rhs, rst2) -> bit_xor_term (BinOp BitXOr lhs rhs) rst2
    | Left e -> Left e
    end
  | _ -> Right (lhs, tkns)
  end

and parse_bit_and tkns =
  match parse_equality tkns with
  | Right (term, rst) -> bit_and_term term rst
  | Left e -> Left e
  end

and bit_and_term lhs tkns =
  match tkns with
  | (TBitAnd::rst1) ->
    match parse_equality rst1 with
    | Right (rhs, rst2) -> bit_and_term (BinOp BitAnd lhs rhs) rst2
    | Left e -> Left e
    end
  | _ -> Right (lhs, tkns)
  end

and collect_bit_and mk tkns =
  match parse_equality tkns with
  | Right (term, rst) -> bit_and_term (mk term) rst
  | Left e -> Left e
  end

and parse_equality tkns =
  match parse_relational tkns with
  | Right (term, rst) -> equality_term term rst
  | Left e -> Left e
  end

and equality_term lhs tkns =
  match tkns with
  | (TEq::rst) -> collect_equality (BinOp Eq lhs) rst
  | (TNEq::rst) -> collect_equality (BinOp NEq lhs) rst
  | _ -> Right (lhs, tkns)
  end

and collect_equality mk tkns =
  match parse_relational tkns with
  | Right (term, rst) -> equality_term (mk term) rst
  | Left e -> Left e
  end

and parse_relational tkns =
  match parse_bit_shift tkns with
  | Right (term, rst) -> relational_term term rst
  | Left e -> Left e
  end

and relational_term lhs tkns =
  match tkns with
  | (TLt::rst) -> collect_relational (BinOp Lt lhs) rst
  | (TLte::rst) -> collect_relational (BinOp Lte lhs) rst
  | (TGt::rst) -> collect_relational (BinOp Gt lhs) rst
  | (TGte::rst) -> collect_relational (BinOp Gte lhs) rst
  | _ -> Right (lhs, tkns)
  end

and collect_relational mk tkns =
  match parse_bit_shift tkns with
  | Right (term, rst) -> relational_term (mk term) rst
  | Left e -> Left e
  end

and parse_bit_shift tkns =
  match parse_additive tkns with
  | Right (term, rst) -> shift_term term rst
  | Left e -> Left e
  end

and shift_term lhs tkns =
  match tkns with
  | (TLShift::rst) -> collect_shift (BinOp LShift lhs) rst
  | (TRShift::rst) -> collect_shift (BinOp RShift lhs) rst
  | _ -> Right (lhs, tkns)
  end

and collect_shift mk tkns =
  match parse_additive tkns with
  | Right (term, rst) -> shift_term (mk term) rst
  | Left e -> Left e
  end

and parse_additive tkns =
  match parse_multiplicative tkns with
  | Right (term, rst) -> additive_term term rst
  | Left e -> Left e
  end

and additive_term lhs tkns =
  match tkns with
  | (TPlus::rst) -> collect_additive (BinOp Plus lhs) rst
  | (TMinus::rst) -> collect_additive (BinOp Minus lhs) rst
  | _ -> Right (lhs, tkns)
  end

and collect_additive mk tkns =
  match parse_multiplicative tkns with
  | Right (term, rst) -> additive_term (mk term) rst
  | Left e -> Left e
  end

and parse_multiplicative tkns =
  match unary_term tkns with
  | Right (term, rst) -> multiplicative_term term rst
  | Left e -> Left e
  end

and multiplicative_term lhs tkns =
  match tkns with
  | (TTimes::rst) -> collect_multiplicative (BinOp Times lhs) rst
  | (TDiv::rst) -> collect_multiplicative (BinOp Div lhs) rst
  | (TMod::rst) -> collect_multiplicative (BinOp Mod lhs) rst
  | _ -> Right (lhs, tkns)
  end

and collect_multiplicative mk tkns =
  match unary_term tkns with
  | Right (term, rst) -> multiplicative_term (mk term) rst
  | Left e -> Left e
  end

and unary_term tkns =
  match tkns with
  | (TPlus::ts) -> unary_term ts
  | (TMinus::ts) ->
      match unary_term ts with
      | Right (term, rst) -> Right (Neg(term), rst)
      | Left e -> Left e
      end
  | (TBitNot::ts) ->
      match unary_term ts with
      | Right (term, rst) -> Right (BitNot(term), rst)
      | Left e -> Left e
      end
  | (TBoolNot::ts) ->
      match unary_term ts with
      | Right (term, rst) -> Right (BoolNot(term), rst)
      | Left e -> Left e
      end
  | _ -> number_term tkns
  end

and number_term tkns =
  match tkns with
  | ((TNum n)::ts) -> Right (Num n, ts)
  | (TLParen::ts) ->
      match parse_assignment ts with
      | Right(term, TRParen::ts1) -> Right (term, ts1)
      | Right(term, _) -> Left "Expected right paren found "
      | Left e -> Left e
      end
  | ts -> Left "Expected number or (expr) found"
  end

val parse_arith_exp : forall 'a. list (arith_token 'a) -> either string (arith_exp 'a)
let parse_arith_exp tkns =
  match parse_assignment tkns with
  | Right (expr, []) -> Right expr
  | Right (_, ts) -> Left "Expected EOF but found tokens"
  | Left e -> Left e
  end

val eval_arith : forall 'a. NumAdd 'a, NumMinus 'a, NumMult 'a, NumIntegerDivision 'a, NumRemainder 'a  => arith_exp 'a -> either string 'a
let rec eval_arith e =
  match e with
  | (Num n) -> Right n
  | (BinOp op e1 e2) ->
      match (eval_arith e1, eval_arith e2) with
      | (Right n1, Right n2) ->
          match op with
          | Plus -> Right (n1 + n2)
          | Minus -> Right (n1 - n2)
          | Times -> Right (n1 * n2)
          | Div -> Right (n1 div n2)
          | Mod -> Right (n1 mod n2)
          | _ -> Left "unimplemented"
          end
      | (Left e, _) -> Left e
      | (_, Left e) -> Left e
      end
  | _ -> Left "unimplemented"
  end

val arith : forall 'a. Read 'a, NumAdd 'a, NumMinus 'a, NumMult 'a, NumIntegerDivision 'a, NumRemainder 'a => (list char) -> either string 'a
let arith str =
  match parse_arith_exp (lexer str) with
  | Right aexp -> eval_arith aexp
  | Left e -> Left e
  end

