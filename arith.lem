(*
 * Parse and evaluate a string representing the arithmetic operation
 *)
open import Pervasives_extra

type arith_token 'a =
    TNum of 'a
  | TVar of string
  | TPlus | TMinus
  | TTimes | TDiv | TMod
  | TBitNot | TBoolNot (* Is '!' actually allowed? *)
  | TLShift | TRShift
  | TLt | TLte
  | TGt | TGte
  | TEq | TNEq
  | TBitAnd | TBitOr | TBitXOr
  | TBoolAnd | TBoolOr
  | TQuestion | TColon (* For 1 ? 17 : 18 *)
  | TVarEq
  | TVarPlusEq | TVarMinusEq
  | TVarTimesEq | TVarDivEq | TVarModEq
  | TVarLShiftEq | TVarRShiftEq
  | TVarBitAndEq | TVarBitOrEq | TVarBitXOrEq
  | TLParen | TRParen

type BinaryOperator =
    Plus
  | Minus
  | Times
  | Div
  | Mod
  | LShift
  | RShift
  | Lt
  | Lte
  | Gt
  | Gte
  | Eq
  | NEq
  | BitAnd
  | BitOr
  | BitXOr
  | BoolAnd
  | BoolOr

type arith_exp 'a =
    Num of 'a
  | Neg of arith_exp 'a
  | BitNot of arith_exp 'a
  | BoolNot of arith_exp 'a
  | Conditional of arith_exp 'a * arith_exp 'a * arith_exp 'a
  | BinOp of BinaryOperator * arith_exp 'a * arith_exp 'a

let is_whitespace c = elem c (toCharList " \n\t")
let is_digit c = elem c (toCharList "1234567890")
let is_num_const_char c = elem c (toCharList "1234567890xabcdefABCDEF")
let is_alpha c = elem c (toCharList "abcdefghijklnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

(* Convert uppercase A-F to lowercase and then convert
 * lowercase hexdigit to integer 10 to 15. *)
val hexalpha_to_num : char -> nat
let hexalpha_to_num c =
  let num = ord c in
  let lowercase = if num >= 65 && num <= 70
    then num + 32
    else num in
  9 + (lowercase - 96)

class ( Read 'a )
  (* Read can fail with an error message by using Left.
   * Do not use any methods that may throw errors. *)
  val read : list char -> either string 'a
end

let readConstant dec hex oct acc chars =
  match chars with
  | #'0'::#'x'::cs -> hex acc cs
  | #'0'::cs -> oct acc cs
  | _ -> dec acc chars
  end

val readIntegerDec : integer -> (list char) -> either string integer
let rec readIntegerDec acc chars =
  match chars with
  | [] -> Right acc
  | (c::cs) ->
      let num = (ord c) - 48 in
      if num >= 0 && num < 10
      then readIntegerDec ((10 * acc) + (integerFromNat ((ord c) - 48))) cs
      else Left ((toString [c]) ^ " is not a valid decimal digit")
  end

let int64Max = ((int64FromNat 2) ** 63) - 1
let int64Min = ~((int64FromNat 2) ** 63)

let int32Max = ((int32FromNat 2) ** 31) - 1
let int32Min = ~((int32FromNat 2) ** 31)

val readInt64Dec : int64 -> (list char) -> either string int64
let rec readInt64Dec acc chars =
  match chars with
  | [] -> Right acc
  | (c::cs) ->
      let num = (ord c) - 48 in
      if num >= 0 && num < 10
      then let acc1 = ((10 * acc) + (int64FromNat ((ord c) - 48))) in
           if acc1 < 0
           then Right int64Max
           else readInt64Dec acc1 cs
      else Left ((toString [c]) ^ " is not a valid decimal digit")
  end

val readInt32Dec : int32 -> (list char) -> either string int32
let rec readInt32Dec acc chars =
  match chars with
  | [] -> Right acc
  | (c::cs) ->
      let num = (ord c) - 48 in
      if num >= 0 && num < 10
      then let acc1 = ((10 * acc) + (int32FromNat ((ord c) - 48))) in
           if acc1 < 0
           then Right int32Max
           else readInt32Dec acc1 cs
      else Left ((toString [c]) ^ " is not a valid decimal digit")
  end

val readIntegerHex : integer -> (list char) -> either string integer
let rec readIntegerHex acc chars =
  match chars with
  | [] -> Right acc
  | (c::cs) ->
      let num = if is_digit c
        then (ord c) - 48
        else hexalpha_to_num c in
      if num >= 0 && num < 16
      then readIntegerHex ((16 * acc) + (integerFromNat num)) cs
      else Left ((toString [c]) ^ " is not a valid hexadecimal digit")
  end

val readInt64Hex : int64 -> (list char) -> either string int64
let rec readInt64Hex acc chars =
  match chars with
  | [] -> Right acc
  | (c::cs) ->
      let num = if is_digit c
        then (ord c) - 48
        else hexalpha_to_num c in
      if num >= 0 && num < 16
      then let acc1 = (16 * acc) + (int64FromNat num) in
           if acc1 < 0
           then Right int64Max
           else readInt64Hex acc1 cs
      else Left ((toString [c]) ^ " is not a valid hexadecimal digit")
  end

val readInt32Hex : int32 -> (list char) -> either string int32
let rec readInt32Hex acc chars =
  match chars with
  | [] -> Right acc
  | (c::cs) ->
      let num = if is_digit c
        then (ord c) - 48
        else hexalpha_to_num c in
      if num >= 0 && num < 16
      then let acc1 = (16 * acc) + (int32FromNat num) in
           if acc1 < 0
           then Right int32Max
           else readInt32Hex acc1 cs
      else Left ((toString [c]) ^ " is not a valid hexadecimal digit")
  end

val readIntegerOct : integer -> (list char) -> either string integer
let rec readIntegerOct acc chars =
  match chars with
  | [] -> Right acc
  | (c::cs) ->
      let num = (ord c) - 48 in
      if num > 7 || num < 0
      then Left ((toString [c]) ^ " is not a valid octal digit")
      else readIntegerOct ((8 * acc) + (integerFromNat ((ord c) - 48)))cs
  end

val readInt64Oct : int64 -> (list char) -> either string int64
let rec readInt64Oct acc chars =
  match chars with
  | [] -> Right acc
  | (c::cs) ->
      let num = (ord c) - 48 in
      if num > 7 || num < 0
      then Left ((toString [c]) ^ " is not a valid octal digit")
      else let acc1 = (8 * acc) + (int64FromNat num) in
           if acc1 < 0
           then Right int64Max
           else readInt64Oct acc1 cs
  end

val readInt32Oct : int32 -> (list char) -> either string int32
let rec readInt32Oct acc chars =
  match chars with
  | [] -> Right acc
  | (c::cs) ->
      let num = (ord c) - 48 in
      if num > 7 || num < 0
      then Left ((toString [c]) ^ " is not a valid octal digit")
      else let acc1 = (8 * acc) + (int32FromNat num) in
           if acc1 < 0
           then Right int32Max
           else readInt32Oct acc1 cs
  end


instance ( Read integer )
  let read cs = readConstant readIntegerDec readIntegerHex readIntegerOct 0 cs
end

instance ( Read int64 )
  let read cs = readConstant readInt64Dec readInt64Hex readInt64Oct (int64FromNat 0) cs
end

instance ( Read int32 )
  let read cs = readConstant readInt32Dec readInt32Hex readInt32Oct (int32FromNat 0) cs
end

val lexer : forall 'a. Read 'a => (list char) -> either string (list (arith_token 'a))
val span : (char -> bool) -> (list char) -> ((list char) * list char)

val either_fmap : forall 'a 'b. ('a -> 'b) -> either string 'a -> either string 'b
let either_fmap fn a = Either.either (fun e -> Left e) (fun b -> Right (fn b)) a

val either_monad : forall 'a 'b. ('a -> either string 'b) -> either string 'a -> either string 'b
let either_monad fn a = Either.either (fun e -> Left e) fn a

let is_plus c =
  match c with
  | #'+' -> true
  | _ -> false
  end

let rec span f l =
  match l with
  | [] -> ([],[])
  | c::cs ->
      if f c
      then let (s, rst) = span f cs
           in (c::s, rst)
      else ([], c::cs)
  end

let rec lexer str =
  match str with
  | [] -> Right []
  | (#'^'::#'='::cs) -> either_fmap (fun lst -> TVarBitXOrEq::lst) (lexer cs)
  | (#'|'::#'='::cs) -> either_fmap (fun lst -> TVarBitOrEq::lst) (lexer cs)
  | (#'&'::#'='::cs) -> either_fmap (fun lst -> TVarBitAndEq::lst) (lexer cs)
  | (#'>'::#'>'::#'='::cs) -> either_fmap (fun lst -> TVarRShiftEq::lst) (lexer cs)
  | (#'<'::#'<'::#'='::cs) -> either_fmap (fun lst -> TVarLShiftEq::lst) (lexer cs)
  | (#'%'::#'='::cs) -> either_fmap (fun lst -> TVarModEq::lst) (lexer cs)
  | (#'/'::#'='::cs) -> either_fmap (fun lst -> TVarDivEq::lst) (lexer cs)
  | (#'*'::#'='::cs) -> either_fmap (fun lst -> TVarTimesEq::lst) (lexer cs)
  | (#'-'::#'='::cs) -> either_fmap (fun lst -> TVarMinusEq::lst) (lexer cs)
  | (#'+'::#'='::cs) -> either_fmap (fun lst -> TVarPlusEq::lst) (lexer cs)
  | (#'='::#'='::cs) -> either_fmap (fun lst -> TEq::lst) (lexer cs)
  | (#'!'::#'='::cs) -> either_fmap (fun lst -> TNEq::lst) (lexer cs)
  | (#'>'::#'>'::cs) -> either_fmap (fun lst -> TRShift::lst) (lexer cs)
  | (#'<'::#'<'::cs) -> either_fmap (fun lst -> TLShift::lst) (lexer cs)
  | (#'&'::#'&'::cs) -> either_fmap (fun lst -> TBoolAnd::lst) (lexer cs)
  | (#'|'::#'|'::cs) -> either_fmap (fun lst -> TBoolOr::lst) (lexer cs)
  | (#'='::cs) -> either_fmap (fun lst -> TVarEq::lst) (lexer cs)
  | (#':'::cs) -> either_fmap (fun lst -> TColon::lst) (lexer cs)
  | (#'?'::cs) -> either_fmap (fun lst -> TQuestion::lst) (lexer cs)
  | (#'^'::cs) -> either_fmap (fun lst -> TBitXOr::lst) (lexer cs)
  | (#'|'::cs) -> either_fmap (fun lst -> TBitOr::lst) (lexer cs)
  | (#'&'::cs) -> either_fmap (fun lst -> TBitAnd::lst) (lexer cs)
  | (#'>'::#'='::cs) -> either_fmap (fun lst -> TGte::lst) (lexer cs)
  | (#'<'::#'='::cs) -> either_fmap (fun lst -> TLte::lst) (lexer cs)
  | (#'>'::cs) -> either_fmap (fun lst -> TGt::lst) (lexer cs)
  | (#'<'::cs) -> either_fmap (fun lst -> TLt::lst) (lexer cs)
  | (#'!'::cs) -> either_fmap (fun lst -> TBoolNot::lst) (lexer cs)
  | (#'~'::cs) -> either_fmap (fun lst -> TBitNot::lst) (lexer cs)
  | (#'%'::cs) -> either_fmap (fun lst -> TMod::lst) (lexer cs)
  | (#'/'::cs) -> either_fmap (fun lst -> TDiv::lst) (lexer cs)
  | (#'*'::cs) -> either_fmap (fun lst -> TTimes::lst) (lexer cs)
  | (#'-'::cs) -> either_fmap (fun lst -> TMinus::lst) (lexer cs)
  | (#'+'::cs) -> either_fmap (fun lst -> TPlus::lst) (lexer cs)
  | (#'('::cs) -> either_fmap (fun lst -> TLParen::lst) (lexer cs)
  | (#')'::cs) -> either_fmap (fun lst -> TRParen::lst) (lexer cs)
  | (c::cs) ->
      match (is_digit c, is_alpha c) with
      | (true, _) -> let (digits, rst) = span is_num_const_char cs in
                     match read (c::digits) with
                     | Right n -> either_fmap (fun lst -> (TNum n)::lst) (lexer rst)
                     | Left e -> Left e
                     end
      | (_, true) -> let (var, rst) = span is_alpha cs
                     in either_fmap (fun lst -> (TVar (toString (c::var)))::lst) (lexer rst)
      | (false, false) ->
          if is_whitespace c
          then lexer cs
          else Left ((toString [c]) ^ " is an unrecognized character")
      end
  end

val parse_assignment : forall 'a. (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))

val parse_bit_shift : forall 'a. (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))
val shift_term : forall 'a. (arith_exp 'a) -> (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))
val collect_shift : forall 'a. ((arith_exp 'a) -> (arith_exp 'a)) -> (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))

val parse_additive : forall 'a. (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))
val additive_term : forall 'a. (arith_exp 'a) -> (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))
val collect_additive : forall 'a. ((arith_exp 'a) -> (arith_exp 'a)) -> (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))

val parse_multiplicative : forall 'a. (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))
val multiplicative_term : forall 'a. (arith_exp 'a) -> (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))
val collect_multiplicative : forall 'a. ((arith_exp 'a) -> (arith_exp 'a)) -> (list (arith_token 'a)) -> either string ((arith_exp 'a) * list (arith_token 'a))

let rec parse_assignment tkns = parse_conditional tkns

and parse_conditional tkns =
  match parse_bool_or tkns with
  | Right (term, rst) -> first_conditional_term term rst
  | Left e -> Left e
  end

and first_conditional_term boolean tkns =
  match tkns with
  | (TQuestion::rst1) ->
    match parse_conditional rst1 with
    | Right (lhs, rst2) ->
        match second_conditional_term rst2 with
        | Right (rhs, rst3) -> Right (Conditional boolean lhs rhs, rst3)
        | Left e -> Left e
        end
    | Left e -> Left e
    end
  | _ -> Right (boolean, tkns)
  end

and second_conditional_term tkns =
  match tkns with
  | (TColon::rst1) -> parse_conditional rst1
  | ts -> Left "Expected ':'"
  end

and parse_bool_or tkns =
  match parse_bool_and tkns with
  | Right (term, rst) -> bool_or_term term rst
  | Left e -> Left e
  end

and bool_or_term lhs tkns =
  match tkns with
  | (TBoolOr::rst1) ->
    match parse_bool_and rst1 with
    | Right (rhs, rst2) -> bool_or_term (BinOp BoolOr lhs rhs) rst2
    | Left e -> Left e
    end
  | _ -> Right (lhs, tkns)
  end

and parse_bool_and tkns =
  match parse_bit_or tkns with
  | Right (term, rst) -> bool_and_term term rst
  | Left e -> Left e
  end

and bool_and_term lhs tkns =
  match tkns with
  | (TBoolAnd::rst1) ->
    match parse_bit_or rst1 with
    | Right (rhs, rst2) -> bool_and_term (BinOp BoolAnd lhs rhs) rst2
    | Left e -> Left e
    end
  | _ -> Right (lhs, tkns)
  end

and parse_bit_or tkns =
  match parse_bit_xor tkns with
  | Right (term, rst) -> bit_or_term term rst
  | Left e -> Left e
  end

and bit_or_term lhs tkns =
  match tkns with
  | (TBitOr::rst1) ->
    match parse_bit_xor rst1 with
    | Right (rhs, rst2) -> bit_or_term (BinOp BitOr lhs rhs) rst2
    | Left e -> Left e
    end
  | _ -> Right (lhs, tkns)
  end

and parse_bit_xor tkns =
  match parse_bit_and tkns with
  | Right (term, rst) -> bit_xor_term term rst
  | Left e -> Left e
  end

and bit_xor_term lhs tkns =
  match tkns with
  | (TBitXOr::rst1) ->
    match parse_bit_and rst1 with
    | Right (rhs, rst2) -> bit_xor_term (BinOp BitXOr lhs rhs) rst2
    | Left e -> Left e
    end
  | _ -> Right (lhs, tkns)
  end

and parse_bit_and tkns =
  match parse_equality tkns with
  | Right (term, rst) -> bit_and_term term rst
  | Left e -> Left e
  end

and bit_and_term lhs tkns =
  match tkns with
  | (TBitAnd::rst1) ->
    match parse_equality rst1 with
    | Right (rhs, rst2) -> bit_and_term (BinOp BitAnd lhs rhs) rst2
    | Left e -> Left e
    end
  | _ -> Right (lhs, tkns)
  end

and collect_bit_and mk tkns =
  match parse_equality tkns with
  | Right (term, rst) -> bit_and_term (mk term) rst
  | Left e -> Left e
  end

and parse_equality tkns =
  match parse_relational tkns with
  | Right (term, rst) -> equality_term term rst
  | Left e -> Left e
  end

and equality_term lhs tkns =
  match tkns with
  | (TEq::rst) -> collect_equality (BinOp Eq lhs) rst
  | (TNEq::rst) -> collect_equality (BinOp NEq lhs) rst
  | _ -> Right (lhs, tkns)
  end

and collect_equality mk tkns =
  match parse_relational tkns with
  | Right (term, rst) -> equality_term (mk term) rst
  | Left e -> Left e
  end

and parse_relational tkns =
  match parse_bit_shift tkns with
  | Right (term, rst) -> relational_term term rst
  | Left e -> Left e
  end

and relational_term lhs tkns =
  match tkns with
  | (TLt::rst) -> collect_relational (BinOp Lt lhs) rst
  | (TLte::rst) -> collect_relational (BinOp Lte lhs) rst
  | (TGt::rst) -> collect_relational (BinOp Gt lhs) rst
  | (TGte::rst) -> collect_relational (BinOp Gte lhs) rst
  | _ -> Right (lhs, tkns)
  end

and collect_relational mk tkns =
  match parse_bit_shift tkns with
  | Right (term, rst) -> relational_term (mk term) rst
  | Left e -> Left e
  end

and parse_bit_shift tkns =
  match parse_additive tkns with
  | Right (term, rst) -> shift_term term rst
  | Left e -> Left e
  end

and shift_term lhs tkns =
  match tkns with
  | (TLShift::rst) -> collect_shift (BinOp LShift lhs) rst
  | (TRShift::rst) -> collect_shift (BinOp RShift lhs) rst
  | _ -> Right (lhs, tkns)
  end

and collect_shift mk tkns =
  match parse_additive tkns with
  | Right (term, rst) -> shift_term (mk term) rst
  | Left e -> Left e
  end

and parse_additive tkns =
  match parse_multiplicative tkns with
  | Right (term, rst) -> additive_term term rst
  | Left e -> Left e
  end

and additive_term lhs tkns =
  match tkns with
  | (TPlus::rst) -> collect_additive (BinOp Plus lhs) rst
  | (TMinus::rst) -> collect_additive (BinOp Minus lhs) rst
  | _ -> Right (lhs, tkns)
  end

and collect_additive mk tkns =
  match parse_multiplicative tkns with
  | Right (term, rst) -> additive_term (mk term) rst
  | Left e -> Left e
  end

and parse_multiplicative tkns =
  match unary_term tkns with
  | Right (term, rst) -> multiplicative_term term rst
  | Left e -> Left e
  end

and multiplicative_term lhs tkns =
  match tkns with
  | (TTimes::rst) -> collect_multiplicative (BinOp Times lhs) rst
  | (TDiv::rst) -> collect_multiplicative (BinOp Div lhs) rst
  | (TMod::rst) -> collect_multiplicative (BinOp Mod lhs) rst
  | _ -> Right (lhs, tkns)
  end

and collect_multiplicative mk tkns =
  match unary_term tkns with
  | Right (term, rst) -> multiplicative_term (mk term) rst
  | Left e -> Left e
  end

and unary_term tkns =
  match tkns with
  | (TPlus::ts) -> unary_term ts
  | (TMinus::ts) ->
      match unary_term ts with
      | Right (term, rst) -> Right (Neg(term), rst)
      | Left e -> Left e
      end
  | (TBitNot::ts) ->
      match unary_term ts with
      | Right (term, rst) -> Right (BitNot(term), rst)
      | Left e -> Left e
      end
  | (TBoolNot::ts) ->
      match unary_term ts with
      | Right (term, rst) -> Right (BoolNot(term), rst)
      | Left e -> Left e
      end
  | _ -> number_term tkns
  end

and number_term tkns =
  match tkns with
  | ((TNum n)::ts) -> Right (Num n, ts)
  | (TLParen::ts) ->
      match parse_assignment ts with
      | Right(term, TRParen::ts1) -> Right (term, ts1)
      | Right(term, _) -> Left "Expected right paren found "
      | Left e -> Left e
      end
  | ts -> Left "Expected number or (expr) found"
  end

val parse_arith_exp : forall 'a. list (arith_token 'a) -> either string (arith_exp 'a)
let parse_arith_exp tkns =
  match parse_assignment tkns with
  | Right (expr, []) -> Right expr
  | Right (_, ts) -> Left "Expected EOF but found tokens"
  | Left e -> Left e
  end

val eval_arith : forall 'a. NumAdd 'a, NumMinus 'a, NumMult 'a, NumIntegerDivision 'a, NumRemainder 'a  => arith_exp 'a -> either string 'a
let rec eval_arith e =
  match e with
  | (Num n) -> Right n
  | (BinOp op e1 e2) ->
      match (eval_arith e1, eval_arith e2) with
      | (Right n1, Right n2) ->
          match op with
          | Plus -> Right (n1 + n2)
          | Minus -> Right (n1 - n2)
          | Times -> Right (n1 * n2)
          | Div -> if num == 0
                   then Left "Divide by zero error"
                   else Right (n1 div n2)
          | Mod -> Right (n1 mod n2)
          | _ -> Left "unimplemented"
          end
      | (Left e, _) -> Left e
      | (_, Left e) -> Left e
      end
  | _ -> Left "unimplemented"
  end

val arith : forall 'a. Read 'a, NumAdd 'a, NumMinus 'a, NumMult 'a, NumIntegerDivision 'a, NumRemainder 'a => (list char) -> either string 'a
let arith str =
  match (either_monad parse_arith_exp (lexer str)) with
  | Right aexp -> eval_arith aexp
  | Left e -> Left e
  end

val arith_big_num : (list char) -> either string integer
let arith_big_num = arith

val arith32 : (list char) -> either string int32
let arith32 = arith

val arith64 : (list char) -> either string int64
let arith64 = arith

