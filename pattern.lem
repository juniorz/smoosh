open import Pervasives_extra
open import Fsh_prelude
open import Arith

type substring_mode =
  Shortest
| Longest

type substring_side =
  Prefix
| Suffix  

type bracket_char =
  Char of char
| Collating of string
| Equiv of string
| Class of string

type bracket_entry =
  BC of bracket_char
| Range of bracket_char * bracket_char

type bracket = 
  Matching of list bracket_entry
| Nonmatching of list bracket_entry

(* http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_05 *)
(* parsing brackets *)
let rec parse_bracket_char (pat:list char) : maybe (bracket_char * list char) =
  match pat with
  | [] -> Nothing
  | #'['::#'.'::_pat' -> Nothing (* TODO collating char, scan for .] *)
  | #'['::#'='::_pat' -> Nothing (* TODO equivalence class, scan for =] *)
  | #'['::#':'::_pat' -> Nothing (* TODO character class, scan for :] *)
  | c::pat' -> Just (Char c,pat')
  end
                      
let rec parse_bracket_entries (pat:list char) : maybe (list bracket_entry * list char) = 
  match pat with
  | [] -> Nothing
  | #']'::pat' -> Just ([],pat')
  | _ -> match parse_bracket_char pat with
         | Nothing -> Nothing
         | Just (bc,#'-'::pat') -> 
            match parse_bracket_char pat' with
            | Nothing -> 
               match parse_bracket_entries (#'-'::pat') with
               | Nothing -> Nothing
               | Just (es,pat'') -> Just (BC bc::es,pat'')
               end
            | Just (bc',pat'') -> 
               match parse_bracket_entries pat'' with
               | Nothing -> Nothing
               | Just (es,pat''') -> Just (Range bc bc'::es,pat''')
               end
            end
         | Just (bc,pat') ->
            match parse_bracket_entries pat' with
            | Nothing -> Nothing
            | Just (es,pat'') -> Just (BC bc::es,pat'')
            end
         end
  end

let rec parse_bracket (neg:char) (pat:list char) : maybe (bracket * list char) = 
  match pat with
  | [] -> Nothing
  | c::pat' ->
     if c = neg
     then match parse_bracket_entries pat' with
          | Nothing -> Nothing
          | Just (es,pat'') -> Just (Nonmatching es, pat'')
          end
     else match parse_bracket_entries (c::pat') with
          | Nothing -> Nothing
          | Just (es, pat'') -> Just (Matching es, pat'')
          end
  end

let match_entry (c : char) (be : bracket_entry) : bool = 
  match be with
  | BC (Char c')      -> c' = c
  | BC (Collating _s) -> false (* TODO *)
  | BC (Equiv _s)     -> false (* TODO *)
  | BC (Class _s)     -> false (* TODO *)
  | Range _lo _hi     -> false (* TODO *)
  end

(* returns nothing if no match, rest of string if so *)
(* is this quite right, to account for collations? *)
let match_bracket (b : bracket) (c : list char) : maybe (list char) = 
  match (b, c) with
  | (_, [])                  -> Nothing
  | (Matching cs,    c :: s) -> if any (match_entry c) cs then Just s else Nothing
  | (Nonmatching cs, c :: s) -> if any (match_entry c) cs then Nothing else Just s
  end

let rec match_prefix (m:substring_mode) (pat:list char) (s:list char) : maybe (list char) =
  match (pat,s) with

  (* empty pattern *)
  | ([]       ,       s) -> Just s

  (* question-mark expressions *)
  | (#'?'::_   ,     []) -> Nothing
  | (#'?'::pat', _ ::s') -> match_prefix m pat' s'

  (* star expressions *)
  | (#'*'::pat',     []) -> match_prefix m pat' []
  | (#'*'::pat', c ::s') ->
     match m with
     | Longest -> 
        match match_prefix m (#'*'::pat') s' with  (* try skipping a character first *)
        | Nothing -> match_prefix m pat' (c::s')   (*   ...no dice; try to stop here *)
        | Just s' -> Just s'                       (*   ...success; we have our answer *)
        end
     | Shortest ->
        match (match_prefix m pat' (c::s')) with    (* try matching empty first *)
        | Nothing -> match_prefix m (#'*'::pat') s' (*   ...no dice; skip a character and go on *)
        | Just s' -> Just s'                        (*   ...success; we have our answer *)
        end
    end

  (* bracket expressions *)
  | (#'['::_   ,     []) -> Nothing (* is this an optimization? *)
  | (#'['::pat',c::s') ->
     match parse_bracket #'!' pat' with
     | Nothing -> 
        (* we couldn't parse a bracket expression, so treat it as literals *)
        if c = #'[' 
        then match_prefix m pat' s'
        else Nothing
     | Just (b,pat'') -> 
        (* got a bracket expression (and some leftover pattern), match the whole string against it *)
        match match_bracket b (c::s') with
        | Nothing -> Nothing                    (* couldn't match the bracket, we're done *)
        | Just s'' -> match_prefix m pat'' s''  (* got it, keep going with what's left *)
        end
     end
  (* plain characters *)                                  
  | (   _::_,        []) -> Nothing
  | (  c1::pat', c2::s') ->
     if c1 = c2
     then match_prefix m pat' s'
     else Nothing
  end

let try_match_prefix (m:substring_mode) (pat:list char) (s:list char) : list char =
  match match_prefix m pat s with
  | Nothing -> s
  | Just s' -> s'
  end
