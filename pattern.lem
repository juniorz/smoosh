open import Pervasives_extra
open import Fsh_prelude
open import Arith

type substring_mode =
  Shortest
| Longest

type substring_side =
  Prefix
| Suffix  

type bracket_char =
  Char of char
| Collating of string
| Equiv of string

type bracket_entry =
  BC of bracket_char
| Range of bracket_char * bracket_char


type bracket = 
  Matching of list bracket_entry
| Nonmatching of list bracket_entry

(* http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_05 *)
(* parsing brackets *)
let rec parse_bracket (_neg:char) (_pat:list char) : bracket = Matching []

let match_entry (c : char) (be : bracket_entry) : bool = 
  match be with
  | BC (Char c')      -> c' = c
  | BC (Collating _s) -> false (* TODO *)
  | BC (Equiv _s)     -> false (* TODO *)
  | Range _lo _hi     -> false (* TODO *)
  end

(* returns nothing if no match, rest of string if so *)
(* is this quite right, to account for collations? *)
let match_bracket (b : bracket) (c : list char) : maybe (list char) = 
  match (b, c) with
  | (_, [])                  -> Nothing
  | (Matching cs,    c :: s) -> if any (match_entry c) cs then Just s else Nothing
  | (Nonmatching cs, c :: s) -> if any (match_entry c) cs then Nothing else Just s
  end

let rec match_prefix (m:substring_mode) (pat:list char) (s:list char) : maybe (list char) =
  match (pat,s) with

  (* empty pattern *)
  | ([]       ,       s) -> Just s

  (* question-mark expressions *)
  | (#'?'::_   ,     []) -> Nothing
  | (#'?'::pat', _ ::s') -> match_prefix m pat' s'

  (* star expressions *)
  | (#'*'::pat',     []) -> match_prefix m pat' []
  | (#'*'::pat', c ::s') ->
     match m with
     | Longest -> 
        match match_prefix m (#'*'::pat') s' with  (* try skipping a character first *)
        | Nothing -> match_prefix m pat' (c::s')   (*   ...no dice; try to stop here *)
        | Just s' -> Just s'                       (*   ...success; we have our answer *)
        end
     | Shortest ->
        match (match_prefix m pat' (c::s')) with    (* try matching empty first *)
        | Nothing -> match_prefix m (#'*'::pat') s' (*   ...no dice; skip a character and go on *)
        | Just s' -> Just s'                        (*   ...success; we have our answer *)
        end
    end

  (* bracket expressions *)
  | (#'['::_   ,     []) -> Nothing (* is this an optimization? *)
  | (#'['::_pat',_c::_s') -> Just (toCharList "TODO: implement bracket expressions in match_prefix")

  (* plain characters *)                                  
  | (   _::_,        []) -> Nothing
  | (  c1::pat', c2::s') ->
     if c1 = c2
     then match_prefix m pat' s'
     else Nothing
  end

let try_match_prefix (m:substring_mode) (pat:list char) (s:list char) : list char =
  match match_prefix m pat s with
  | Nothing -> s
  | Just s' -> s'
  end
