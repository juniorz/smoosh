include import Fsh_prelude
include import Os

(**********************************************************************)
(* PRETTY PRINTING ****************************************************)
(**********************************************************************)

val string_of_stmt : stmt -> string
val string_of_words : words -> string
val string_of_entry : entry -> string

let join s1 s2 =
  let sep = if s1 <> "" && s2 <> "" then " " else "" in
  s1 ^ sep ^ s2

let braces s = "{ " ^ s ^ " ; }"

(* we translate 
           cmds... &
   to
           { cmds & }
   this avoids issues with parsing; in particular,
     cmd1 & ; cmd2 & ; cmd3
   doesn't parse; it must be:
     cmd1 & cmd2 & cmd3
   it's a little too annoying to track "was the last thing
   backgrounded?" so the braces resolve the issue. testing
   indicates that they're semantically equivalent.
*)
let background s = "{ " ^ s ^ " & }"

let show_unless expected actual =
  if expected = actual
  then ""
  else stringFromNat actual

(* TODO 2018-02-02 finish string rendering for technical runtime terms *)
let rec string_of_stmt c = 
  match c with
  | Command assigns cmds redirs ->
     let s_assigns = 
       concat " " (List.map (fun (v,a) -> v ^ "=" ^ string_of_words a) assigns) 
     in
     let s_cmds = string_of_words cmds in
     let s_redirs = string_of_redirs redirs in
     join s_assigns (join s_cmds s_redirs)
  | CommandExpAssign assigns cmds redirs -> 
     let s_assigns = 
       concat " " (List.map (fun (v,a) -> v ^ "=" ^ string_of_expansion_state a) assigns) 
     in
     let s_cmds = string_of_words cmds in
     let s_redirs = string_of_redirs redirs in
     join s_assigns (join s_cmds s_redirs)
  | CommandExpArgs assigns cmds redirs -> 
     let s_assigns = 
       concat " " (List.map (fun (v,a) -> v ^ "=" ^ string_of_fields a) assigns) 
     in
     let s_cmds = string_of_expansion_state cmds in
     let s_redirs = string_of_redirs redirs in
     join s_assigns (join s_cmds s_redirs)
  | CommandExpRedirs assigns cmds redir_state ->
     let s_assigns = 
       concat " " (List.map (fun (v,a) -> v ^ "=" ^ string_of_fields a) assigns) 
     in
     let s_cmds = string_of_fields cmds in
     let s_redirs = string_of_redir_state redir_state in
     join s_assigns (join s_cmds s_redirs)
  | Pipe bg cmds ->
     let p = concat " | " (List.map string_of_stmt cmds) in
     if bg then background p else p
  | Redir cmd redir_state -> 
     join (string_of_stmt cmd) (string_of_redir_state redir_state)
  | Background cmd redir_state -> 
     background (join (string_of_stmt cmd) (string_of_redir_state redir_state))
  | Subshell cmd redir_state ->
     parens (join (string_of_stmt cmd) (string_of_redir_state redir_state))
  | And cmd1 cmd2 ->
     string_of_stmt cmd1 ^ " && " ^ string_of_stmt cmd2
  | Or cmd1 cmd2 ->
     string_of_stmt cmd1 ^ " || " ^ string_of_stmt cmd2
  | Semi cmd1 cmd2 ->
     string_of_stmt cmd1 ^ " ; " ^ string_of_stmt cmd2
  | Not cmd ->
     "! " ^ string_of_stmt cmd
  | If c1 c2 c3 ->
     string_of_if c1 c2 c3
  | While (Not c1) c2 ->
     "until " ^ string_of_stmt c1 ^ "; do " ^ string_of_stmt c2 ^ "; done "
  | While c1 c2 ->
     "while " ^ string_of_stmt c1 ^ "; do " ^ string_of_stmt c2 ^ "; done "
  | WhileCond _c _cur _body -> "TODO WhileCond"
  | WhileRunning _c _body _cur -> "TODO WhileRunning"
  | For x w c ->
     "for " ^ x ^ " in " ^ string_of_words w ^ "; do " ^ string_of_stmt c ^ "; done"
  | ForExpArgs _ _ _ -> "TODO ForExpArgs"
  | ForExpanded _ _ _ -> "TODO ForExpanded"
  | ForRunning _ _ _ _ -> "TODO ForRunning"
  | Case w cs ->
     "case " ^ string_of_words w ^ " in " ^ concat " " (List.map string_of_case cs) ^ " esac"
  | CaseExpArg _exp _cs -> "TODO CaseExpArg"
  | CaseMatch _s _cs -> "TODO CaseMatch"
  | CaseCheckMatch _s _exp _c _cs -> "TODO CaseCheckMatch"
  | Defun name cmd -> name ^ "() {\n" ^ string_of_stmt cmd ^ "\n}"
  | Call _loopnest _argv _f _body _c -> "TODO Call"
  | Break n -> "break " ^ show n
  | Continue n -> "continue " ^ show n
  | Return -> "return"
  | Exit -> "exit"
  | Wait n -> "wait " ^ stringFromNat n
  | Pushredir s _saved -> string_of_stmt s (* TODO fixme *)
  | Done -> "Done"
  end

and string_of_command f_a f_c f_r assigns cmds redirs =
  join (concat " " (List.map (fun (v,a) -> v ^ "=" ^ f_a a) assigns))
    (join (f_c cmds) (f_r redirs))

and string_of_inprogress_assign (v,f,a) = v ^ "=" ^ string_of_fields f ^ string_of_words a

and string_of_if c t e =
  "if " ^ string_of_stmt c ^
  "; then " ^ string_of_stmt t ^
  (match e with
   | Command [] [] [] -> "; fi" (* one-armed if *)
   | If c t e -> "; el" ^ string_of_if c t e
   | _ -> "; else " ^ string_of_stmt e ^ "; fi"
   end)

and string_of_case (w,c) =
  intercalate "|" (List.map string_of_words w) ^ ") " ^ string_of_stmt c ^ ";;"

and string_of_rfile ty fd =
  match ty with
  | To      -> show_unless 1 fd ^ ">"
  | Clobber -> show_unless 1 fd ^ ">|"
  | From    -> show_unless 0 fd ^ "<"
  | FromTo  -> show_unless 0 fd ^ "<>"
  | Append  -> show_unless 1 fd ^ ">>"
  end

and string_of_rdup ty fd =
  match ty with
  | ToFD -> show_unless 1 fd ^ ">&"
  | FromFD -> show_unless 0 fd ^ "<&"
  end

and string_of_heredoc ty fd heredoc =
  (* TODO 2018-09-04 use sound marker *)
  let marker = "EOF" in
  show_unless 0 fd ^ "<<" ^
  (if ty = XHere then marker else "'" ^ marker ^ "'") ^ "\n" ^ heredoc ^ marker ^ "\n"

and string_of_redir r = 
  match r with
  | RFile ty fd a   ->  string_of_rfile ty fd ^ string_of_words a
  | RDup ty fd tgt  ->  string_of_rdup ty fd ^ stringFromNat tgt
  | RHeredoc ty fd a -> string_of_heredoc ty fd (string_of_words a)
  end 

and string_of_expanding_redir exp_redir =
  match exp_redir with
  | Nothing -> ""
  | Just (XRFile ty fd exp_state) -> 
     string_of_rfile ty fd ^ string_of_expansion_state exp_state
  | Just (XRHeredoc ty fd exp_state) ->
     string_of_heredoc ty fd (string_of_expansion_state exp_state)
  end

and string_of_expanded_redir er =
  match er with
  | ERFile ty fd a   ->  string_of_rfile ty fd ^ string_of_fields a
  | ERDup ty _close_orig fd tgt  ->  string_of_rdup ty fd ^ stringFromNat tgt
  | ERHeredoc ty fd a -> string_of_heredoc ty fd (string_of_fields a)
  end 

and string_of_expanded_redirs ers =
  concat " " (List.map string_of_expanded_redir ers)
and string_of_redirs rs = 
  concat " " (List.map string_of_redir rs)

and string_of_redir_state (ers, exp_redir, rs) =
  let s_ers = string_of_expanded_redirs ers in
  let s_exp_redir = string_of_expanding_redir exp_redir in
  let s_rs = string_of_redirs rs in
  join s_ers (join s_exp_redir s_rs)

and string_of_words w = List.foldr (^) "" (List.map string_of_entry w)
and string_of_inprogress_words (f,w) = string_of_fields f ^ string_of_words w
and string_of_entry e =
  match e with
  | S str -> str
  | ESym _ -> "<<SYMBOLIC>>" (* TODO "R(" ^ string_of_symbolic_string c ^ ")" *)
  | K _ -> "<<CTRL>>" (* TODO 2018-08-24 need to implement correctly to support Here heredocs *)

  | F -> " "
  end

and string_of_expansion_state _exp_state =
  (* TODO 2018-09-04 TODO implement *)
  "string_of_expansion_state"
