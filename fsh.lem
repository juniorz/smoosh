include import Fsh_prelude
include import Os

(**********************************************************************)
(* Pretty printing ****************************************************)
(**********************************************************************)

val string_of_stmt : stmt -> string
val string_of_words : words -> string
val string_of_entry : entry -> string

let parens s = "( " ^ s ^ " )"
  
let braces s = "{ " ^ s ^ " ; }"

(* we translate 
           cmds... &
   to
           { cmds & }
   this avoids issues with parsing; in particular,
     cmd1 & ; cmd2 & ; cmd3
   doesn't parse; it must be:
     cmd1 & cmd2 & cmd3
   it's a little too annoying to track "was the last thing
   backgrounded?" so the braces resolve the issue. testing
   indicates that they're semantically equivalent.
*)
let background s = "{ " ^ s ^ " & }"

let show_unless expected actual =
  if expected = actual
  then ""
  else stringFromNat actual

(* TODO 2018-02-02 finish string rendering for technical runtime terms *)
let rec string_of_stmt c = 
  match c with
  | Command assigns cmds redirs ->
     concat " " (List.map string_of_assign assigns) ^
     (if List.length assigns = 0 || List.length cmds = 0 then "" else " ") ^
     string_of_words cmds ^
     string_of_redirs redirs
  | CommandExpAssign _assigns _cmds _redirs -> "TODO CommandExpAssign"
  | CommandExpArgs _assigns _cmds _redirs -> "TODO CommandExpArgs"
  | CommandExpanded _assigns _cmds _redirs -> "TODO CommandExpanded"  
  | Pipe bg cmds ->
     let p = concat " | " (List.map string_of_stmt cmds) in
     if bg then background p else p
  | Redir cmd redirs ->
     string_of_stmt cmd ^ string_of_redirs redirs
  | Background cmd redirs -> 
     background (string_of_stmt cmd ^ string_of_redirs redirs)
  | Subshell cmd redirs ->
     parens (string_of_stmt cmd ^ string_of_redirs redirs)
  | And cmd1 cmd2 ->
     string_of_stmt cmd1 ^ " && " ^ string_of_stmt cmd2
  | Or cmd1 cmd2 ->
     string_of_stmt cmd1 ^ " || " ^ string_of_stmt cmd2
  | Semi cmd1 cmd2 ->
     string_of_stmt cmd1 ^ " ; " ^ string_of_stmt cmd2
  | Not cmd ->
     "! " ^ string_of_stmt cmd
  | If c1 c2 c3 ->
     string_of_if c1 c2 c3
  | While (Not c1) c2 ->
     "until " ^ string_of_stmt c1 ^ "; do " ^ string_of_stmt c2 ^ "; done "
  | While c1 c2 ->
     "while " ^ string_of_stmt c1 ^ "; do " ^ string_of_stmt c2 ^ "; done "
  | WhileCond _c _cur _body -> "TODO WhileCond"
  | WhileRunning _c _body _cur -> "TODO WhileRunning"
  | For x w c ->
     "for " ^ x ^ " in " ^ string_of_words w ^ "; do " ^ string_of_stmt c ^ "; done"
  | ForExpArgs _ _ _ -> "TODO ForExpArgs"
  | ForExpanded _ _ _ -> "TODO ForExpanded"
  | ForRunning _ _ _ _ -> "TODO ForRunning"
  | Case w cs ->
     "case " ^ string_of_words w ^ " in " ^ concat " " (List.map string_of_case cs) ^ " esac"
  | CaseExpArg _exp _cs -> "TODO CaseExpArg"
  | CaseMatch _s _cs -> "TODO CaseMatch"
  | CaseCheckMatch _s _exp _c _cs -> "TODO CaseCheckMatch"
  | Defun name cmd -> name ^ "() {\n" ^ string_of_stmt cmd ^ "\n}"
  | Call _loopnest _argv _f _body _c -> "TODO Call"
  | Break n -> "break " ^ show n
  | Continue n -> "continue " ^ show n
  | Return -> "return"
  | Exit -> "exit"
  | Wait n -> "wait " ^ stringFromNat n
  | Done -> "Done"
  end

and string_of_assign (v,a) = v ^ "=" ^ string_of_words a

and string_of_inprogress_assign (v,f,a) = v ^ "=" ^ fields_to_string f ^ string_of_words a

and string_of_if c t e =
  "if " ^ string_of_stmt c ^
  "; then " ^ string_of_stmt t ^
  (match e with
   | Command [] [] [] -> "; fi" (* one-armed if *)
   | If c t e -> "; el" ^ string_of_if c t e
   | _ -> "; else " ^ string_of_stmt e ^ "; fi"
   end)

and string_of_case (w,c) =
  string_of_words w ^ ") " ^ string_of_stmt c ^ ";;"

and string_of_redir r = 
  match r with
  | RFile To fd a      -> show_unless 1 fd ^ ">" ^ string_of_words a
  | RFile Clobber fd a -> show_unless 1 fd ^ ">|" ^ string_of_words a
  | RFile From fd a    -> show_unless 0 fd ^ "<" ^ string_of_words a
  | RFile FromTo fd a  -> show_unless 0 fd ^ "<>" ^ string_of_words a
  | RFile Append fd a  -> show_unless 1 fd ^ ">>" ^ string_of_words a
  | RDup ToFD fd tgt   -> show_unless 1 fd ^ ">&" ^ stringFromNat tgt
  | RDup FromFD fd tgt -> show_unless 0 fd ^ "<&" ^ stringFromNat tgt
  | RHeredoc t fd a ->
     let heredoc = string_of_words a in
     let marker = "EOF" in
     show_unless 0 fd ^ "<<" ^
     (if t = XHere then marker else "'" ^ marker ^ "'") ^ "\n" ^ heredoc ^ marker ^ "\n"
  end 

and string_of_redirs rs =
  let ss = List.map string_of_redir rs in
  (if List.length ss > 0 then " " else "") ^ concat " " ss

and string_of_words w = List.foldr (^) "" (List.map string_of_entry w)
and string_of_inprogress_words (f,w) = fields_to_string f ^ string_of_words w
and string_of_entry e =
  match e with
  | S str -> "S(" ^ str ^ ")"
  | ESym _ -> "<<SYMBOLIC>>" (* TODO "R(" ^ string_of_symbolic_string c ^ ")" *)
  | K _ -> "<<CTRL>>"
  | F -> "<<FS>>"
  end
