open import Fsh_prelude

(* signal numbers for the local platform are generated by mk_signal_platform.sh *)

(* dropping XSI/XSR signals *)
type signal = 
  | SIGABRT
  | SIGALRM
  | SIGBUS
  | SIGCHLD
  | SIGCONT
  | SIGFPE
  | SIGHUP
  | SIGILL
  | SIGINT
  | SIGKILL
  | SIGPIPE
  | SIGQUIT
  | SIGSEGV
  | SIGSTOP
  | SIGTERM
  | SIGTSTP
  | SIGTTIN
  | SIGTTOU
  | SIGUSR1
  | SIGUSR2
  | SIGTRAP
  | SIGURG
  | SIGXCPU
  | SIGXFSZ

val signal_name : signal -> string
let signal_name signal =
  match signal with
  | SIGABRT   -> "ABRT"
  | SIGALRM   -> "ALRM"
  | SIGBUS    -> "BUS"
  | SIGCHLD   -> "CHLD"
  | SIGCONT   -> "CONT"
  | SIGFPE    -> "FPE"
  | SIGHUP    -> "HUP"
  | SIGILL    -> "ILL"
  | SIGINT    -> "INT"
  | SIGKILL   -> "KILL"
  | SIGPIPE   -> "PIPE"
  | SIGQUIT   -> "QUIT"
  | SIGSEGV   -> "SEGV"
  | SIGSTOP   -> "STOP"
  | SIGTERM   -> "TERM"
  | SIGTSTP   -> "TSTP"
  | SIGTTIN   -> "TTIN"
  | SIGTTOU   -> "TTOU"
  | SIGUSR1   -> "USR1"
  | SIGUSR2   -> "USR2"
  | SIGTRAP   -> "TRAP"
  | SIGURG    -> "URG"
  | SIGXCPU   -> "XCPU"
  | SIGXFSZ   -> "XFSZ"
  end

val ocaml_sigabrt   : int
declare ocaml target_rep function ocaml_sigabrt = `Sys.sigabrt`
val ocaml_sigalrm   : int
declare ocaml target_rep function ocaml_sigalrm = `Sys.sigalrm`
val ocaml_sigbus    : int
declare ocaml target_rep function ocaml_sigbus = `Sys.sigbus`
val ocaml_sigchld   : int
declare ocaml target_rep function ocaml_sigchld = `Sys.sigchld`
val ocaml_sigcont   : int
declare ocaml target_rep function ocaml_sigcont = `Sys.sigcont`
val ocaml_sigfpe    : int
declare ocaml target_rep function ocaml_sigfpe = `Sys.sigfpe`
val ocaml_sighup    : int
declare ocaml target_rep function ocaml_sighup = `Sys.sighup`
val ocaml_sigill    : int
declare ocaml target_rep function ocaml_sigill = `Sys.sigill`
val ocaml_sigint    : int
declare ocaml target_rep function ocaml_sigint = `Sys.sigint`
val ocaml_sigkill   : int
declare ocaml target_rep function ocaml_sigkill = `Sys.sigkill`
val ocaml_sigpipe   : int
declare ocaml target_rep function ocaml_sigpipe = `Sys.sigpipe`
val ocaml_sigquit   : int
declare ocaml target_rep function ocaml_sigquit = `Sys.sigquit`
val ocaml_sigsegv   : int
declare ocaml target_rep function ocaml_sigsegv = `Sys.sigsegv`
val ocaml_sigstop   : int
declare ocaml target_rep function ocaml_sigstop = `Sys.sigstop`
val ocaml_sigterm   : int
declare ocaml target_rep function ocaml_sigterm = `Sys.sigterm`
val ocaml_sigtstp   : int
declare ocaml target_rep function ocaml_sigtstp = `Sys.sigtstp`
val ocaml_sigttin   : int
declare ocaml target_rep function ocaml_sigttin = `Sys.sigttin`
val ocaml_sigttou   : int
declare ocaml target_rep function ocaml_sigttou = `Sys.sigttou`
val ocaml_sigusr1   : int
declare ocaml target_rep function ocaml_sigusr1 = `Sys.sigusr1`
val ocaml_sigusr2   : int
declare ocaml target_rep function ocaml_sigusr2 = `Sys.sigusr2`
val ocaml_sigtrap   : int
declare ocaml target_rep function ocaml_sigtrap = `Sys.sigtrap`
val ocaml_sigurg    : int
declare ocaml target_rep function ocaml_sigurg = `Sys.sigurg`
val ocaml_sigxcpu   : int
declare ocaml target_rep function ocaml_sigxcpu = `Sys.sigxcpu`
val ocaml_sigxfsz   : int
declare ocaml target_rep function ocaml_sigxfsz = `Sys.sigxfsz`

val ocaml_signal_of_signal : signal -> int
let ocaml_signal_of_signal signal =
  match signal with
  | SIGABRT   -> ocaml_sigabrt
  | SIGALRM   -> ocaml_sigalrm
  | SIGBUS    -> ocaml_sigbus
  | SIGCHLD   -> ocaml_sigchld
  | SIGCONT   -> ocaml_sigcont
  | SIGFPE    -> ocaml_sigfpe
  | SIGHUP    -> ocaml_sighup
  | SIGILL    -> ocaml_sigill
  | SIGINT    -> ocaml_sigint
  | SIGKILL   -> ocaml_sigkill
  | SIGPIPE   -> ocaml_sigpipe
  | SIGQUIT   -> ocaml_sigquit
  | SIGSEGV   -> ocaml_sigsegv
  | SIGSTOP   -> ocaml_sigstop
  | SIGTERM   -> ocaml_sigterm
  | SIGTSTP   -> ocaml_sigtstp
  | SIGTTIN   -> ocaml_sigttin
  | SIGTTOU   -> ocaml_sigttou
  | SIGUSR1   -> ocaml_sigusr1
  | SIGUSR2   -> ocaml_sigusr2
  | SIGTRAP   -> ocaml_sigtrap
  | SIGURG    -> ocaml_sigurg
  | SIGXCPU   -> ocaml_sigxcpu
  | SIGXFSZ   -> ocaml_sigxfsz
  end
