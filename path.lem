open import Fsh

open import Pattern

val break : forall 'a. ('a -> bool) -> list 'a -> (list 'a) * (list 'a)
let rec break p ls =
  match ls with
  | [] -> ([], [])
  | x::xs ->
    if p x
    then ([], xs)
    else let (xs', xs'') = break p xs in (x::xs', xs'')
  end

val split : list char -> list (list char)
let rec split cs =
  (* TODO: don't break a trailing slash
   * /c*/../ should find /c/../ not /c/.. *)
  match break ((=) #'/') cs with
  | ([], []) -> []
  | (cs', []) -> [cs']
  | (cs', cs'') -> cs'::(split cs'')
  end

type path_info = <| path_prefix : string
                  ; trailing_slash : bool
                  |>

val has_leading_dot : list char -> bool
let has_leading_dot = function
  | #'.'::_ -> true
  | _ -> false
  end

val has_trailing_slash : list char -> bool
let has_trailing_slash cs =
  match reverse cs with
  | #'/'::_ -> true
  | _ -> false
  end

val parse_path_pattern : ty_os_state -> string -> list string * fs * path_info
let parse_path_pattern st pat =
  match toCharList pat with
  | #'/'::pat' -> (map toString (split pat'), st.fs_root, <| path_prefix = "/"; trailing_slash = has_trailing_slash pat' |>)
  | chars -> (map toString (split chars), st.sh.cwd, <| path_prefix = ""; trailing_slash = has_trailing_slash chars |>)
  end

(* We use shortest matching because we won't look at the content of the match.
 * We only care whether or not there was a match.
 *)
val match_pattern_file_list : locale -> fs -> string -> set (string * file)
let match_pattern_file_list lc fs pat =
  (* TODO:
    * Is first character literal '.'
    * if not, remove all dot files from list
  let should_remove_dot_files =
    match (toCharList pat) with
    | #'.'::_ -> true
    | _ -> false
    end
  in
    *)
  Set.filter
    (fun (file, _) -> 
      match match_prefix lc Shortest (stringToSymbolicString pat) (stringToSymbolicString file) with
      | Match _ -> not (has_leading_dot (toCharList file)) || has_leading_dot (toCharList pat)
      | _ -> false
      end)
    (* Only compare equality for the set based on the keys.
     * Comparing equality of a non-trivial file system will loop infinitely. *)
    (toSetBy (fun (str, _)  (str', _) -> compare str str') fs.contents)

val stringToFs : fs -> string -> set fs -> set fs
let stringtoFs fs k set =
  match Map.lookup k fs.contents with
  | Just fs' -> Set.insert fs' set
  | _ -> set
  end


val match_dir : fs -> locale -> string -> set (string * file)
let match_dir dir lc name =
  match name with
  | "." -> Set.singleton (".", Dir dir)
  | ".." -> Set.singleton ("..", Dir (dotdot dir))
  | _ -> match_pattern_file_list lc dir name
  end

val walk : (maybe string * fs) -> path_info -> locale -> list string -> set (string * file)
let rec walk (path_so_far, dir) pinfo lc path =
  match path with
  | [] ->
     let full_path =
       match path_so_far with
       (* If there is no path so far, we are matching nothing,
        * so just return the path prefix (either "" or "/") *)
       | Nothing -> pinfo.path_prefix
       (* If we have a path so far, we are done, just return that path *)
       | Just p -> p
       end in
      Set.singleton (full_path ^ if pinfo.trailing_slash then "/" else "", Dir dir)
  | path'::rest ->
    bigunionMapBy (fun (str, _) (str', _) -> compare str str') (fun (sub, file) ->
      let full_path =
        match path_so_far with
        (* If we have nothing so far we are at the start of our
         * walk. Therefore we append the path prefix. *)
        | Nothing -> pinfo.path_prefix ^ sub
        (* Insert a '/' between two directories (or a directory and a file) *)
        | Just parent -> parent ^ "/" ^ sub
        end in
      match file with
      | File -> 
         if null rest && not (pinfo.trailing_slash)
         then Set.singleton (full_path, File)
         else Set.empty
      | Dir dir' -> walk (Just full_path, dir') pinfo lc rest
      end)
      (match_dir dir lc path')
  end

val match_path : ty_os_state -> string -> list string
let match_path st path =
  let (pat,start,pinfo) = parse_path_pattern st path in
  Set_extra.toOrderedList (Set.map fst (walk (Nothing, start) pinfo st.sh.locale pat))
