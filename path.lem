open import Fsh

open import Pattern

val break : forall 'a. ('a -> bool) -> list 'a -> (list 'a) * (list 'a)
let rec break p ls =
  match ls with
  | [] -> ([], [])
  | x::xs ->
    if p x
    then ([], xs)
    else let (xs', xs'') = break p xs in (x::xs', xs'')
  end

val split : list char -> list (list char)
let rec split cs =
  (* TODO: don't break a trailing slash
   * /c*/../ should find /c/../ not /c/.. *)
  match break ((=) #'/') cs with
  | ([], []) -> []
  | (cs', []) -> [cs']
  | (cs', cs'') -> cs'::(split cs'')
  end

type pat_info = <| pat : list string
                 ; start : fs
                 ; from_root : bool
                 ; trailing_slash : bool
                 ; leading_dot : bool
                 |>

val parse_path_pattern : ty_os_state -> string -> pat_info
let parse_path_pattern st pat =
  match toCharList pat with
  | #'/'::pat' -> <| pat = map toString (split pat'); start = st.fs_root; from_root = true; trailing_slash = false; leading_dot = false |> (* FIXME *)
  | chars -> <| pat = map toString (split chars); start = st.sh.cwd; from_root = false; trailing_slash = false; leading_dot = false |> (* last two wrong *)
  end

(* We use shortest matching because we won't look at the content of the match.
 * We only care whether or not there was a match.
 *)
val match_pattern_file_list : locale -> fs -> string -> set (string * file)
let match_pattern_file_list lc fs pat =
  (* TODO:
    * Is first character literal '.'
    * if not, remove all dot files from list
  let should_remove_dot_files =
    match (toCharList pat) with
    | #'.'::_ -> true
    | _ -> false
    end
  in
    *)
  Set.filter
    (fun (file, _) -> 
      match match_prefix lc Shortest (stringToSymbolicString pat) (stringToSymbolicString file) with
      | Match _ -> true
      | _ -> false
      end)
    (* Only compare equality for the set based on the keys.
     * Comparing equality of a non-trivial file system will loop infinitely. *)
    (toSetBy (fun (str, _)  (str', _) -> compare str str') fs.contents)

val stringToFs : fs -> string -> set fs -> set fs
let stringtoFs fs k set =
  match Map.lookup k fs.contents with
  | Just fs' -> Set.insert fs' set
  | _ -> set
  end


val match_dir : fs -> locale -> string -> set (string * file)
let match_dir dir lc name =
  match name with
  | "." -> Set.singleton (".", Dir dir)
  | ".." -> Set.singleton ("..", Dir (dotdot dir))
  | _ -> match_pattern_file_list lc dir name
  end

val walk : string -> (maybe string * fs) -> locale -> list string -> set (string * file)
let rec walk path_prefix (path_so_far, dir) lc path =
  match path with
  | [] ->
     let full_path =
       match path_so_far with
       (* If there is no path so far, we are matching nothing,
        * so just return the path prefix (either "" or "/") *)
       | Nothing -> path_prefix
       (* If we have a path so far, we are done, just return that path *)
       | Just p -> p
       end in
      Set.singleton (full_path, Dir dir)
  | path'::rest ->
    let next = match_dir dir lc path' in
    bigunionMapBy (fun (str, _) (str', _) -> compare str str') (fun (sub, file) ->
      let full_path =
        match path_so_far with
        (* If we have nothing so far we are at the start of our
         * walk. Therefore we append the path prefix. *)
        | Nothing -> path_prefix ^ sub
        (* Insert a '/' between two directories (or a directory and a file) *)
        | Just parent -> parent ^ "/" ^ sub
        end in
      (* It is no longer necessary to pass through path_prefix because path_so_far will
       * never be Nothing again *)
      match (file,rest) with
      | (File,[]) -> Set.singleton (full_path, File)
      | (File,_) -> Set.empty
      | (Dir dir',_) -> walk "" (Just full_path, dir') lc rest
      end)
      next
  end

val match_path : ty_os_state -> string -> set string
let match_path st path =
  let pinfo = parse_path_pattern st path in
  let path_prefix = if pinfo.from_root then "/" else "" in
  (* ss empty? *)
  Set.map fst (walk path_prefix (Nothing, pinfo.start) st.sh.locale pinfo.pat)
