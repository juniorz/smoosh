open import Fsh

open import Pattern

val break : forall 'a. ('a -> bool) -> list 'a -> (list 'a) * (list 'a)
let rec break p ls =
  match ls with
  | [] -> ([], [])
  | x::xs ->
    if p x
    then ([], xs)
    else let (xs', xs'') = break p xs in (x::xs', xs'')
  end

val split : list char -> list (list char)
let rec split cs =
  (* TODO: don't break a trailing slash
   * /c*/../ should find /c/../ not /c/.. *)
  match break ((=) #'/') cs with
  | ([], []) -> []
  | (cs', []) -> [cs']
  | (cs', cs'') -> cs'::(split cs'')
  end

val split_slash : ty_os_state -> string -> list string * (fs * bool)
let split_slash st pat =
  match toCharList pat with
  | #'/'::pat' -> (map toString (split pat'), (st.fs_root, true))
  | chars -> (map toString (split chars), (st.sh.cwd, false))
  end

(* We use shortest matching because we won't look at the content of the match.
 * We only care whether or not there was a match.
 *)
val match_pattern_file_list : locale -> fs -> string -> set (string * file)
let match_pattern_file_list lc fs pat =
  (* TODO:
    * Is first character literal '.'
    * if not, remove all dot files from list
  let should_remove_dot_files =
    match (toCharList pat) with
    | #'.'::_ -> true
    | _ -> false
    end
  in
    *)
  Set.filter
    (fun (file, _) -> 
      match match_prefix lc Shortest (stringToSymbolicString pat) (stringToSymbolicString file) with
      | Match _ -> true
      | _ -> false
      end)
    (* Only compare equality for the set based on the keys.
     * Comparing equality of a non-trivial file system will loop infinitely. *)
    (toSetBy (fun (str, _)  (str', _) -> compare str str') fs.contents)

val stringToFs : fs -> string -> set fs -> set fs
let stringtoFs fs k set =
  match Map.lookup k fs.contents with
  | Just fs' -> Set.insert fs' set
  | _ -> set
  end


val match_dir : fs -> locale -> string -> set (string * file)
let match_dir dir lc name =
  match name with
  | "." -> Set.singleton (".", Dir dir)
  | ".." -> Set.singleton ("..", Dir (dotdot dir))
  | _ -> match_pattern_file_list lc dir name
  end

val walk : string -> (maybe string * fs) -> locale -> list string -> set (string * file)
let rec walk path_prefix (path_so_far, dir) lc path =
  match path with
  | [] ->
     let full_path =
       match path_so_far with
       (* If there is no path so far, we are matching nothing,
        * so just return the path prefix (either "" or "/") *)
       | Nothing -> path_prefix
       (* If we have a path so far, we are done, just return that path *)
       | Just p -> p
       end in
      Set.singleton (full_path, Dir dir)
  | path'::rest ->
    let next = match_dir dir lc path' in
    bigunionMapBy (fun (str, _) (str', _) -> compare str str') (fun (sub, file) ->
      let full_path =
        match path_so_far with
        (* If we have nothing so far we are at the start of our
         * walk. Therefore we append the path prefix. *)
        | Nothing -> path_prefix ^ sub
        (* Insert a '/' between two directories (or a directory and a file) *)
        | Just parent -> parent ^ "/" ^ sub
        end in
      (* It is no longer necessary to pass through path_prefix because path_so_far will
       * never be Nothing again *)
      match (file,rest) with
      | (File,[]) -> Set.singleton (full_path, File)
      | (File,_) -> Set.empty
      | (Dir dir',_) -> walk "" (Just full_path, dir') lc rest
      end)
      next
  end

val match_path : ty_os_state -> string -> set string
let match_path st path =
  let (path_parts, (start_fs, is_absolute_path)) = split_slash st path in
  let path_prefix = if is_absolute_path
               then "/"
               else ""
  in
  (* ss empty? *)
  Set.map fst (walk path_prefix (Nothing, start_fs) st.sh.locale path_parts)
