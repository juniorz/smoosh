include import Pervasives_extra
include import Fsh_num

(* ??? What character set does lem use for strings? Does it matter? *)

(**********************************************************************)
(* UTILITY FUNCTIONS **************************************************)
(**********************************************************************)

val ltrim_newlines_cl : list char -> list char
let rec ltrim_newlines_cl cl =
  match cl with
  | [] -> []
  | #'\n'::cl' -> ltrim_newlines_cl cl'
  | _ -> cl
  end

val trimr_newlines : string -> string
let trimr_newlines s =
  let cl = toCharList s in
  toString (reverse (ltrim_newlines_cl (reverse cl)))

val break : forall 'a. ('a -> bool) -> list 'a -> (list 'a) * (list 'a)
let rec break p ls =
  match ls with
  | [] -> ([], [])
  | x::xs ->
    if p x
    then ([], xs)
    else let (xs', xs'') = break p xs in (x::xs', xs'')
  end

let rec intercalate sep ss = 
  match ss with
  | [] -> ""
  | [s] -> s
  | s::ss' -> s ^ sep ^ intercalate sep ss'
  end

val break_on_esc : bool -> char -> list char -> (list char) * (list char)
let rec break_on_esc escapable sep ls =
  match (escapable,ls) with
  | (_,[]) -> ([], [])
  | (true,#'\\'::c::cs) ->
     let (cs', cs'') = break_on_esc escapable sep cs in 
     (#'\\'::c::cs', cs'')
  | (_,c::cs) ->
    if sep = c
    then ([], cs)
    else let (cs', cs'') = break_on_esc escapable sep cs in 
         (c::cs', cs'')
  end

val split_on : bool -> char -> list char -> list (list char)
let rec split_on escapable sep cs =
  match break_on_esc escapable sep cs with
  | ([], []) -> []
  | (cs', []) -> [cs']
  | (cs', cs'') -> cs'::(split_on escapable sep cs'')
  end

val split_string_on : bool -> char -> string -> list string
let split_string_on escapable sep s =
  map toString (split_on escapable sep (toCharList s))

val adjust_nth : forall 'a 'b. list 'a -> nat -> ('a -> 'a * 'b) -> maybe (list 'a * 'b)
let rec adjust_nth l n f =
  match (l,n) with
  | ([],_) -> Nothing
  | (v::l',0) -> 
     let (v',res) = f v in
     Just (v'::l',res)
  | (v::l',_) ->
     match adjust_nth l' (n-1) f with
     | Nothing -> Nothing
     | Just (l'',res) -> Just (v::l'',res)
     end
  end

(**********************************************************************)
(* LOCALES ************************************************************)
(**********************************************************************)

type range_char = 
    RChar of char
  | RCollating of string

type locale = 
  <| name : string ;
     collates : char -> string -> bool ; 
     equiv : char -> string -> bool ; 
     charclass : char -> string -> bool ; 
     range : char -> range_char -> range_char -> bool |>

(* TODO: look at LC_ environment variables, decide what to do *)

(* need functions for various locale operations on, e.g., matching collating elements, equivalence classes, character classes, and ranges *)

let between lo c hi = lo <= c && c <= hi

let rec ambient_charclass c cls = 
  match cls with     (* TODO expose is_ functions from ctypes into ocaml, just use those *)
  | "alnum" -> ambient_charclass c "alpha" || ambient_charclass c "digit"
  | "alpha" -> ambient_charclass c "upper" || ambient_charclass c "lower"
  | "blank" -> elem c (toCharList " \t")
  | "cntrl" -> ord c < ord #' ' || ord c = 127 (* del *)
  | "digit" -> elem c (toCharList "0123456789")
  | "graph" -> ambient_charclass c "alnum" || ambient_charclass c "punct"
  | "lower" -> between (ord #'a') (ord c) (ord #'z')
  | "print" -> ambient_charclass c "graph" || c = #' '
  | "punct" -> elem c (toCharList "!\"#$%&'()*+,-./:;<=>?@[\\]^_{}~|") || ord c = 200 (* grave accent *)
  | "space" -> elem c (toCharList " \t\n\r") || ord c = 11 (* VT *) || ord c = 14 (* FF *)
  | "upper" -> between (ord #'A') (ord c) (ord #'Z')
  | "xdigit" -> elem c (toCharList "0123456789ABCDEFabcdef")
  | _ -> false
  end 

let lc_ambient = 
  let collates c cls = elem c (toCharList cls) in (* TODO strcoll-ish *)
  let equiv c cls = elem c (toCharList cls) in (* derp derp *)
  let rchar (rc:range_char) : maybe char =
    match rc with
    | RChar c -> Just c
    | RCollating s -> 
       match toCharList s with
       | [c] -> Just c
       | _ -> Nothing
       end
    end in
  let range c rlo rhi = 
    match (rchar rlo, rchar rhi) with
    | (Just lo, Just hi) -> between (ord lo) (ord c) (ord hi)
    | _ -> false
    end in
  <| name = "ambient" ; collates = collates ; equiv = equiv ; charclass = ambient_charclass ; range = range |>

  
(**********************************************************************)
(* Patterns ***********************************************************)
(**********************************************************************)

type substring_mode =
  Shortest
| Longest
| Exact

type substring_side =
  Prefix
| Suffix  

(**********************************************************************)
(* Commands ***********************************************************)
(**********************************************************************)

type redir_type = To | Clobber | From | FromTo | Append
type dup_type = ToFD | FromFD
type heredoc_type = Here (* quoted heredoc name, for when the heredoc shouldn't do any expansion *) | XHere (* unquoted, do expansion *)

(**********************************************************************)
(* AST ****************************************************************)
(**********************************************************************)

type format =
    Normal
  | Default of words
  | NDefault of words
  | Assign of words
  | NAssign of words
  | Error of words
  | NError of words
  | Alt of words
  | NAlt of words
  | Length
  | Substring of substring_side * substring_mode * words
                                
(* Treating parameters niavely led to a problem when evaluating
 * ${x=${x=foo}bar${x=baz}} incorrectly when x was unset
 *)
and control =
    Tilde
  | TildeUser of string
  | Param of string * format
  | LAssign of string * expanded_words * words (* runtime technicality *)
  | LMatch of fields * substring_side * substring_mode * expanded_words * words (* runtime technicality *)
  | LError of string * expanded_words * words (* runtime technicality *)
  | Backtick of stmt
  | LBacktick of stmt (* original stmt *) * nat (* pid *) * fd (* pipe [read] *)
  | Arith of expanded_words (* runtime technicality *) * words
  | Quote of expanded_words (* runtime technicality *) * words

and entry =
    S of string
  | K of control
  | F
  | ESym of symbolic (* embedded symbolic entries *)

and words = list entry

and stmt =
    Command of list (string * words) * words * list redir
  | CommandExpAssign of list (string * expansion_state) * words * list redir
  | CommandExpArgs of list (string * fields) * expansion_state * list redir
  | CommandExpRedirs of list (string * fields) * fields * redir_state
  | Pipe of bool (* bg? *) * list stmt
  | Redir of stmt * list redir
  | RedirExpRedirs of stmt * redir_state
  | Background of stmt * list redir
  | BackgroundExpRedirs of stmt * redir_state
  | Subshell of stmt * list redir
  | SubshellExpRedirs of stmt * redir_state
  | And of stmt * stmt
  | Or of stmt * stmt
  | Not of stmt
  | Semi of stmt * stmt
  | If of stmt * stmt * stmt
  | While of stmt * stmt
  | WhileCond of stmt (* original cond *) * stmt (* current cond *) * stmt (* original body *)
  | WhileRunning of stmt (* original cond *) * stmt (* original body *) * stmt (* current body *)
  | For of string * words * stmt
  | ForExpArgs of string * expansion_state * stmt
  | ForExpanded of string * fields * stmt
  | ForRunning of string * fields * stmt (* original body *) * stmt (* current body *)
  | Case of words * list (list words * stmt)
  | CaseExpArg of expansion_state * list (list words * stmt)
  | CaseMatch of symbolic_string * list (list words * stmt)
  | CaseCheckMatch of symbolic_string * expansion_state (* current pattern *) * stmt (* current command(s) *) * list (list words * stmt) (* remaining cases *)
  | Defun of string * stmt
  | Call of nat (* outer loop_nest, to be restored *) * fields (* outer $1, $2, $3, etc *) * string (* function name *) * stmt (* orig body *) * stmt (* current body *)
  | Break of nat
  | Continue of nat
  | Return
  | Exit
  | Wait of nat (* pid *)
  | Pushredir of stmt * saved_fds
  | Done

(* TODO 2018-08-24 refactor into redir 'a with appropriate params *)
and redir = 
   | RFile of redir_type * nat * words
   | RDup of dup_type * nat * nat
   | RHeredoc of heredoc_type * nat * words

and expanding_redir =
   | XRFile of redir_type * nat * expansion_state
   | XRHeredoc of heredoc_type * nat * expansion_state

and expanded_redir = 
   | ERFile of redir_type * nat * fields
   | ERDup of dup_type * nat * nat
   | ERHeredoc of heredoc_type * nat * fields

and redir_state = list expanded_redir * maybe expanding_redir * list redir

(**********************************************************************)
(* Expansion **********************************************************)
(**********************************************************************)

and expanded_word =
   UsrF
 | ExpS of string
 | UsrS of string
 | DQuo of symbolic_string
 | EWSym of symbolic

and expanded_words = list expanded_word

(* final expansion output *)
and symbolic =
    SymArith of fields (* symbolic result of arithmetic evaluation *) (* TODO is fields necessary? *)
  | SymCommand of stmt (* symbolic result of evaluating a command *)
  | SymPat of substring_side * substring_mode * symbolic_string * symbolic_string (* symbolic result of pattern matching (mode, pat, string) *)
and symbolic_char =
    C of char
  | Sym of symbolic
and symbolic_string = list symbolic_char

and fields = list (symbolic_string)

and tmp_field =
    WFS
  | FS
  | Field of symbolic_string
  | QField of symbolic_string

and intermediate_fields = list tmp_field

and expansion_state = 
    (* the constructor name indicates the *next* step to perform *)
    ExpStart of words
  | ExpExpand of expanded_words * words 
  | ExpSplit of expanded_words
  | ExpPath of intermediate_fields
  | ExpQuote of intermediate_fields
  | ExpError of fields
  | ExpDone of fields

and expansion_step =
    ESTilde of string
  | ESParam of string
  | ESCommand of string
  | ESArith of string
  | ESSplit of string
  | ESPath of string
  | ESQuote of string
  | ESStep of string
  | ESNested of expansion_step * expansion_step
  | ESEval of expansion_step * evaluation_step

and evaluation_step =
    XSSimple of string
  | XSPipe of string
  | XSRedir of string
  | XSBackground of string
  | XSSubshell of string
  | XSAnd of string
  | XSOr of string
  | XSNot of string
  | XSSemi of string
  | XSIf of string
  | XSWhile of string
  | XSFor of string
  | XSCase of string
  | XSDefun of string
  | XSStack of string (* function name *) * evaluation_step 
  | XSStep of string
  | XSWait of string
  | XSNested of evaluation_step * evaluation_step
  | XSExpand of evaluation_step * expansion_step

(**********************************************************************)
(* SHELL STATE ********************************************************)
(**********************************************************************)

(* File descriptors *)         
and fd = nat

(* Paths *)
and path = string

(* Information for saved FDs during redirect: put in a list to indicate each FD
   e.g., Map.fromList [(0,Close);(1,Saved 31);(4,Close)] says that:
     - STDIN was opened for a redirect and should be closed
     - that STDOUT was saved as fd 31 
     - STDERR was closed before and should stay closed
     - fd 3 was closed before and should stay closed
     - fd 4 was opened for the redirect but should be closed
 *)

and saved_fd_info = Saved of fd | Close 

and saved_fds = Map.map fd saved_fd_info

(* environments *)       
and env = Map.map string symbolic_string

(* function definitions *)
and funcs = Map.map string stmt        

and ty_shell_state = <|
    (* no explicit stack of params... we use Call stmt as a stack frame *)
    positional_params: list symbolic_string; (* $0, $1, $2, $3, ... *)
    env: env;
    funcs: funcs;                 
    cwd: string;
    locale: locale;
    loop_nest: nat (* for tracking break/continue *)
 |>

val STDIN : nat
val STDOUT : nat
val STDERR : nat
let STDIN = 0
let STDOUT = 1
let STDERR = 2

(**********************************************************************)
(* SYMBOLIC STRING FUNCTIONS ******************************************)
(**********************************************************************)

val null_sym : symbolic -> maybe bool
let null_sym sym =
  match sym with
  | SymArith _ -> Just false
  | SymCommand _ -> Nothing
  | SymPat _ _ _ _-> Nothing
  end

val null_char : symbolic_char -> maybe bool
let null_char c =
  match c with
  | C _ -> Just false
  | Sym sym -> null_sym sym
  end

val null_string : symbolic_string -> maybe bool
let rec null_string sym_str = 
  match sym_str with
  | [] -> Just true
  | c::cs ->
    let only_false mb =
      match mb with
      | Just true -> Nothing
      | Just false -> Just false
      | Nothing -> Nothing
      end
    in
    match null_char c with
    | Just true -> only_false (null_string cs)
    | Just false -> Just false
    | Nothing -> only_false (null_string cs)
    end
  end

val null_fields : fields -> maybe bool
let rec null_fields fs = 
  match fs with
  | [] -> Just true
  | f::fs -> 
     match (null_string f, null_fields fs) with
     | (Just true,  Just true)  -> Just true
     | (Just false, _)          -> Just false
     | (_,          Just false) -> Just false
     | (_,          _)          -> Nothing
     end
   end

val symbolic_string_of_fields : fields -> symbolic_string
let rec symbolic_string_of_fields fs = 
  match fs with
  | [] -> []
  | [f] -> f
  | f::fs' -> f ++ [C #' '] ++ symbolic_string_of_fields fs'
  end

val maximal_char_list : symbolic_string -> (list char * symbolic_string)
let rec maximal_char_list sym_str =
  match sym_str with
  | [] -> ([], [])
  | C c::rest ->
    let (cs, sym_str') = maximal_char_list rest in
    (c::cs, sym_str')
  | Sym _::_ -> ([], sym_str)
  end

val words_of_symbolic_string : symbolic_string -> words
let rec words_of_symbolic_string sym_str =
  match sym_str with
  | [] -> []
  | C _::_ ->
    let (cs, sym_str') = maximal_char_list sym_str in
    S (toString cs)::words_of_symbolic_string sym_str'
  | Sym sym::sym_str' -> ESym sym::words_of_symbolic_string sym_str'
  end

val words_of_fields : fields -> words
let words_of_fields fs = words_of_symbolic_string (symbolic_string_of_fields fs)

val expanded_words_of_symbolic_string : symbolic_string -> expanded_words
let rec expanded_words_of_symbolic_string sym_str =
  match sym_str with
  | [] -> []
  | C _::_ ->
    let (cs, sym_str') = maximal_char_list sym_str in
    ExpS (toString cs)::expanded_words_of_symbolic_string sym_str'
  | Sym sym::sym_str' -> EWSym sym::expanded_words_of_symbolic_string sym_str'
  end

val expanded_words_of_fields : fields -> expanded_words
let expanded_words_of_fields fs = expanded_words_of_symbolic_string (symbolic_string_of_fields fs)

val symbolic_string_of_char_list : list char -> symbolic_string
let symbolic_string_of_char_list cs = map C cs

val symbolic_string_of_string : string -> symbolic_string
let symbolic_string_of_string s = symbolic_string_of_char_list (toCharList s)

val fields_of_symbolic_string : symbolic_string -> fields
let fields_of_symbolic_string s = [s]

val try_concrete : symbolic_string -> maybe string
let rec try_concrete vs =
  match vs with
  | [] -> Just ""
  | C(c)::vs' -> 
     match try_concrete vs' with
     | Nothing -> Nothing
     | Just cs -> Just (toString [c] ^ cs)
     end
  | Sym _::_ -> Nothing
  end

val try_concrete_fields : fields -> maybe string
let rec try_concrete_fields fs =
  match fs with
  | [] -> Just ""
  | ss::fs' ->
     match try_concrete ss with
     | Nothing -> Nothing
     | Just s -> 
        match try_concrete_fields fs' with
        | Nothing -> Nothing
        | Just s' -> Just (s ^ s')
        end
     end
  end
        

val symbolic_to_string : symbolic -> string
let symbolic_to_string _sym = "<<SYMBOLIC>>"

val symbolic_char_to_string : symbolic_char -> string
let symbolic_char_to_string c =
  match c with
  | C c -> toString [c]
  | Sym sym -> symbolic_to_string sym
  end

val char_list_of_symbolic_string : symbolic_string -> list char
let rec char_list_of_symbolic_string sym_str =
  match sym_str with
  | [] -> []
  | (C c::cs) -> c::char_list_of_symbolic_string cs
  | (Sym sym)::cs -> toCharList (symbolic_to_string sym) ++ char_list_of_symbolic_string cs
  end
   
val string_of_symbolic_string : symbolic_string -> string
let rec string_of_symbolic_string sym_str =
  match sym_str with
  | [] -> ""
  | c::cs -> symbolic_char_to_string c ^ string_of_symbolic_string cs
  end

val string_of_fields : fields -> string
let rec string_of_fields fs = 
  match fs with
  | [] -> ""
  | [f] -> string_of_symbolic_string f
  | f::fs' -> string_of_symbolic_string f ^ "<<FB>>" ^ string_of_fields fs'
  end

val concat_expanded : expanded_words -> symbolic_string
let rec concat_expanded w =
  match w with
  | [] -> symbolic_string_of_string ""
  | UsrF::ws -> symbolic_string_of_string " " ++ concat_expanded ws
  | ExpS s::ws -> symbolic_string_of_string s ++ concat_expanded ws
  | DQuo ss::ws -> ss ++ concat_expanded ws
    (* we don't include the quotes, since they'll be ultimately erased! *)
  | EWSym sym::ws -> Sym sym::concat_expanded ws
  | UsrS _::_ -> symbolic_string_of_string "TODO: broken invariant"
  end

val fields_of_expanded_words : expanded_words -> fields
let fields_of_expanded_words w = [concat_expanded w]
                                    
(* Number type helpers *)

val integerToFields : integer -> fields
let integerToFields n = [symbolic_string_of_string (write n)]

val int32ToFields : int32 -> fields
let int32ToFields n = [symbolic_string_of_string (write n)]

val int64ToFields : int64 -> fields
let int64ToFields n = [symbolic_string_of_string (write n)]

(* AST helpers *)

val pushredir : stmt -> saved_fds -> stmt
let pushredir stmt saved_fds =
  if Map.null saved_fds
  then stmt
  else Pushredir stmt saved_fds

val is_terminating_control : stmt -> bool
let is_terminating_control c =
  match c with
  | Exit -> true
  | Return -> true
  | Break _ -> true
  | Continue _ -> true
  | Done -> true
  | _ -> false
  end

val get_expanding_redir_state : expanding_redir -> expansion_state
let get_expanding_redir_state er =
  match er with
  | XRFile _ _ es -> es
  | XRHeredoc _ _ es -> es
  end

val is_heredoc : expanding_redir -> bool
let is_heredoc er =
  match er with
  | XRFile _ _ _ -> false
  | XRHeredoc _ _ _ -> true
  end

val set_expanding_redir_state : expansion_state -> expanding_redir -> expanding_redir
let set_expanding_redir_state es er =
  match er with
  | XRFile ty src _ -> XRFile ty src es
  | XRHeredoc ty src _ -> XRHeredoc ty src es
  end

val expand_redir : expanding_redir -> fields -> expanded_redir
let expand_redir er f =
  match er with
  | XRFile ty src _ -> ERFile ty src f
  | XRHeredoc ty src _ -> ERHeredoc ty src f
  end

val wanted_fd_of_redir : expanded_redir -> fd
let wanted_fd_of_redir er =
  match er with
  | ERFile _ fd _ -> fd
  | ERDup _ _ fd -> fd
  | ERHeredoc _ fd _ -> fd
  end

(**********************************************************************)
(* DEFAULT SHELL STATE ************************************************)
(**********************************************************************)

let env_default : env = Map.insert "?" (symbolic_string_of_string "0") Map.empty

let default_shell_state = <|
      positional_params = []; (* $0, $1, $2, $3 ... *)
      env = env_default;
      funcs = Map.empty;
      cwd = "/";
      locale = lc_ambient;
      loop_nest = 0
  |>

