open import Pervasives_extra

(*
Strings will be whatever lem uses for string
??? What character set does lem use for strings? Does it matter?
*)

(**********************************************************************)
(* Patterns ***********************************************************)
(**********************************************************************)

type substring_mode =
  Shortest
| Longest

type substring_side =
  Prefix
| Suffix  

(**********************************************************************)
(* Commands ***********************************************************)
(**********************************************************************)

type redir_type = To | Clobber | From | FromTo | Append
type dup_type = ToFD | FromFD
type heredoc_type = Here | XHere (* for when in a quote... not sure when this comes up *)

(**********************************************************************)
(* AST ****************************************************************)
(**********************************************************************)

type format =
    Normal
  | Default of words
  | NDefault of words
  | Assign of words
  | NAssign of words
  | Error of words
  | NError of words
  | Alt of words
  | NAlt of words
  | Length
  | Substring of substring_side * substring_mode * words
                                
(* Treating parameters niavely led to a problem when evaluating
 * ${x=${x=foo}bar${x=baz}} incorrectly when x was unset
 *)
and control =
    Tilde
  | TildeUser of string
  | Param of string * format
  | LAssign of string * expanded_words * words (* runtime technicality *)
  | LMatch of fields * substring_side * substring_mode * expanded_words * words (* runtime technicality *)
  | LError of string * expanded_words * words (* runtime technicality *)
  | Backtick of stmt
  | Arith of expanded_words * words
  | Quote of words

and entry =
    S of string
  | K of control
  | F
  | ESym of symbolic (* embedded symbolic entries *)

and words = list entry

and stmt = 
    Command of list (string * words) * words * list redir
  | CommandExpAssign of list (string * expansion_state) * words * list redir
  | CommandExpArgs of list (string * fields) * expansion_state * list redir
  | CommandExpanded of list (string * fields) * fields * list redir
  | Pipe of bool (* bg? *) * list stmt
  | Redir of stmt * list redir
  | Background of stmt * list redir
  | Subshell of stmt * list redir
  | And of stmt * stmt
  | Or of stmt * stmt
  | Not of stmt
  | Semi of stmt * stmt
  | If of stmt * stmt * stmt
  | While of stmt * stmt
  (*   | InWhile of stmt (* condition *) * stmt (* original body *) * stmt (* current body *) *)
  | For of string * words * stmt
  | Case of words * list (words * stmt)
  | Defun of string * stmt

and redir = 
   | RFile of redir_type * nat * words
   | RDup of dup_type * nat * nat
   | RHeredoc of heredoc_type * nat * words


(**********************************************************************)
(* Expansion **********************************************************)
(**********************************************************************)

and expanded_word =
   UsrF
 | ExpS of string
 | UsrS of string
 | DQuo of string
 | EWSym of symbolic

and expanded_words = list expanded_word

(* final expansion output *)
and symbolic =
    SymArith of fields (* symbolic result of arithmetic evaluation *) (* TODO is fields necessary? *)
  | SymCommand of stmt (* symbolic result of evaluating a command *)
  | SymPat of substring_side * substring_mode * symbolic_string * symbolic_string (* symbolic result of pattern matching (mode, pat, string) *)
and symbolic_char =
    C of char
  | Sym of symbolic
and symbolic_string = list symbolic_char

and fields = list (symbolic_string)

and tmp_field =
    WFS
  | FS
  | Field of symbolic_string
  | QField of symbolic_string

and intermediate_fields = list tmp_field

and expansion_state = 
    (* the constructor name indicates the *next* step to perform *)
    ExpStart of words
  | ExpExpand of expanded_words * words 
  | ExpSplit of expanded_words
  | ExpPath of intermediate_fields
  | ExpQuote of intermediate_fields
  | ExpError of fields
  | ExpDone of fields

and expansion_step =
    ESTilde of string
  | ESParam of string
  | ESCommand of string
  | ESArith of string
  | ESSplit of string
  | ESPath of string
  | ESQuote of string
  | ESStep of string
  | ESNested of expansion_step * expansion_step

and evaluation_step =
    XSSimple of string
  | XSPipe of string
  | XSRedir of string
  | XSBackground of string
  | XSSubshell of string
  | XSAnd of string
  | XSOr of string
  | XSNot of string
  | XSSemi of string
  | XSIf of string
  | XSWhile of string
  | XSFor of string
  | XSCase of string
  | XSDefun of string
  | XSNested of evaluation_step * evaluation_step
  | XSExpand of evaluation_step * expansion_step

(**********************************************************************)
(* SYMBOLIC STRINGS ***************************************************)
(**********************************************************************)

val null_sym : symbolic -> maybe bool
let null_sym sym =
  match sym with
  | SymArith _ -> Just false
  | SymCommand _ -> Nothing
  | SymPat _ _ _ _-> Nothing
  end

val null_char : symbolic_char -> maybe bool
let null_char c =
  match c with
  | C _ -> Just false
  | Sym sym -> null_sym sym
  end

val null_string : symbolic_string -> maybe bool
let rec null_string sym_str = 
  match sym_str with
  | [] -> Just true
  | c::cs ->
    let only_false mb =
      match mb with
      | Just true -> Nothing
      | Just false -> Just false
      | Nothing -> Nothing
      end
    in
    match null_char c with
    | Just true -> only_false (null_string cs)
    | Just false -> Just false
    | Nothing -> only_false (null_string cs)
    end
  end

val null_fields : fields -> maybe bool
let rec null_fields fs = 
  match fs with
  | [] -> Just true
  | f::fs -> 
     match (null_string f, null_fields fs) with
     | (Just true,  Just true)  -> Just true
     | (Just false, _)          -> Just false
     | (_,          Just false) -> Just false
     | (_,          _)          -> Nothing
     end
   end

val symbolic_string_of_fields : fields -> symbolic_string
let rec symbolic_string_of_fields fs = 
  match fs with
  | [] -> []
  | [f] -> f
  | f::fs' -> f ++ [C #' '] ++ symbolic_string_of_fields fs'
  end

val maximal_char_list : symbolic_string -> (list char * symbolic_string)
let rec maximal_char_list sym_str =
  match sym_str with
  | [] -> ([], [])
  | C c::rest ->
    let (cs, sym_str') = maximal_char_list rest in
    (c::cs, sym_str')
  | Sym _::_ -> ([], sym_str)
  end

val words_of_symbolic_string : symbolic_string -> words
let rec words_of_symbolic_string sym_str =
  match sym_str with
  | [] -> []
  | C _::_ ->
    let (cs, sym_str') = maximal_char_list sym_str in
    S (toString cs)::words_of_symbolic_string sym_str'
  | Sym sym::sym_str' -> ESym sym::words_of_symbolic_string sym_str'
  end

val words_of_fields : fields -> words
let words_of_fields fs = words_of_symbolic_string (symbolic_string_of_fields fs)

val expanded_words_of_symbolic_string : symbolic_string -> expanded_words
let rec expanded_words_of_symbolic_string sym_str =
  match sym_str with
  | [] -> []
  | C _::_ ->
    let (cs, sym_str') = maximal_char_list sym_str in
    ExpS (toString cs)::expanded_words_of_symbolic_string sym_str'
  | Sym sym::sym_str' -> EWSym sym::expanded_words_of_symbolic_string sym_str'
  end

val expanded_words_of_fields : fields -> expanded_words
let expanded_words_of_fields fs = expanded_words_of_symbolic_string (symbolic_string_of_fields fs)

val symbolic_string_of_char_list : list char -> symbolic_string
let symbolic_string_of_char_list cs = map C cs

val symbolic_string_of_string : string -> symbolic_string
let symbolic_string_of_string s = symbolic_string_of_char_list (toCharList s)

val fields_of_symbolic_string : symbolic_string -> fields
let fields_of_symbolic_string s = [s]

val try_concrete : symbolic_string -> maybe string
let rec try_concrete vs =
  match vs with
  | [] -> Just ""
  | C(c)::vs' -> 
     match try_concrete vs' with
     | Nothing -> Nothing
     | Just cs -> Just (toString [c] ^ cs)
     end
  | Sym _::_ -> Nothing
  end

val symbolic_to_string : symbolic -> string
let symbolic_to_string _sym = "<<SYMBOLIC>>"

val symbolic_char_to_string : symbolic_char -> string
let symbolic_char_to_string c =
  match c with
  | C c -> toString [c]
  | Sym sym -> symbolic_to_string sym
  end

val symbolic_string_to_string : symbolic_string -> string
let rec symbolic_string_to_string sym_str =
  match sym_str with
  | [] -> ""
  | c::cs -> symbolic_char_to_string c ^ symbolic_string_to_string cs
  end

val fields_to_string : fields -> string
let rec fields_to_string fs = 
  match fs with
  | [] -> "f"
  | [f] -> symbolic_string_to_string f
  | f::fs' -> symbolic_string_to_string f ^ "<<FB>>" ^ fields_to_string fs'
  end

val concat_expanded : expanded_words -> symbolic_string
let rec concat_expanded w =
  match w with
  | [] -> symbolic_string_of_string ""
  | UsrF::ws -> symbolic_string_of_string " " ++ concat_expanded ws
  | ExpS s::ws -> symbolic_string_of_string s ++ concat_expanded ws
  | DQuo s::ws -> symbolic_string_of_string s ++ concat_expanded ws
  | EWSym sym::ws -> Sym sym::concat_expanded ws
  | UsrS _::_ -> symbolic_string_of_string "TODO: broken invariant"
  end

val fields_of_expanded_words : expanded_words -> fields
let fields_of_expanded_words w = [concat_expanded w]

(**********************************************************************)
(* LOCALES ************************************************************)
(**********************************************************************)

type range_char = 
    RChar of char
  | RCollating of string

type locale = 
  <| collates : char -> string -> bool ; 
     equiv : char -> string -> bool ; 
     charclass : char -> string -> bool ; 
     range : char -> range_char -> range_char -> bool |>

(* TODO: look at LC_ environment variables, decide what to do *)

(* need functions for various locale operations on, e.g., matching collating elements, equivalence classes, character classes, and ranges *)

let between lo c hi = lo <= c && c <= hi

let rec ambient_charclass c cls = 
  match cls with     (* TODO expose is_ functions from ctypes into ocaml, just use those *)
  | "alnum" -> ambient_charclass c "alpha" || ambient_charclass c "digit"
  | "alpha" -> ambient_charclass c "upper" || ambient_charclass c "lower"
  | "blank" -> elem c (toCharList " \t")
  | "cntrl" -> ord c < ord #' ' || ord c = 127 (* del *)
  | "digit" -> elem c (toCharList "0123456789")
  | "graph" -> ambient_charclass c "alnum" || ambient_charclass c "punct"
  | "lower" -> between (ord #'a') (ord c) (ord #'z')
  | "print" -> ambient_charclass c "graph" || c = #' '
  | "punct" -> elem c (toCharList "!\"#$%&'()*+,-./:;<=>?@[\\]^_{}~|") || ord c = 200 (* grave accent *)
  | "space" -> elem c (toCharList " \t\n\r") || ord c = 11 (* VT *) || ord c = 14 (* FF *)
  | "upper" -> between (ord #'A') (ord c) (ord #'Z')
  | "xdigit" -> elem c (toCharList "0123456789ABCDEFabcdef")
  | _ -> false
  end 

let lc_ambient = 
  let collates c cls = elem c (toCharList cls) in (* TODO strcoll-ish *)
  let equiv c cls = elem c (toCharList cls) in (* derp derp *)
  let rchar (rc:range_char) : maybe char =
    match rc with
    | RChar c -> Just c
    | RCollating s -> 
       match toCharList s with
       | [c] -> Just c
       | _ -> Nothing
       end
    end in
  let range c rlo rhi = 
    match (rchar rlo, rchar rhi) with
    | (Just lo, Just hi) -> between (ord lo) (ord c) (ord hi)
    | _ -> false
    end in
  <| collates = collates ; equiv = equiv ; charclass = ambient_charclass ; range = range |>

(**********************************************************************)
(* FILESYSTEMS ********************************************************)
(**********************************************************************)

(* Broadly, directories map to contents, which are dir trees or files.
 * For now, fine, just using for pathname expansion.
 *
 * TODO: Ultimately, rely on SibylFS's detailed model *)
type fs = <|
  parent: maybe fs;
  contents: Map.map string file
|>

and file = File | Dir of fs

val file_exists : fs -> string -> bool
let file_exists f name = 
  match Map.lookup name f.contents with
  | Nothing -> false
  | Just _ -> true
  end

val is_dir : fs -> string -> bool
let is_dir f name = 
  match Map.lookup name f.contents with
  | Just File -> false
  | Just (Dir _) -> true
  | Nothing -> false (* ??? *)
  end

val is_file : fs -> string -> bool
let is_file f name = 
  match Map.lookup name f.contents with
  | Just File -> true
  | Just (Dir _) -> false
  | Nothing -> false (* ??? *)
  end

val dotdot : fs -> fs
let dotdot fs =
  match fs.parent with
  | Nothing -> fs
  | Just fs' -> fs'
  end

(**********************************************************************)
(* SHELL/OS STATE *****************************************************)
(**********************************************************************)

type ty_shell_state = <|
    env: Map.map string symbolic_string;
    cwd: fs;
    locale: locale
  |>
(* From t_fs_spec.lem_cppo line 1187 *)
type ty_os_state = <|
    passwd: Map.map string string; (* TODO relate to /etc/passwd, emulate getpwnam properly in getpwdir *)
    sh: ty_shell_state;
    fs_root: fs
  |>

let fs_empty =
  <| parent = Nothing;
     contents = Map.empty
  |>

let os_empty : ty_os_state = <|
    sh = <|
      env = Map.empty;
      cwd = fs_empty;
      locale = lc_ambient
  |>;
    passwd = Map.empty;
    fs_root = fs_empty
 |>

val print_shell_env : ty_os_state -> string
let print_shell_env st = Map_extra.fold (fun k v s -> k ^ " => " ^ symbolic_string_to_string v ^ ", " ^ s) st.sh.env ""

(* The result is nothing if the parameter is unset, and the empty string null. *)
val lookup_param : ty_os_state -> string -> maybe symbolic_string
let lookup_param s0 str = Map.lookup str s0.sh.env

val lookup_concrete_param : ty_os_state -> string -> maybe string
let lookup_concrete_param s0 str =
  match Map.lookup str s0.sh.env with
  | Nothing -> Nothing
  | Just fs -> try_concrete fs
  end

val set_param : string -> symbolic_string -> ty_os_state -> ty_os_state
let set_param x v os = <| os with sh = <| os.sh with env = Map.insert x v os.sh.env |> |>

val get_pwdir : ty_os_state -> string -> maybe string
let get_pwdir os u = Map.lookup u os.passwd

val set_pwdir : string -> string -> ty_os_state -> ty_os_state
let set_pwdir u d os = <| os with passwd = Map.insert u d (os.passwd) |>

(*--------------------------------*)
(* Nat class                      *)
(*--------------------------------*)
class ( Nat 'a )
  val fromNat : nat -> 'a
  val toNat : 'a -> nat
end

instance (Nat integer)
  let fromNat = integerFromNat
  let toNat = natFromInteger
end

instance (Nat int32)
  let fromNat = int32FromNat
  let toNat = natFromInt32
end

instance (Nat int64)
  let fromNat = int64FromNat
  let toNat = natFromInt64
end

(*--------------------------------*)
(* Read class                     *)
(*--------------------------------*)

let is_whitespace c = elem c (toCharList " \n\t")
let is_digit c = elem c (toCharList "1234567890")
let is_num_const_char c = elem c (toCharList "1234567890xabcdefABCDEF")
let is_alpha c = elem c (toCharList "abcdefghijklnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

(* Convert uppercase A-F to lowercase and then convert
 * lowercase hexdigit to integer 10 to 15. *)
val hexalpha_to_num : char -> nat
let hexalpha_to_num c =
  let num = ord c in
  if 48 <= num && num <= 57
  then num - 48
  else let lowercase = if num >= 65 && num <= 70
                       then num + 32
                       else num in
       9 + (lowercase - 96)

class ( Read 'a )
  (* Read can fail with an error message by using Left.
   * Do not use any methods that may throw errors. *)
  val read : list char -> either string 'a
  val write : 'a -> string
end

let readConstant dec hex oct acc chars =
  match chars with
  | #'0'::#'x'::cs -> hex acc cs
  | #'0'::cs -> oct acc cs
  | _ -> dec acc chars
  end

let int64Max = ((int64FromNat 2) ** 63) - 1
let int64Min = ~((int64FromNat 2) ** 63)

let int32Max = ((int32FromNat 2) ** 31) - 1
let int32Min = ~((int32FromNat 2) ** 31)

val readInteger : nat -> integer -> (list char) -> either string integer
let rec readInteger base acc chars =
  match chars with
  | [] -> Right acc
  | (c::cs) ->
     let num = hexalpha_to_num c in
      if num > base - 1 || num < 0
      then Left ((toString [c]) ^ " is not a valid base " ^ show base ^ " digit")
      else readInteger base (((integerFromNat base) * acc) + (integerFromNat num)) cs
  end

val readInt64 : nat -> int64 -> (list char) -> either string int64
let rec readInt64 base acc chars =
  match chars with
  | [] -> Right acc
  | (c::cs) ->
     let num = hexalpha_to_num c in
      if num > base - 1 || num < 0
      then Left ((toString [c]) ^ " is not a valid base " ^ show base ^ " digit")
      else let acc1 = ((int64FromNat base) * acc) + (int64FromNat num) in
           if acc1 < 0
           then Right int64Max
           else readInt64 base acc1 cs
  end

val readInt32 : nat -> int32 -> (list char) -> either string int32
let rec readInt32 base acc chars =
  match chars with
  | [] -> Right acc
  | (c::cs) ->
     let num = hexalpha_to_num c in
      if num > base - 1 || num < 0
      then Left ((toString [c]) ^ " is not a valid base " ^ show base ^ " digit")
      else let acc1 = ((int32FromNat base) * acc) + (int32FromNat num) in
           if acc1 < 0
           then Right int32Max
           else readInt32 base acc1 cs
  end


val write_helper : forall 'a. Eq 'a, Nat 'a, NumIntegerDivision 'a, NumRemainder 'a => string -> 'a -> string
let rec write_helper str n =
  if n = fromNat 0
  then str
  else let ten = fromNat 10 in
    let next_digit = n mod ten in
    write_helper ((stringFromNat (toNat next_digit)) ^ str) (n div ten)

val unbounded_write : forall 'a. Eq 'a, Ord 'a, Nat 'a, NumNegate 'a, NumIntegerDivision 'a, NumRemainder 'a => 'a -> string
let unbounded_write n =
  if n < fromNat 0
  then "-" ^ (write_helper "" (~n))
  else 
    if n = fromNat 0
    then "0"
    else write_helper "" n

val write32 : int32 -> string
val write64 : int64 -> string
declare ocaml target_rep function write32 = `Int32.to_string`
declare ocaml target_rep function write64 = `Int64.to_string`

instance ( Read integer )
  let read cs = readConstant (readInteger 10) (readInteger 16) (readInteger 8) 0 cs
  let write = unbounded_write
end

instance ( Read int64 )
  let read cs = readConstant (readInt64 10) (readInt64 16) (readInt64 8) (int64FromNat 0) cs
  let write = write64
end

instance ( Read int32 )
  let read cs = readConstant (readInt32 10) (readInt32 16) (readInt32 8) (int32FromNat 0) cs
  let write = write32
end

val integerToFields : integer -> fields
let integerToFields n = [symbolic_string_of_string (write n)]

val int32ToFields : int32 -> fields
let int32ToFields n = [symbolic_string_of_string (write n)]

val int64ToFields : int64 -> fields
let int64ToFields n = [symbolic_string_of_string (write n)]

