open import Fsh

val run_command : forall 'a. OS 'a => 
                  'a -> 
                  symbolic_string (* prog *) -> 
                  fields (* argv *) ->
                  env ->
                  fds ->
                  either ('a * string) ('a * stmt)
   
val is_special_builtin : string -> bool
let is_special_builtin s =
  elem s ["break";":";"continue";".";"eval";"exec";"exit";"export";"readonly";
          "return";"set";"shift";"times";"trap";"unset"]

val is_unspecified_utility : string -> bool
let is_unspecified_utility s =
  elem s ["alloc";"autoload";"bind";"bindkey";"builtin";"bye";"caller";"cap";
          "chdir";"clone";"comparguments";"compcall";"compctl";"compdescribe";
          "compfiles";"compgen";"compgroups";"complete";"compquote";"comptags";
          "comptry";"compvalues";"declare";"dirs";"disable";"disown";"dosh";
          "echotc";"echoti";"help";"history";"hist";"let";"local";"login";
          "logout";"map";"mapfile";"popd";"print";"pushd";"readarray";"repeat";
          "savehistory";"source";"shopt";"stop";"suspend";"typeset";"whence"]
       
let builtin_unimplemented s0 _argv _env _fds = Left (s0,"unimplemented")

(**********************************************************************)
(* SPECIAL BUILTINS ***************************************************)
(**********************************************************************)

let builtin_colon s0 _argv _env _fds = Right (exit_with 0 s0,Done)
             
let builtin_break s0 argv _env _fds =
  match argv with
  | [] -> Right (exit_with 0 s0,Break 1) (* default to just breaking the immediate loop *)
  | [s] -> match readInteger 10 0 (char_list_of_symbolic_string s) with
           | Right n -> 
              if n < 1
              then Left (s0,"break: " ^ write n ^ ": loop count out of range")
              else Right (exit_with 0 s0,Break (toNat n))
           | Left _ -> Left (s0,"break: " ^ string_of_symbolic_string s ^ ": numeric argument required")
           end
  | _ -> Left (s0,"break: too many arguments")
  end

let builtin_continue s0 argv _env _fds =
  match argv with
  | [] -> Right (exit_with 0 s0,Continue 1) (* default to just continuing the immediate loop *)
  | [s] -> match readNat (char_list_of_symbolic_string s) with
           | Right n -> Right (exit_with 0 s0,Continue n)
           | Left _ -> Left (s0,"continue: " ^ string_of_symbolic_string s ^ ": numeric argument required")
           end
  | _ -> Left (s0,"continue: too many arguments")
  end

let builtin_exit s0 argv _env _fds =
  match argv with
  | [] -> Right (s0,Exit) (* default to exit code of last command *)
  | [s] -> match readInteger 10 0 (char_list_of_symbolic_string s) with
           | Right n -> 
              if n < 1 || n > 255
              then Left (s0,"exit: " ^ write n ^ ": illegal number")
              else Right (exit_with (toNat n) s0,Exit)
           | Left _ -> Left (s0,"exit: " ^ string_of_symbolic_string s ^ ": numeric argument required")
           end
  | _ -> Left (s0,"exit: too many arguments")
  end

let builtin_return s0 argv _env _fds =
  (* 2018-03-2 the present arrangement yields exit code of 1 on error; bash gives 255 for return; dash does 2.
        unspecified in POSIX docs *)
  match argv with
  | [] -> Right (s0,Return) (* just keep the last command's return status *)
  | [s] -> match readNat (char_list_of_symbolic_string s) with
           | Right n -> Right (exit_with n s0,Return)
           | Left _ -> Left (s0,"return: " ^ string_of_symbolic_string s ^ ": numeric argument required")
           end
  | _ -> Left (s0,"return: too many arguments")
  end

let builtin_shift s0 argv _env _fds =
  let n = match argv with
    | [] -> Right 1
    | [s] -> match readNat (char_list_of_symbolic_string s) with
          | Right n -> Right n
          | Left _ -> Left ("shift: " ^ string_of_symbolic_string s ^ ": numeric argument required")
          end
    | _  -> Left ("shift: too many arguments")
    end in 
  match n with
  | Left err -> Left (s0,err)
  | Right n -> 
     if n >= length (get_shell_state s0).positional_params
     then Left (exit_with 1 s0,"shift: can't shift that many")
     else
       let s1 = 
         update_shell_state 
           (fun sh -> <| sh with positional_params = drop n sh.positional_params |>)
           s0 in
       Right (exit_with 0 s1, Done)
  end

(* TODO 2018-08-13 *)
let builtin_source = builtin_unimplemented
let builtin_eval = builtin_unimplemented
let builtin_exec = builtin_unimplemented
let builtin_export = builtin_unimplemented
let builtin_readonly = builtin_unimplemented
let builtin_set = builtin_unimplemented
let builtin_times = builtin_unimplemented
let builtin_trap = builtin_unimplemented
let builtin_unset = builtin_unimplemented
   
val special_builtins :
  forall 'a. OS 'a =>
    Map.map string ('a -> fields (* argv *) -> env -> fds -> either ('a * string) ('a * stmt))
let special_builtins =  
  Map.fromList
    [ (".", builtin_source)
    ; (":", builtin_colon)
    ; ("break", builtin_break)
    ; ("continue", builtin_continue)
    ; ("eval", builtin_eval)
    ; ("exec", builtin_exec)
    ; ("exit", builtin_exit)
    ; ("export", builtin_export)
    ; ("readonly", builtin_readonly)
    ; ("return", builtin_return)
    ; ("shift", builtin_shift)
    ; ("source", builtin_source)
    ; ("set", builtin_set)
    ; ("times", builtin_times)
    ; ("trap", builtin_trap)
    ; ("unset", builtin_unset)
    ]

(**********************************************************************)
(* ORDINARY BUILTINS **************************************************)
(**********************************************************************)
  
let builtin_true s0 _argv _env _fds = Right (exit_with 0 s0, Done)
let builtin_false s0 _argv _env _fds = Right (exit_with 1 s0, Done)

let builtin_pwd s0 _argv _env _fds =
  (* TODO 2018-08-10 support -L [allow links, no . or ..] and -P [resolve symbolic links] options *)
  let pwd = (get_shell_state s0).cwd ^ "\n" in
  Right (exit_with 0 (write_stdout pwd s0), Done)

let rec write_many_stdout ss s0 =
  match ss with
  | [] -> s0
  | [s] -> write_stdout (string_of_symbolic_string s) s0
  | s::ss' -> 
     let s1 = write_stdout (string_of_symbolic_string s ^ " ") s0 in
     write_many_stdout ss' s1
  end

let builtin_echo s0 argv _env _fds = 
  let (terminator, ss) = match argv with
    | [C #'-'; C #'n']::argv' -> ("", argv')
    | _ -> ("\n", argv)
    end in
  let s1 = write_many_stdout ss s0 in
  let s2 = write_stdout terminator s1 in
  Right (exit_with 0 s2, Done)

(* TODO 2018-08-13 *)
let builtin_alias = builtin_unimplemented
let builtin_bg = builtin_unimplemented
let builtin_cd = builtin_unimplemented
let builtin_chdir = builtin_unimplemented
let builtin_command = builtin_unimplemented
let builtin_fg = builtin_unimplemented
let builtin_getopts = builtin_unimplemented
let builtin_hash = builtin_unimplemented
let builtin_jobs = builtin_unimplemented
let builtin_kill = builtin_unimplemented
let builtin_local = builtin_unimplemented
let builtin_printf = builtin_unimplemented
let builtin_read = builtin_unimplemented
let builtin_test = builtin_unimplemented
let builtin_type = builtin_unimplemented
let builtin_ulimit = builtin_unimplemented
let builtin_umask = builtin_unimplemented
let builtin_unalias = builtin_unimplemented
let builtin_wait = builtin_unimplemented
  
val builtins :
  forall 'a. OS 'a =>
    Map.map string ('a -> fields (* argv *) -> env -> fds -> either ('a * string) ('a * stmt))
let builtins =
  Map.fromList
    [ ("[", builtin_test)
    ; ("alias", builtin_alias)
    ; ("bg", builtin_bg)
    ; ("cd", builtin_cd)
    ; ("chdir", builtin_chdir)
    ; ("command", builtin_command)
    ; ("echo", builtin_echo)
    ; ("false", builtin_false)    
    ; ("fg", builtin_fg)
    ; ("getopts", builtin_getopts)
    ; ("hash", builtin_hash)
    ; ("jobs", builtin_jobs)
    ; ("kill", builtin_kill)
    ; ("local", builtin_local)
    ; ("printf", builtin_printf)
    ; ("pwd", builtin_pwd)
    ; ("read", builtin_read)
    ; ("test", builtin_test)
    ; ("true", builtin_true)
    ; ("type", builtin_type)
    ; ("ulimit", builtin_ulimit)
    ; ("umask", builtin_umask)
    ; ("unalias", builtin_unalias)
    ; ("wait", builtin_wait)
    ]

let run_command s0 prog_name argv env fds =
  match try_concrete prog_name with
  | Nothing -> Left (s0,"can't run symbolic command")
  | Just prog ->
  (*  1a. If the command name matches the name of a special built-in utility, that special built-in utility shall be invoked. *)
     match Map.lookup prog special_builtins with
     | Just fn -> fn s0 argv env fds
     | Nothing ->
        (* 1b. b. If the command name matches the name of a utility
           listed in the following table, the results are unspecified. *)
        if is_unspecified_utility prog
        then Right (s0,Done)
        else 
          (* 1c. If the command name matches the name of a function
             known to this shell, the function shall be invoked as
             described in Function Definition Command. If the
             implementation has provided a standard utility in the
             form of a function, it shall not be recognized at this
             point. It shall be invoked in conjunction with the path
             search in step 1e. *)
          match lookup_function prog s0 with
          | Just body ->
             let sh = get_shell_state s0 in
             Right (set_function_params 0 argv s0,
                    Call sh.loop_nest sh.positional_params prog body body)
          | Nothing -> 
             (* 1d. If the command name matches the name [XSI] [Option
                Start] of the type or ulimit utility, or [Option End]
                of a utility listed in the following table, that
                utility shall be invoked. *)
             match Map.lookup prog builtins with
             | Just fn -> fn s0 argv env fds
             | Nothing ->
                (* Otherwise, the command shall be searched for using
                   the PATH environment variable as described in XBD
                   Environment Variables:

                   If the search is successful:

                   If the system has implemented the utility as a
                   regular built-in or as a shell function, it shall
                   be invoked at this point in the path search.

                   Otherwise, the shell executes the utility in a
                   separate utility environment (see Shell Execution
                   Environment) with actions equivalent to calling the
                   execl() function as defined in the System
                   Interfaces volume of POSIX.1-2008 with the path
                   argument set to the pathname resulting from the
                   search, arg0 set to the command name, and the
                   remaining execl() arguments set to the command
                   arguments (if any) and the null terminator.

                   If the execl() function fails due to an error
                   equivalent to the [ENOEXEC] error defined in the
                   System Interfaces volume of POSIX.1-2008, the shell
                   shall execute a command equivalent to having a
                   shell invoked with the pathname resulting from the
                   search as its first operand, with any remaining
                   arguments passed to the new shell, except that the
                   value of "$0" in the new shell may be set to the
                   command name. If the executable file is not a text
                   file, the shell may bypass this command
                   execution. In this case, it shall write an error
                   message, and shall return an exit status of 126.

                   It is unspecified whether environment variables
                   that were passed to the shell when it was invoked,
                   but were not used to initialize shell variables
                   (see Shell Variables) because they had invalid
                   names, are included in the environment passed to
                   execl() and (if execl() fails as described above)
                   to the new shell.

                   Once a utility has been searched for and found
                   (either as a result of this specific search or as
                   part of an unspecified shell start-up activity), an
                   implementation may remember its location and need
                   not search for the utility again unless the PATH
                   variable has been the subject of an assignment. If
                   the remembered location fails for a subsequent
                   invocation, the shell shall repeat the search to
                   find the new location for the utility, if any.

                   If the search is unsuccessful, the command shall
                   fail with an exit status of 127 and the shell shall
                   write an error message.

                   If the command name contains at least one <slash>,
                   the shell shall execute the utility in a separate
                   utility environment with actions equivalent to
                   calling the execl() function defined in the System
                   Interfaces volume of POSIX.1-2008 with the path and
                   arg0 arguments set to the command name, and the
                   remaining execl() arguments set to the command
                   arguments (if any) and the null terminator.

                   If the execl() function fails due to an error
                   equivalent to the [ENOEXEC] error, the shell shall
                   execute a command equivalent to having a shell
                   invoked with the command name as its first operand,
                   with any remaining arguments passed to the new
                   shell. If the executable file is not a text file,
                   the shell may bypass this command execution. In
                   this case, it shall write an error message and
                   shall return an exit status of 126.

                   It is unspecified whether environment variables
                   that were passed to the shell when it was invoked,
                   but were not used to initialize shell variables
                   (see Shell Variables) because they had invalid
                   names, are included in the environment passed to
                   execl() and (if execl() fails as described above)
                   to the new shell.

                   If the utility would be executed with file
                   descriptor 0, 1, or 2 closed, implementations may
                   execute the utility with the file descriptor open
                   to an unspecified file. If a standard utility or a
                   conforming application is executed with file
                   descriptor 0 not open for reading or with file
                   descriptor 1 or 2 not open for writing, the
                   environment in which the utility or application is
                   executed shall be deemed non-conforming, and
                   consequently the utility or application might not
                   behave as described in this standard.  *)
                (* TODO 2018-08-13 path resolution of program *)
                let (s1,pid) = fork_and_execve s0 (symbolic_string_of_string prog) argv env fds in
                Right (s1,Wait pid)
             end
          end
     end
   end
  
