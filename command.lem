open import Fsh

import Debug

val run_command : forall 'a. OS 'a => 
                  'a -> 
                  symbolic_string (* prog *) -> 
                  fields (* argv *) ->
                  env ->
                  either ('a * string) ('a * stmt)
   
val is_special_builtin : string -> bool
let is_special_builtin s =
  elem s ["break";":";"continue";".";"eval";"exec";"exit";"export";"readonly";
          "return";"set";"shift";"times";"trap";"unset"]

val is_unspecified_utility : string -> bool
let is_unspecified_utility s =
  elem s ["alloc";"autoload";"bind";"bindkey";"builtin";"bye";"caller";"cap";
          "chdir";"clone";"comparguments";"compcall";"compctl";"compdescribe";
          "compfiles";"compgen";"compgroups";"complete";"compquote";"comptags";
          "comptry";"compvalues";"declare";"dirs";"disable";"disown";"dosh";
          "echotc";"echoti";"help";"history";"hist";"let";"local";"login";
          "logout";"map";"mapfile";"popd";"print";"pushd";"readarray";"repeat";
          "savehistory";"source";"shopt";"stop";"suspend";"typeset";"whence"]
       
let builtin_unimplemented s0 _argv _env = Left (s0,"unimplemented")

val getopt : list char -> fields -> maybe (char * fields)
let rec getopt opts fields =
  match fields with
  | [] -> Nothing
  | arg::fields' ->
     match try_concrete arg with
     | Nothing -> Nothing
     | Just s -> 
        match toCharList s with
        | #'-'::c::cs -> 
           if elem c opts
           then 
             (* try to support -LP, constructions *)
             let argrest = 
               match cs with
               | [] -> fields'
               | _ -> ((C #'-')::map C cs)::fields'
               end in
             Just (c,argrest)
           else Nothing
        | _ -> Nothing
        end
     end
   end

val getopts : list char -> fields -> list char * fields
let rec getopts opts fields = 
  match getopt opts fields with
  | Nothing -> ([],fields)
  | Just (opt,fields') -> 
     let (opts,fields'') = getopts opts fields' in
     (* store in reverse order so we can process the list without needing an accumulator *)
     (opts ++ [opt],fields'')
  end

(**********************************************************************)
(* SPECIAL BUILTINS ***************************************************)
(**********************************************************************)

let builtin_colon s0 _argv _env = Right (exit_with 0 s0,Done)
             
let builtin_break s0 argv _env =
  match argv with
  | [] -> Right (exit_with 0 s0, Break 1) (* default to just breaking the immediate loop *)
  | [s] -> match readInteger 10 0 (char_list_of_symbolic_string s) with
           | Right n -> 
              if n < 1
              then Left (s0,"break: " ^ write n ^ ": loop count out of range")
              else Right (exit_with 0 s0,Break (toNat n))
           | Left _ -> Left (s0,"break: " ^ string_of_symbolic_string s ^ ": numeric argument required")
           end
  | _ -> Left (s0,"break: too many arguments")
  end

let builtin_continue s0 argv _env =
  match argv with
  | [] -> Right (exit_with 0 s0,Continue 1) (* default to just continuing the immediate loop *)
  | [s] -> match readNat (char_list_of_symbolic_string s) with
           | Right n -> Right (exit_with 0 s0,Continue n)
           | Left _ -> Left (s0,"continue: " ^ string_of_symbolic_string s ^ ": numeric argument required")
           end
  | _ -> Left (s0,"continue: too many arguments")
  end

let builtin_exit s0 argv _env =
  match argv with
  | [] -> Right (s0,Exit) (* default to exit code of last command *)
  | [s] -> match readInteger 10 0 (char_list_of_symbolic_string s) with
           | Right n -> 
              if n < 1 || n > 255
              then Left (s0,"exit: " ^ write n ^ ": illegal number")
              else Right (exit_with (toNat n) s0,Exit)
           | Left _ -> Left (s0,"exit: " ^ string_of_symbolic_string s ^ ": numeric argument required")
           end
  | _ -> Left (s0,"exit: too many arguments")
  end

let builtin_return s0 argv _env =
  (* 2018-03-2 the present arrangement yields exit code of 1 on error; bash gives 255 for return; dash does 2.
        unspecified in POSIX docs *)
  match argv with
  | [] -> Right (s0,Return) (* just keep the last command's return status *)
  | [s] -> match readNat (char_list_of_symbolic_string s) with
           | Right n -> Right (exit_with n s0,Return)
           | Left _ -> Left (s0,"return: " ^ string_of_symbolic_string s ^ ": numeric argument required")
           end
  | _ -> Left (s0,"return: too many arguments")
  end

let builtin_shift s0 argv _env =
  let n = match argv with
    | [] -> Right 1
    | [s] -> match readNat (char_list_of_symbolic_string s) with
          | Right n -> Right n
          | Left _ -> Left ("shift: " ^ string_of_symbolic_string s ^ ": numeric argument required")
          end
    | _  -> Left ("shift: too many arguments")
    end in 
  match n with
  | Left err -> Left (s0,err)
  | Right n -> 
     if n >= length (get_shell_state s0).positional_params
     then Left (exit_with 1 s0,"shift: can't shift that many")
     else
       let s1 = 
         update_shell_state 
           (fun sh -> <| sh with positional_params = drop n sh.positional_params |>)
           s0 in
       Right (exit_with 0 s1, Done)
  end

(* TODO 2018-08-13 *)
let builtin_source = builtin_unimplemented
let builtin_eval = builtin_unimplemented
let builtin_exec = builtin_unimplemented
let builtin_export = builtin_unimplemented
let builtin_readonly = builtin_unimplemented
let builtin_set = builtin_unimplemented
let builtin_times = builtin_unimplemented
let builtin_trap = builtin_unimplemented
let builtin_unset = builtin_unimplemented
   
val special_builtins :
  forall 'a. OS 'a =>
    Map.map string ('a -> fields (* argv *) -> env -> either ('a * string) ('a * stmt))
let special_builtins =  
  Map.fromList
    [ (".", builtin_source)
    ; (":", builtin_colon)
    ; ("break", builtin_break)
    ; ("continue", builtin_continue)
    ; ("eval", builtin_eval)
    ; ("exec", builtin_exec)
    ; ("exit", builtin_exit)
    ; ("export", builtin_export)
    ; ("readonly", builtin_readonly)
    ; ("return", builtin_return)
    ; ("shift", builtin_shift)
    ; ("source", builtin_source)
    ; ("set", builtin_set)
    ; ("times", builtin_times)
    ; ("trap", builtin_trap)
    ; ("unset", builtin_unset)
    ]

(**********************************************************************)
(* ORDINARY BUILTINS **************************************************)
(**********************************************************************)
  
let builtin_true s0 _argv _env = Right (exit_with 0 s0, Done)
let builtin_false s0 _argv _env = Right (exit_with 1 s0, Done)

type path_mode = Link | Physical

val path_mode : list char -> path_mode
let rec path_mode opts =
  match opts with
  | [] -> Link
  | #'P'::_ -> Physical
  | #'L'::_ -> Link
  | _::opts -> path_mode opts
  end 

val resolve_path_mode : forall 'a. OS 'a => 'a -> path_mode -> 'a * string
let resolve_path_mode s0 mode =
  match mode with
  | Link -> (s0, (get_shell_state s0).cwd)
  | Physical -> 
     let pwd = physical_cwd s0 in
     let s1 = update_shell_state (fun sh -> <| sh with cwd = pwd |>) s0 in
     (set_param "PWD" (symbolic_string_of_string pwd) s1, pwd)
  end

let builtin_pwd s0 argv _env =
  let (opts,_argv') = getopts [#'L';#'P'] argv in
  let mode = path_mode opts in
  let (s1,pwd) = resolve_path_mode s0 mode in
  Right (exit_with 0 (write_stdout (pwd ^ "\n") s1), Done)

let rec write_many_stdout ss s0 =
  match ss with
  | [] -> s0
  | [s] -> write_stdout (string_of_symbolic_string s) s0
  | s::ss' -> 
     let s1 = write_stdout (string_of_symbolic_string s ^ " ") s0 in
     write_many_stdout ss' s1
  end

let builtin_echo s0 argv _env = 
  let (terminator, ss) = match argv with
    | [C #'-'; C #'n']::argv' -> ("", argv')
    | _ -> ("\n", argv)
    end in
  let s1 = write_many_stdout ss s0 in
  let s2 = write_stdout terminator s1 in
  Right (exit_with 0 s2, Done)

val resolve_path_with : (path -> bool) -> list path -> string -> maybe path
let rec resolve_path_with ok path name = 
  let attempt altered path' = 
     if ok altered
     then Just altered
     else resolve_path_with ok path' name
  in
  match path with
  | [] -> Nothing
  | ""::path' -> attempt ("./" ^ name) path' (* 'legacy feature' in PATH per 8.3 *)
  | pwd::path' -> attempt (join_path pwd name) path'
  end

let do_cd s0 mode dir =   
  let (curpath,need_print) =
    if first_is_slash dir
    then
      (* 3. If the directory operand begins with a <slash> character,
         set curpath to the operand and proceed to step 7. *)
      (dir,false)
    else if dir = "." || dir = ".." || 
            toString (take 2 (toCharList dir)) = "./" || 
            toString (take 3 (toCharList dir)) = "../"
    then 
      (* 4. If the first component of the directory operand is dot or
         dot-dot, proceed to step 6. *)
      (* 6. Set curpath to the directory operand. *)
      (* onward! *)
      (dir,false)
    else 
  (* 5. Starting with the first pathname in the <colon>-separated
     pathnames of CDPATH (see the ENVIRONMENT VARIABLES section) if
     the pathname is non-null, test if the concatenation of that
     pathname, a <slash> character if that pathname did not end with a
     <slash> character, and the directory operand names a
     directory. If the pathname is null, test if the concatenation of
     dot, a <slash> character, and the operand names a directory. In
     either case, if the resulting string names an existing directory,
     set curpath to that string and proceed to step 7. Otherwise,
     repeat this step with the next pathname in CDPATH until all
     pathnames have been tested. *)
      match lookup_concrete_param s0 "CDPATH" with
      | Nothing -> (dir,false)
      | Just cdpath -> 
         let cdpaths = split_string_on true (* escapable *) #':' cdpath in
         match resolve_path_with (isdir s0) cdpaths dir with
         | Nothing -> (dir,false)
         | Just dir' -> (dir',true)
         end
      end
  in
  (* 7. If the -P option is in effect, proceed to step 10. If
     curpath does not begin with a <slash> character, set curpath to
     the string formed by the concatenation of the value of PWD, a
     <slash> character if the value of PWD did not end with a
     <slash> character, and curpath. *)
  let curpath' = 
    match mode with
    | Physical -> Just curpath
    | Link -> 
       let curpath'' = 
         if first_is_slash curpath
         then curpath 
         else 
           let pwd = (get_shell_state s0).cwd in
           join_path pwd curpath in
       (* 8. The curpath value shall then be converted to canonical form
          as follows, considering each component from beginning to end,
          in sequence: ... *)
       canonicalize_path s0 curpath''
    end in
  match curpath' with
  | Nothing -> Left (s0, "illegal path " ^ curpath)
  | Just curpath'' ->
     let old = (get_shell_state s0).cwd in
     let (s1,res) = chdir s0 curpath'' in
     match res with
     | Nothing -> 
        let (s2,pwd) = resolve_path_mode s1 mode in (* sets PWD *)
        let s3 = set_param "OLDPWD" (symbolic_string_of_string old) s2 in
        let s4 = 
          if need_print
          then write_stdout (pwd ^ "\n") s3
          else s3
        in
        Right (exit_with 0 s4, Done)
     | Just err -> Left (s1, err)
     end
  end

let builtin_cd s0 argv _env = 
  let (opts,argv') = getopts [#'L';#'P'] argv in
  let mode = path_mode opts in
  match argv' with
  | [] ->
    match lookup_concrete_param s0 "HOME" with
    | Nothing -> 
       (* 1. If no directory operand is given and the HOME environment
          variable is empty or undefined, the default behavior is
          implementation-defined and no further steps shall be
          taken. *)
       Left (s0, "HOME unset")
    | Just homedir -> 
       (* 2. If no directory operand is given and the HOME environment
          variable is set to a non-empty value, the cd utility shall
          behave as if the directory named in the HOME environment
          variable was specified as the directory operand. *)
       do_cd s0 mode homedir
    end
  | (C #'-'::[])::_ -> 
     (* equivalent to `cd $OLDPWD && pwd` *)
     match lookup_concrete_param s0 "OLDPWD" with
     | Nothing -> Left (s0, "can't move back to missing OLDPWD")
     | Just path -> 
        match do_cd s0 mode path with
        | Left (s1,msg) -> Left (s1,msg)
        | Right (s1, _stmt (* should be Done *)) -> 
           Right (write_stdout (path ^ "\n") s1, Done)
        end
     end
  | path::_ -> (* just ignore extra args *) 
     match try_concrete path with
     | Nothing -> Left (s0, "can't cd to symbolic path")
     | Just path -> do_cd s0 mode path
     end
  end


(* TODO 2018-08-13 *)
let builtin_alias = builtin_unimplemented
let builtin_bg = builtin_unimplemented
let builtin_chdir = builtin_unimplemented
let builtin_command = builtin_unimplemented
let builtin_fg = builtin_unimplemented
let builtin_getopts = builtin_unimplemented
let builtin_hash = builtin_unimplemented
let builtin_jobs = builtin_unimplemented
let builtin_kill = builtin_unimplemented
let builtin_local = builtin_unimplemented
let builtin_printf = builtin_unimplemented
let builtin_read = builtin_unimplemented
let builtin_test = builtin_unimplemented
let builtin_type = builtin_unimplemented
let builtin_ulimit = builtin_unimplemented
let builtin_umask = builtin_unimplemented
let builtin_unalias = builtin_unimplemented
let builtin_wait = builtin_unimplemented
  
val builtins :
  forall 'a. OS 'a =>
    Map.map string ('a -> fields (* argv *) -> env -> either ('a * string) ('a * stmt))
let builtins =
  Map.fromList
    [ ("[", builtin_test)
    ; ("alias", builtin_alias)
    ; ("bg", builtin_bg)
    ; ("cd", builtin_cd)
    ; ("chdir", builtin_chdir)
    ; ("command", builtin_command)
    ; ("echo", builtin_echo)
    ; ("false", builtin_false)    
    ; ("fg", builtin_fg)
    ; ("getopts", builtin_getopts)
    ; ("hash", builtin_hash)
    ; ("jobs", builtin_jobs)
    ; ("kill", builtin_kill)
    ; ("local", builtin_local)
    ; ("printf", builtin_printf)
    ; ("pwd", builtin_pwd)
    ; ("read", builtin_read)
    ; ("test", builtin_test)
    ; ("true", builtin_true)
    ; ("type", builtin_type)
    ; ("ulimit", builtin_ulimit)
    ; ("umask", builtin_umask)
    ; ("unalias", builtin_unalias)
    ; ("wait", builtin_wait)
    ]

let run_command s0 prog_name argv env =
  match try_concrete prog_name with
  | Nothing -> Left (s0,"can't run symbolic command")
  | Just prog ->
  (*  1a. If the command name matches the name of a special built-in utility, that special built-in utility shall be invoked. *)
     match Map.lookup prog special_builtins with
     | Just fn -> fn s0 argv env
     | Nothing ->
        (* 1b. b. If the command name matches the name of a utility
           listed in the following table, the results are unspecified. *)
        if is_unspecified_utility prog
        then Right (s0,Done)
        else 
          (* 1c. If the command name matches the name of a function
             known to this shell, the function shall be invoked as
             described in Function Definition Command. If the
             implementation has provided a standard utility in the
             form of a function, it shall not be recognized at this
             point. It shall be invoked in conjunction with the path
             search in step 1e. *)
          match lookup_function prog s0 with
          | Just body ->
             let sh = get_shell_state s0 in
             Right (set_function_params 0 argv s0,
                    Call sh.loop_nest sh.positional_params prog body body)
          | Nothing -> 
             (* 1d. If the command name matches the name [XSI] [Option
                Start] of the type or ulimit utility, or [Option End]
                of a utility listed in the following table, that
                utility shall be invoked. *)
             match Map.lookup prog builtins with
             | Just fn -> fn s0 argv env
             | Nothing ->
                (* Otherwise, the command shall be searched for using
                   the PATH environment variable as described in XBD
                   Environment Variables:

                   If the search is successful:

                   If the system has implemented the utility as a
                   regular built-in or as a shell function, it shall
                   be invoked at this point in the path search.

                   Otherwise, the shell executes the utility in a
                   separate utility environment (see Shell Execution
                   Environment) with actions equivalent to calling the
                   execl() function as defined in the System
                   Interfaces volume of POSIX.1-2008 with the path
                   argument set to the pathname resulting from the
                   search, arg0 set to the command name, and the
                   remaining execl() arguments set to the command
                   arguments (if any) and the null terminator.

                   If the execl() function fails due to an error
                   equivalent to the [ENOEXEC] error defined in the
                   System Interfaces volume of POSIX.1-2008, the shell
                   shall execute a command equivalent to having a
                   shell invoked with the pathname resulting from the
                   search as its first operand, with any remaining
                   arguments passed to the new shell, except that the
                   value of "$0" in the new shell may be set to the
                   command name. If the executable file is not a text
                   file, the shell may bypass this command
                   execution. In this case, it shall write an error
                   message, and shall return an exit status of 126.

                   It is unspecified whether environment variables
                   that were passed to the shell when it was invoked,
                   but were not used to initialize shell variables
                   (see Shell Variables) because they had invalid
                   names, are included in the environment passed to
                   execl() and (if execl() fails as described above)
                   to the new shell.

                   Once a utility has been searched for and found
                   (either as a result of this specific search or as
                   part of an unspecified shell start-up activity), an
                   implementation may remember its location and need
                   not search for the utility again unless the PATH
                   variable has been the subject of an assignment. If
                   the remembered location fails for a subsequent
                   invocation, the shell shall repeat the search to
                   find the new location for the utility, if any.

                   If the search is unsuccessful, the command shall
                   fail with an exit status of 127 and the shell shall
                   write an error message.

                   If the command name contains at least one <slash>,
                   the shell shall execute the utility in a separate
                   utility environment with actions equivalent to
                   calling the execl() function defined in the System
                   Interfaces volume of POSIX.1-2008 with the path and
                   arg0 arguments set to the command name, and the
                   remaining execl() arguments set to the command
                   arguments (if any) and the null terminator.

                   If the execl() function fails due to an error
                   equivalent to the [ENOEXEC] error, the shell shall
                   execute a command equivalent to having a shell
                   invoked with the command name as its first operand,
                   with any remaining arguments passed to the new
                   shell. If the executable file is not a text file,
                   the shell may bypass this command execution. In
                   this case, it shall write an error message and
                   shall return an exit status of 126.

                   It is unspecified whether environment variables
                   that were passed to the shell when it was invoked,
                   but were not used to initialize shell variables
                   (see Shell Variables) because they had invalid
                   names, are included in the environment passed to
                   execl() and (if execl() fails as described above)
                   to the new shell.

                   If the utility would be executed with file
                   descriptor 0, 1, or 2 closed, implementations may
                   execute the utility with the file descriptor open
                   to an unspecified file. If a standard utility or a
                   conforming application is executed with file
                   descriptor 0 not open for reading or with file
                   descriptor 1 or 2 not open for writing, the
                   environment in which the utility or application is
                   executed shall be deemed non-conforming, and
                   consequently the utility or application might not
                   behave as described in this standard.  *)
                let prog_path = 
                  match lookup_concrete_param s0 "PATH" with
                  | Nothing -> Just prog
                  | Just path -> 
                     let paths = split_string_on true (* escapable *) #':' path in
                     resolve_path_with (file_exists s0) paths prog
                  end in
                match prog_path with
                | Nothing -> 
                   let s1 = write_stderr (prog ^ ": command not found") s0 in
                   Right (exit_with 127 s1, Done)
                | Just executable ->
                   if isexec s0 executable
                   then 
                     let (s1,pid) = fork_and_execve 
                                      s0 
                                      (symbolic_string_of_string executable) 
                                      argv 
                                      env 
                     in
                     Right (s1,Wait pid)
                   else (* TODO 2018-08-20 test for text file? *)
                     let s1 = write_stderr (executable ^ ": command not executable") s0 in
                     Right (exit_with 126 s1,Done)
                end
             end
          end
     end
   end
  
