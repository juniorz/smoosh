open import Fsh

import Debug

val run_command : forall 'a. OS 'a => 
                  (os_state 'a -> stmt -> nat) -> (* eval, for fork_and_execve *)
                  os_state 'a -> 
                  symbolic_string (* prog *) -> 
                  fields (* argv *) ->
                  env ->
                  either (os_state 'a * string) 
                         (os_state 'a * stmt * bool (* restore redirs *))

(* NB that special builtins have to return the restore_redirs bool,
   but it'll automatically get set to true for everything else.  all
   of this is a bunch of silliness to properly allow exec its two
   (rather different) behaviors *)

val is_special_builtin : string -> bool
let is_special_builtin s =
  elem s ["break";":";"continue";".";"eval";"exec";"exit";"export";"readonly";
          "return";"set";"shift";"times";"trap";"unset"]

val is_unspecified_utility : string -> bool
let is_unspecified_utility s =
  elem s ["alloc";"autoload";"bind";"bindkey";"builtin";"bye";"caller";"cap";
          "chdir";"clone";"comparguments";"compcall";"compctl";"compdescribe";
          "compfiles";"compgen";"compgroups";"complete";"compquote";"comptags";
          "comptry";"compvalues";"declare";"dirs";"disable";"disown";"dosh";
          "echotc";"echoti";"help";"history";"hist";"let";"local";"login";
          "logout";"map";"mapfile";"popd";"print";"pushd";"readarray";"repeat";
          "savehistory";"source";"shopt";"stop";"suspend";"typeset";"whence"]
       
let builtin_unimplemented s0 _argv _env = Left (s0,"unimplemented")

(**********************************************************************)
(* PATH RESOLUTION ****************************************************)
(**********************************************************************)

val resolve_path_with : (path -> bool) -> list path -> string -> maybe path
let rec resolve_path_with ok path name = 
  let attempt altered path' = 
     if ok altered
     then Just altered
     else resolve_path_with ok path' name
  in
  match path with
  | [] -> Nothing
  | ""::path' -> attempt ("./" ^ name) path' (* 'legacy feature' in PATH per 8.3 *)
  | pwd::path' -> attempt (join_path pwd name) path'
  end

val resolve_command_name : forall 'a. OS 'a =>
                           os_state 'a ->
                           string ->
                           maybe string
let resolve_command_name s0 prog =
  if elem #'/' (toCharList prog)
  then 
    (* If the command name contains at least one <slash>, the shell
       shall execute the utility in a separate utility environment
       with actions equivalent to calling the execl() function defined
       in the System Interfaces volume of POSIX.1-2008 with the path
       and arg0 arguments set to the command name, and the remaining
       execl() arguments set to the command arguments (if any) and the
       null terminator. *)
    Just prog
  else
    (* Otherwise, the command shall be searched for using the PATH
       environment variable as described in XBD Environment Variables *)
    match lookup_concrete_param s0 "PATH" with
    | Nothing -> 
       (* no PATH, just see if we can find the file *)
       if file_exists s0 prog
       then Just prog
       else Nothing
    | Just path -> 
       (* try to resolve the file in the path *)
       let paths = split_string_on true (* escapable *) #':' path in
       resolve_path_with (file_exists s0) paths prog
    end

(**********************************************************************)
(* ARGUMENT PROCESSING ************************************************)
(**********************************************************************)

val getopt : list char -> fields -> maybe (maybe char * fields)
let rec getopt opts fields =
  match fields with
  | [] -> Nothing
  | arg::fields' ->
     match try_concrete arg with
     | Nothing -> Nothing
     | Just s -> 
        match toCharList s with
        | #'-'::#'-'::[] -> Just (Nothing, fields')
        | #'-'::c::cs -> 
           if elem c opts
           then 
             (* try to support -LP, constructions *)
             let argrest = 
               match cs with
               | [] -> fields'
               | _ -> ((C #'-')::map C cs)::fields'
               end in
             Just (Just c,argrest)
           else Nothing
        | _ -> Nothing
        end
     end
   end

val getopts : list char -> fields -> list char * fields
let rec getopts opts fields = 
  match getopt opts fields with
  | Nothing -> ([],fields)
  | Just (Nothing, fields') ->
     (* stop! we hit -- or some such *)
     (opts, fields')
  | Just (Just opt,fields') -> 
     let (opts,fields'') = getopts opts fields' in
     (* store in reverse order so we can process the list without needing an accumulator *)
     (opts ++ [opt],fields'')
  end

(**********************************************************************)
(* SPECIAL BUILTINS ***************************************************)
(**********************************************************************)

let builtin_colon s0 _argv _env = Right (exit_with 0 s0, Done, true)
             
let builtin_break s0 argv _env =
  match argv with
  | [] -> 
     (* default to just breaking the immediate loop *)
     Right (exit_with 0 s0, Break 1, true) 
  | [s] -> match readInteger 10 0 (char_list_of_symbolic_string s) with
           | Right n -> 
              if n < 1
              then Left (s0,write n ^ ": loop count out of range")
              else Right (exit_with 0 s0, Break (toNat n), true)
           | Left _ -> Left (s0,string_of_symbolic_string s ^ ": numeric argument required")
           end
  | _ -> Left (s0,"too many arguments")
  end

let builtin_continue s0 argv _env =
  match argv with
  | [] -> 
     (* default to just continuing the immediate loop *)
     Right (exit_with 0 s0, Continue 1, true) 
  | [s] -> match readNat (char_list_of_symbolic_string s) with
           | Right n -> Right (exit_with 0 s0, Continue n, true)
           | Left _ -> Left (s0,string_of_symbolic_string s ^ ": numeric argument required")
           end
  | _ -> Left (s0, "too many arguments")
  end

let builtin_exit s0 argv _env =
  match argv with
  | [] -> Right (s0, Exit, true) (* default to exit code of last command *)
  | [s] -> match readInteger 10 0 (char_list_of_symbolic_string s) with
           | Right n -> 
              if n < 0 || n > 255
              then Left (s0, write n ^ ": illegal number")
              else Right (exit_with (toNat n) s0, Exit, true)
           | Left _ -> Left (s0,string_of_symbolic_string s ^ ": numeric argument required")
           end
  | _ -> Left (s0, "too many arguments")
  end

let builtin_return s0 argv _env =
  (* 2018-03-2 the present arrangement yields exit code of 1 on error; bash gives 255 for return; dash does 2.
        unspecified in POSIX docs *)
  match argv with
  | [] -> Right (s0, Return, true) (* just keep the last command's return status *)
  | [s] -> match readNat (char_list_of_symbolic_string s) with
           | Right n -> Right (exit_with n s0, Return, true)
           | Left _ -> Left (s0,string_of_symbolic_string s ^ ": numeric argument required")
           end
  | _ -> Left (s0,"too many arguments")
  end

let builtin_shift s0 argv _env =
  let n = match argv with
    | [] -> Right 1
    | [s] -> match readNat (char_list_of_symbolic_string s) with
          | Right n -> Right n
          | Left _ -> Left (string_of_symbolic_string s ^ ": numeric argument required")
          end
    | _  -> Left ("too many arguments")
    end in 
  match n with
  | Left err -> Left (s0,err)
  | Right n -> 
     if n >= length s0.sh.positional_params
     then Left (exit_with 1 s0, "can't shift that many")
     else
       let s1 = 
         <| s0 with sh = 
            <| s0.sh with positional_params = drop n s0.sh.positional_params |> |>
       in
       Right (exit_with 0 s1, Done, true)
  end

val unset_var : 
  forall 'a. OS 'a => symbolic_string -> os_state 'a -> either string (os_state 'a)
let unset_var sx s0 =
  match try_concrete sx with
  | Nothing -> Left ("couldn't unset symbolic variable " ^ string_of_symbolic_string sx)
  | Just x ->
     Right <| s0 with sh = <| s0.sh with 
                                env = Map.delete x s0.sh.env;
                                readonly = Set.delete x s0.sh.readonly;
                                export = Set.delete x s0.sh.export
                           |> |>
  end

val unset_fun : 
  forall 'a. OS 'a => symbolic_string -> (os_state 'a) -> either string (os_state 'a)
let unset_fun sx s0 =
  match try_concrete sx with
  | Nothing -> Left ("couldn't unset symbolic function " ^ string_of_symbolic_string sx)
  | Just x ->
     Right <| s0 with sh = <| s0.sh with funcs = Map.delete x s0.sh.funcs |> |>
  end

let rec unset_mode opts =
  match opts with
  | [] -> unset_var
  | #'f'::_ -> unset_fun
  | #'v'::_ -> unset_var
  | _::opts -> unset_mode opts
  end 

val unset_all : forall 'a. OS 'a =>
                  (symbolic_string -> os_state 'a -> either string (os_state 'a)) ->
                  list symbolic_string ->
                  os_state 'a ->
                  either (os_state 'a * string) (os_state 'a * stmt * bool)
let rec unset_all unsetter names s0 =
  match names with
  | [] -> Right (exit_with 0 s0, Done, true)
  | name::names' ->
     match unsetter name s0 with
     | Left err -> Left (s0, err)
     | Right s1 -> unset_all unsetter names' s1
     end
  end

let builtin_unset s0 argv _env =
  let (opts,argv') = getopts [#'f'; #'v'] argv in
  (* unspec whether to unset a function if no flag is given and no such var.
     dash doesn't do it; neither will we . *)
  let unsetter = unset_mode opts in
  unset_all unsetter argv' s0

let rec show_varlist s0 cmd vs =
  match vs with
  | [] -> s0
  | v::vs' ->
     let msg = 
       cmd ^ " " ^ v ^ 
         match lookup_param s0 v with
         | Just ss -> "=" ^ quote (string_of_fields ss)
         | Nothing -> ""
         end ^
       "\n"
     in
     let s1 = write_stdout msg s0 in
     show_varlist s1 cmd vs'
  end

val update_varlist : forall 'a. OS 'a => 
   os_state 'a -> string -> (os_state 'a -> string -> os_state 'a) -> 
   list symbolic_string -> 
   either (os_state 'a * string) (os_state 'a * stmt * bool)
let rec update_varlist s0 cmd update args =
  match args with
  | [] -> Right (s0, Done, true)
  | arg::args' ->
     let (var,mvalue) = try_split_assign arg in
     (* first, try to set. if it's readonly, we're borked! *)
     match mvalue with
     | Nothing -> 
        update_varlist (update s0 var) cmd update args'
     | Just value ->
        match set_param var value s0 with
        | Left msg -> Left (s0, msg) (* var is readonly, exit early *)
        | Right s1 -> update_varlist (update s1 var) cmd update args'
        end
     end
  end

let builtin_export s0 argv _env = 
  let (opts,argv') = getopts [#'p'] argv in
  if elem #'p' opts || null argv'
  then (* print out current export vars *)
    let vars = Set_extra.toOrderedList s0.sh.export in
    Right (show_varlist s0 "export" vars, Done, true)
  else (* mark export and possibly set *)
    update_varlist 
      s0 
      "export" 
      (fun os x ->
        <| os with sh = <| os.sh with export = Set.insert x os.sh.export |> |>)
      argv'

let builtin_readonly s0 argv _env = 
  let (opts,argv') = getopts [#'p'] argv in
  if elem #'p' opts || null argv'
  then (* print out current readonly vars *)
    let vars = Set_extra.toOrderedList s0.sh.readonly in
    Right (show_varlist s0 "readonly" vars, Done, true)
  else (* mark readonly and possibly set *)
    update_varlist 
      s0 
      "readonly" 
      (fun os x ->
        <| os with sh = <| os.sh with readonly = Set.insert x os.sh.readonly |> |>)
      argv'

let builtin_times s0 _argv _env = 
  let (utime, stime, cutime, cstime) = times s0 in
  Right (write_stdout (utime ^ " " ^ stime ^ "\n" ^ cutime ^ " " ^ cstime ^ "\n") s0, 
         Done,
         true)

val parse_string : string -> list stmt
declare ocaml target_rep function parse_string = `Shim.parse_string`

val parse_file : path -> list stmt
declare ocaml target_rep function parse_file = `Shim.parse_file`

let builtin_eval s0 argv _env = 
  if null argv
  then Right (exit_with 0 s0, Done, true)
  else 
    let stmts = parse_string (string_of_fields argv) in
    (* TODO 2018-09-05 won't do the right thing for, e.g., alias *)
    Right (s0, foldr Semi (Command [] [] []) stmts, true)

let builtin_source s0 argv _env = 
  match argv with
  | [] -> Left (s0, ".: usage: . filename")
  | sfile::_ ->
     match try_concrete sfile with
     | Nothing -> 
        Left (s0, ".: couldn't handle symbolic argument " ^ string_of_symbolic_string sfile)
     | Just file ->
        let path = 
          if elem #'/' (toCharList file)
          then file
          else match lookup_concrete_param s0 "PATH" with
               | Nothing -> file
               | Just pathvar -> 
                  let paths = split_string_on true (* escapable *) #':' pathvar in
                  match resolve_path_with (file_exists s0) paths file with
                  | Nothing -> file
                  | Just path -> path
                  end
               end in
        let stmts = parse_file path in
        (* TODO 2018-09-05 won't do the right thing for, e.g., alias 
           really, we should call setinputstring
           call an appropriate parsecmd in Dash
           then process that line and continue

           pretty tricky when there are all kinds of subshells, but our popfile() discipline should work it out
         *)
        Right (s0, foldr Semi (Command [] [] []) stmts, true)
     end
  end

let builtin_exec s0 argv env =
  match argv with
  | [] -> 
     Right (s0, Done, false (* don't restore *))
  | scmd::args ->
     (* resolve the command path *)
     let cmd_path = 
       match try_concrete scmd with
       | Nothing -> scmd
       | Just cmd ->
          match resolve_command_name s0 cmd with
          | Nothing -> scmd
          | Just path -> symbolic_string_of_string path
          end
       end in
     (* leave behind an exec to the full command *)
     Right (s0, 
            Exec cmd_path args env, 
            false (* but it doesn't matter, we'll never return *))
  end

let set_getopt_longopt fields =
  match fields with
  | [] -> Nothing (* we handled raw "set -o" already *)
  | name::fields' ->
     match try_concrete name with
     | Nothing -> Nothing
     | Just longopt -> 
        match sh_opt_of_longopt longopt with
        | Nothing -> Nothing
        | Just opt -> Just (opt, fields')
        end
     end
  end

let set_getopt_shortopt c cs fields =
  match sh_opt_of_shortopt c with
  | Nothing -> Nothing
  | Just opt ->
    (* support multiple args, as in -xv *)
    let argrest = 
      match cs with
      | [] -> fields
      | _ -> ((C #'-')::map C cs)::fields
      end in
    Just (opt,argrest)
  end

val set_add_opt : list sh_opt * list sh_opt -> bool -> maybe (sh_opt * fields) -> maybe (maybe (list sh_opt * list sh_opt) * fields)
let set_add_opt (on,off) add_to_on res =
  match res with
  | Nothing -> Nothing
  | Just (opt, fields) -> 
     Just (Just (if add_to_on 
                 then (opt::on,List.delete opt off)
                 else (List.delete opt on,opt::off)), 
           fields)
  end

val set_getopt : list sh_opt * list sh_opt -> fields -> maybe (maybe (list sh_opt * list sh_opt) * fields)
let rec set_getopt opts fields =
  match fields with
  | [] -> Nothing
  | arg::fields' ->
     match try_concrete arg with
     | Nothing -> Nothing
     | Just s -> 
        match toCharList s with
        | #'-'::#'-'::[] -> Just (Nothing, fields')
        (* - means turn it ON *)
        | #'-'::#'o'::[] ->
           set_add_opt opts true (set_getopt_longopt fields')
        | #'-'::c::cs -> 
           set_add_opt opts true (set_getopt_shortopt c cs fields')
        (* + means turn it OFF *)
        | #'+'::#'o'::[] ->
           set_add_opt opts false (set_getopt_longopt fields')
        | #'+'::c::cs -> 
           set_add_opt opts false (set_getopt_shortopt c cs fields')
        | _ -> Nothing
        end
     end
   end

val set_getopts : list sh_opt * list sh_opt -> fields -> maybe ((list sh_opt * list sh_opt) * fields)
let rec set_getopts opts fields = 
  match set_getopt opts fields with
  | Nothing -> Nothing (* bad parse is a failure. need explict -- for args *)
  | Just (Nothing, fields') ->
     (* stop! we hit -- or some such *)
     Just (opts, fields')
  | Just (Just opts',fields') -> set_getopts opts' fields'
  end

let set_showopts s0 show = 
  let opt_vals = map (fun opt -> (opt, Set.member opt s0.sh.opts)) all_sh_opts in
  Right (foldr show s0 opt_vals, Done, true)

let builtin_set s0 argv _env =
  (* set [-abCefhmnuvx] [-o option] [argument...]
     set [+abCefhmnuvx] [+o option] [argument...]
     set -- [argument...]
OR
     set -o
OR
     set -o *)
  match argv with
  | [] ->
     (* dump env *)
     Right (write_stdout (printable_shell_env s0) s0, Done, true)
  | [[C #'-'; C #'o']] -> 
     (* print in human readable format; following dash *)
     set_showopts s0 
       (fun (opt,is_set) os ->
         let msg = string_of_sh_opt opt ^ " " ^ if is_set then "on" else "off" in
         write_stdout (msg ^ "\n") os)
  | [[C #'+'; C #'o']] -> 
     (* print in shell readable format *)
     set_showopts s0 
       (fun (opt,is_set) os ->
         match char_of_sh_opt opt with
         | Nothing -> os
         | Just c ->
            let switch = if is_set then #'-' else #'+' in
            let flag = toString [switch;c] in
            let msg = "set " ^ flag in
            write_stdout (msg ^ "\n") os
         end)
  | _ ->
     match set_getopts ([],[]) argv with
     | Nothing ->
        Left (s0, "illegal option")
     | Just ((on,off),params) ->
        let s1 = foldr (fun opt os -> set_sh_opt os opt) s0 on in
        let s2 = foldr (fun opt os -> unset_sh_opt os opt) s1 off in
        let s3 = set_function_params s2.sh.loop_nest (* keep the same *) params s2 in
        Right (s3, Done, true) 
     end
  end

(* TODO 2018-08-13 *)
let builtin_trap = builtin_unimplemented
   
val special_builtins :
  forall 'a. OS 'a =>
    Map.map string 
      (os_state 'a -> fields (* argv *) -> env -> 
       either (os_state 'a * string) (os_state 'a * stmt * bool))
let special_builtins =  
  Map.fromList
    [ (".", builtin_source)
    ; (":", builtin_colon)
    ; ("break", builtin_break)
    ; ("continue", builtin_continue)
    ; ("eval", builtin_eval)
    ; ("exec", builtin_exec)
    ; ("exit", builtin_exit)
    ; ("export", builtin_export)
    ; ("readonly", builtin_readonly)
    ; ("return", builtin_return)
    ; ("shift", builtin_shift)
    ; ("source", builtin_source)
    ; ("set", builtin_set)
    ; ("times", builtin_times)
    ; ("trap", builtin_trap)
    ; ("unset", builtin_unset)
    ]

(**********************************************************************)
(* ORDINARY BUILTINS **************************************************)
(**********************************************************************)
  
let builtin_true s0 _argv _env = Right (exit_with 0 s0, Done)
let builtin_false s0 _argv _env = Right (exit_with 1 s0, Done)

type path_mode = Link | Physical

val path_mode : list char -> path_mode
let rec path_mode opts =
  match opts with
  | [] -> Link
  | #'P'::_ -> Physical
  | #'L'::_ -> Link
  | _::opts -> path_mode opts
  end 

val resolve_path_mode : forall 'a. OS 'a => os_state 'a -> path_mode -> os_state 'a * string
let resolve_path_mode s0 mode =
  match mode with
  | Link -> (s0, s0.sh.cwd)
  | Physical -> 
     let pwd = physical_cwd s0 in
     let s1 = <| s0 with sh = <| s0.sh with cwd = pwd |> |> in
     (internal_set_param "PWD" (symbolic_string_of_string pwd) s1, pwd)
  end

let builtin_pwd s0 argv _env =
  let (opts,_argv') = getopts [#'L';#'P'] argv in
  let mode = path_mode opts in
  let (s1,pwd) = resolve_path_mode s0 mode in
  Right (exit_with 0 (write_stdout (pwd ^ "\n") s1), Done)

let rec write_many_stdout ss s0 =
  match ss with
  | [] -> s0
  | [s] -> write_stdout (string_of_symbolic_string s) s0
  | s::ss' -> 
     let s1 = write_stdout (string_of_symbolic_string s ^ " ") s0 in
     write_many_stdout ss' s1
  end

let builtin_echo s0 argv _env = 
  let (terminator, ss) = match argv with
    | [C #'-'; C #'n']::argv' -> ("", argv')
    | _ -> ("\n", argv)
    end in
  let s1 = write_many_stdout ss s0 in
  let s2 = write_stdout terminator s1 in
  Right (exit_with 0 s2, Done)

let do_cd s0 mode dir =   
  let (curpath,need_print) =
    if first_is_slash dir
    then
      (* 3. If the directory operand begins with a <slash> character,
         set curpath to the operand and proceed to step 7. *)
      (dir,false)
    else if dir = "." || dir = ".." || 
            toString (take 2 (toCharList dir)) = "./" || 
            toString (take 3 (toCharList dir)) = "../"
    then 
      (* 4. If the first component of the directory operand is dot or
         dot-dot, proceed to step 6. *)
      (* 6. Set curpath to the directory operand. *)
      (* onward! *)
      (dir,false)
    else 
  (* 5. Starting with the first pathname in the <colon>-separated
     pathnames of CDPATH (see the ENVIRONMENT VARIABLES section) if
     the pathname is non-null, test if the concatenation of that
     pathname, a <slash> character if that pathname did not end with a
     <slash> character, and the directory operand names a
     directory. If the pathname is null, test if the concatenation of
     dot, a <slash> character, and the operand names a directory. In
     either case, if the resulting string names an existing directory,
     set curpath to that string and proceed to step 7. Otherwise,
     repeat this step with the next pathname in CDPATH until all
     pathnames have been tested. *)
      match lookup_concrete_param s0 "CDPATH" with
      | Nothing -> (dir,false)
      | Just cdpath -> 
         let cdpaths = split_string_on true (* escapable *) #':' cdpath in
         match resolve_path_with (isdir s0) cdpaths dir with
         | Nothing -> (dir,false)
         | Just dir' -> (dir',true)
         end
      end
  in
  (* 7. If the -P option is in effect, proceed to step 10. If
     curpath does not begin with a <slash> character, set curpath to
     the string formed by the concatenation of the value of PWD, a
     <slash> character if the value of PWD did not end with a
     <slash> character, and curpath. *)
  let curpath' = 
    match mode with
    | Physical -> Just curpath
    | Link -> 
       let curpath'' = 
         if first_is_slash curpath
         then curpath 
         else join_path s0.sh.cwd curpath in
       (* 8. The curpath value shall then be converted to canonical form
          as follows, considering each component from beginning to end,
          in sequence: ... *)
       canonicalize_path s0 curpath''
    end in
  match curpath' with
  | Nothing -> Left (s0, "illegal path " ^ curpath)
  | Just curpath'' ->
     let old = s0.sh.cwd in
     let (s1,res) = chdir s0 curpath'' in
     match res with
     | Nothing -> 
        let (s2,pwd) = resolve_path_mode s1 mode in (* sets PWD *)
        let s3 = internal_set_param "OLDPWD" (symbolic_string_of_string old) s2 in
        let s4 = 
          if need_print
          then write_stdout (pwd ^ "\n") s3
          else s3
        in
        Right (exit_with 0 s4, Done)
     | Just err -> Left (s1, err)
     end
  end

let builtin_cd s0 argv _env = 
  let (opts,argv') = getopts [#'L';#'P'] argv in
  let mode = path_mode opts in
  match argv' with
  | [] ->
    match lookup_concrete_param s0 "HOME" with
    | Nothing -> 
       (* 1. If no directory operand is given and the HOME environment
          variable is empty or undefined, the default behavior is
          implementation-defined and no further steps shall be
          taken. *)
       Left (s0, "HOME unset")
    | Just homedir -> 
       (* 2. If no directory operand is given and the HOME environment
          variable is set to a non-empty value, the cd utility shall
          behave as if the directory named in the HOME environment
          variable was specified as the directory operand. *)
       do_cd s0 mode homedir
    end
  | (C #'-'::[])::_ -> 
     (* equivalent to `cd $OLDPWD && pwd` *)
     match lookup_concrete_param s0 "OLDPWD" with
     | Nothing -> Left (s0, "can't move back to missing OLDPWD")
     | Just path -> 
        match do_cd s0 mode path with
        | Left (s1,msg) -> Left (s1,msg)
        | Right (s1, _stmt (* should be Done *)) -> 
           Right (write_stdout (path ^ "\n") s1, Done)
        end
     end
  | path::_ -> (* just ignore extra args *) 
     match try_concrete path with
     | Nothing -> Left (s0, "can't cd to symbolic path")
     | Just path -> do_cd s0 mode path
     end
  end

(* TODO 2018-08-13 *)

(* interface with dash :( *)
let builtin_alias = builtin_unimplemented
let builtin_unalias = builtin_unimplemented

(* command understanding *)
let builtin_command = builtin_unimplemented
let builtin_hash = builtin_unimplemented
let builtin_type = builtin_unimplemented

(* job control *)
let builtin_bg = builtin_unimplemented
let builtin_fg = builtin_unimplemented
let builtin_fc = builtin_unimplemented
let builtin_jobs = builtin_unimplemented
let builtin_wait = builtin_unimplemented
let builtin_kill = builtin_unimplemented

(* parsing/printing *)
let builtin_getopts = builtin_unimplemented
let builtin_local = builtin_unimplemented (* unspec *)
let builtin_printf = builtin_unimplemented
let builtin_read = builtin_unimplemented
let builtin_test = builtin_unimplemented

(* POSIX user control *)
let builtin_ulimit = builtin_unimplemented
let builtin_umask = builtin_unimplemented
let builtin_newgrp = builtin_unimplemented
 
val builtins :
  forall 'a. OS 'a =>
    Map.map string 
      (os_state 'a -> fields (* argv *) -> env -> 
       either (os_state 'a * string) (os_state 'a * stmt))
let builtins =
  Map.fromList
    [ ("[", builtin_test)
    ; ("alias", builtin_alias)
    ; ("bg", builtin_bg)
    ; ("cd", builtin_cd)
    ; ("command", builtin_command)
    ; ("echo", builtin_echo)
    ; ("false", builtin_false)    
    ; ("fc", builtin_fc)
    ; ("fg", builtin_fg)
    ; ("getopts", builtin_getopts)
    ; ("hash", builtin_hash)
    ; ("jobs", builtin_jobs)
    ; ("kill", builtin_kill)
    ; ("local", builtin_local)
    ; ("newgrp", builtin_newgrp)
    ; ("printf", builtin_printf)
    ; ("pwd", builtin_pwd)
    ; ("read", builtin_read)
    ; ("test", builtin_test)
    ; ("true", builtin_true)
    ; ("type", builtin_type)
    ; ("ulimit", builtin_ulimit)
    ; ("umask", builtin_umask)
    ; ("unalias", builtin_unalias)
    ; ("wait", builtin_wait)
    ]

let run_command eval s0 prog_name argv env =
  match try_concrete prog_name with
  | Nothing -> Left (s0,"can't run symbolic command")
  | Just prog ->
     (* TODO 2018-09-06 if there's a slash, we can skip ahead. but shouldn't hurt. *)
  (*  1a. If the command name matches the name of a special built-in utility, that special built-in utility shall be invoked. *)
     match Map.lookup prog special_builtins with
     | Just fn -> fn s0 argv env
     | Nothing ->
        (* 1b. b. If the command name matches the name of a utility
           listed in the following table, the results are unspecified. *)
        if is_unspecified_utility prog
        then Right (s0, Done, true)
        else 
          (* 1c. If the command name matches the name of a function
             known to this shell, the function shall be invoked as
             described in Function Definition Command. If the
             implementation has provided a standard utility in the
             form of a function, it shall not be recognized at this
             point. It shall be invoked in conjunction with the path
             search in step 1e. *)
          match lookup_function prog s0 with
          | Just body ->
             Right (set_function_params 0 argv s0,
                    Call s0.sh.loop_nest s0.sh.positional_params prog body body,
                    true)
          | Nothing -> 
             (* 1d. If the command name matches the name [XSI] [Option
                Start] of the type or ulimit utility, or [Option End]
                of a utility listed in the following table, that
                utility shall be invoked. *)
             match Map.lookup prog builtins with
             | Just fn -> 
                (* force a restore *)
                match fn s0 argv env with
                | Left err -> Left err
                | Right (s1, stmt) -> Right (s1, stmt, true)
                end
             | Nothing ->
                match resolve_command_name s0 prog with
                | Nothing -> 
                   (* If the search is unsuccessful, the command shall
                      fail with an exit status of 127 and the shell
                      shall write an error message. *)
                   let s1 = write_stderr (prog ^ ": command not found\n") s0 in
                   Right (exit_with 127 s1, Done, true)
                | Just executable ->
                   if isexec s0 executable
                   then 
                     (* TODO 2018-09-06 support this? *)
                     (* If the execl() function fails due to an error
                        equivalent to the [ENOEXEC] error defined in
                        the System Interfaces volume of POSIX.1-2008,
                        the shell shall execute a command equivalent
                        to having a shell invoked with the pathname
                        resulting from the search as its first
                        operand, with any remaining arguments passed
                        to the new shell, except that the value of
                        "$0" in the new shell may be set to the
                        command name. If the executable file is not a
                        text file, the shell may bypass this command
                        execution. In this case, it shall write an
                        error message, and shall return an exit status
                        of 126. *)
                     let (s1,pid) = fork_and_execve 
                                      eval
                                      s0 
                                      (symbolic_string_of_string executable) 
                                      argv 
                                      env 
                     in
                     Right (s1, Wait pid, true)
                   else (* TODO 2018-08-20 test for text file? *)
                     (* If the execl() function fails due to an error
                        equivalent to the [ENOEXEC] error, the shell
                        shall execute a command equivalent to having a
                        shell invoked with the command name as its
                        first operand, with any remaining arguments
                        passed to the new shell. If the executable
                        file is not a text file, the shell may bypass
                        this command execution. In this case, it shall
                        write an error message and shall return an
                        exit status of 126. *)
                     let s1 = write_stderr (executable ^ ": command not executable\n") s0 in
                     Right (exit_with 126 s1, Done, true)
                end
             end
          end
     end
   end
  
